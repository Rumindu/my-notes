# Fetching Strategies: Eager and Lazy Loading

<!-- omit from toc -->

## Table of Contents

- [Fetching Strategies Overview](#fetching-strategies-overview)
- [Eager Loading Strategy](#eager-loading-strategy)
- [Lazy Loading Strategy](#lazy-loading-strategy)
- [Default Fetching Strategies](#default-fetching-strategies)
- [Testing Eager Loading](#testing-eager-loading)
- [Changing Fetch Strategy](#changing-fetch-strategy)
- [One-to-One Relationship Ownership](#one-to-one-relationship-ownership)
- [Fetch Strategy Limitations](#fetch-strategy-limitations)
- [Removing Relationships for Performance](#removing-relationships-for-performance)
- [Testing Lazy Loading](#testing-lazy-loading)
- [Creating Profile Repository](#creating-profile-repository)
- [Adding Test Data](#adding-test-data)
- [Lazy Loading in Action](#lazy-loading-in-action)
- [Lazy Initialization Exception](#lazy-initialization-exception)
- [Transaction Boundary Solutions](#transaction-boundary-solutions)
- [Practical Guidelines](#practical-guidelines)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Fetching Strategies Overview

- **Two main strategies**: Eager loading and lazy loading for related objects
- **Eager loading**: Related objects loaded immediately when parent entity retrieved
- **Lazy loading**: Related objects loaded only when accessed (on-demand)
- **Customizable**: Default strategies can be changed based on application needs

![Fetching Strategies Overview Diagram](assets/fetching-strategies-overview-diagram.png)

**Strategy characteristics:**
- **Performance impact**: Different strategies affect query patterns and performance
- **Memory usage**: Eager loading uses more memory, lazy loading uses less initially
- **Network calls**: Lazy loading may cause additional database queries
- **Use case dependent**: Choice depends on application access patterns

## Eager Loading Strategy

- **Immediate loading**: Related objects fetched immediately with parent entity
- **Single query**: Typically uses JOIN operations to fetch all data at once
- **Memory overhead**: All related data loaded into memory regardless of usage
- **Predictable performance**: Known query patterns, no surprise additional queries

![Eager Loading Strategy Diagram](assets/eager-loading-strategy-diagram.png)

**Eager loading benefits:**
- **Single database trip**: All data fetched in one query
- **No lazy exceptions**: Related data always available
- **Predictable queries**: Query patterns known at development time
- **Session independence**: Data available even after session closes

## Lazy Loading Strategy

- **On-demand loading**: Related objects loaded only when accessed
- **Proxy objects**: Hibernate creates proxy objects for lazy relationships
- **Session dependency**: Requires active Hibernate session when accessing data
- **Potential N+1 problem**: May cause multiple queries if not handled properly

![Lazy Loading Strategy Diagram](assets/lazy-loading-strategy-diagram.png)

**Lazy loading benefits:**
- **Memory efficiency**: Only loads data when needed
- **Initial query speed**: Faster initial queries (less data transferred)
- **Selective loading**: Can choose which relationships to load
- **Bandwidth savings**: Reduces unnecessary data transfer

## Default Fetching Strategies

- **One-to-One relationships**: Default is EAGER loading
- **Many-to-One relationships**: Default is EAGER loading
- **One-to-Many relationships**: Default is LAZY loading
- **Many-to-Many relationships**: Default is LAZY loading

![Default Fetching Strategies Chart](assets/default-fetching-strategies-chart.png)

**Strategy rationale:**
- **Single object relationships**: EAGER makes sense (minimal overhead)
- **Collection relationships**: LAZY prevents large data sets from being loaded unnecessarily
- **Performance consideration**: Collections can be large, single objects typically small
- **Customizable**: All defaults can be overridden with fetch annotations

## Testing Eager Loading

- **User-Profile relationship**: One-to-one relationship demonstrates eager loading
- **Service method**: Create method to test fetching behavior
- **SQL observation**: Enable SQL logging to see actual queries generated
- **Database setup**: Ensure test data exists for demonstration

```java
@Service
public class UserService {
    
    public void showRelatedEntities() {
        var user = userRepository.findById(2L)
            .orElseThrow();
        
        System.out.println(user.getEmail());
    }
}
```

![Eager Loading Test Method](assets/eager-loading-test-method.png)

**Generated SQL with eager loading:**
```sql
SELECT u1.id, u1.email, u1.name, u1.password, 
       p1.id, p1.bio, p1.date_of_birth, p1.loyalty_points
FROM users u1 
LEFT JOIN profiles p1 ON u1.id = p1.user_id 
WHERE u1.id = ?
```

![Eager Loading SQL Output](assets/eager-loading-sql-output.png)

**SQL analysis:**
- **Table aliases**: u1 for users table, p1 for profiles table
- **LEFT JOIN**: Ensures user retrieved even without profile
- **All columns**: Both user and profile columns selected
- **Single query**: Everything fetched in one database trip

## Changing Fetch Strategy

- **Fetch attribute**: Use fetch parameter in relationship annotations
- **FetchType.EAGER**: Explicit eager loading configuration
- **FetchType.LAZY**: Explicit lazy loading configuration
- **Override defaults**: Can change default behavior for specific relationships

```java
@Entity
public class User {
    @OneToOne(mappedBy = "user", fetch = FetchType.LAZY)
    private Profile profile;
}
```

![Fetch Strategy Configuration](assets/fetch-strategy-configuration.png)

## One-to-One Relationship Ownership

- **Ownership concept**: One side of relationship owns the foreign key
- **Owner determination**: Entity with @JoinColumn annotation is owner
- **Profile ownership**: Profile entity owns User-Profile relationship
- **Fetch strategy limitation**: Can only set fetch strategy on owning side

![One-to-One Relationship Ownership](assets/one-to-one-relationship-ownership.png)

**JPA Buddy warning example:**
```
"Specifying fetch type lazy for the non-owning side of the one-to-one 
association will not affect the loading"
```

![JPA Buddy Fetch Strategy Warning](assets/jpa-buddy-fetch-strategy-warning.png)

**Ownership identification:**
- **Foreign key location**: Table with foreign key owns relationship
- **@JoinColumn annotation**: Present on owning side
- **mappedBy attribute**: Present on non-owning side
- **Fetch strategy placement**: Must be on owning side to be effective

## Fetch Strategy Limitations

- **One-to-One limitation**: Fetch strategy only effective on owning side
- **Non-owning side**: Fetch strategy settings ignored on non-owning side
- **Practical impact**: Cannot make non-owning side lazy in one-to-one relationships
- **Design implications**: Consider relationship design for optimal fetching

```java
// Effective - on owning side (Profile entity)
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_id")
private User user;

// Ineffective - on non-owning side (User entity)
@OneToOne(mappedBy = "user", fetch = FetchType.LAZY)  // Ignored!
private Profile profile;
```

![Fetch Strategy Effectiveness](assets/fetch-strategy-effectiveness.png)

## Removing Relationships for Performance

- **Complete removal**: Comment out relationship field for optimal performance
- **Use case consideration**: User entity for authentication may not need profile
- **Query optimization**: Eliminates unnecessary JOINs completely
- **Design decision**: Balance functionality vs performance requirements

```java
@Entity
public class User {
    // Authentication-focused entity
    private String email;
    private String password;
    
    // Profile relationship removed for performance
    // @OneToOne(mappedBy = "user")
    // private Profile profile;
}
```

![Relationship Removal for Performance](assets/relationship-removal-for-performance.png)

**SQL after relationship removal:**
```sql
SELECT u1.id, u1.email, u1.name, u1.password 
FROM users u1 
WHERE u1.id = ?
-- No JOIN to profiles table
```

![Clean SQL Without Relationships](assets/clean-sql-without-relationships.png)

## Testing Lazy Loading

- **Profile repository**: Create repository for Profile entity testing
- **Lazy loading demonstration**: Show how lazy loading works in practice
- **Owner side testing**: Test fetch strategy on relationship owner
- **Query pattern analysis**: Observe lazy loading query patterns

## Creating Profile Repository

- **JPA Buddy generation**: Use JPA Buddy to create ProfileRepository
- **Repository interface**: Extend CrudRepository for basic operations
- **Entity selection**: Choose Profile as target entity
- **Parent interface**: Select CrudRepository as parent

```java
public interface ProfileRepository extends CrudRepository<Profile, Long> {
    // Inherits standard CRUD operations
}
```

![Profile Repository Creation](assets/profile-repository-creation.png)

**Repository integration:**
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final ProfileRepository profileRepository;  // Add profile repository
    
    // Constructor injection for both repositories
}
```

![Service Layer Repository Integration](assets/service-layer-repository-integration.png)

## Adding Test Data

- **Database preparation**: Add profile record for testing lazy loading
- **Manual insertion**: Use database tool to insert test profile data
- **Foreign key setup**: Link profile to existing user record
- **Minimal data**: Add only essential fields for testing

![Database Profile Record Addition](assets/database-profile-record-addition.png)

**Test data insertion:**
```sql
INSERT INTO profiles (user_id, bio) VALUES (2, 'Test bio');
```

![Profile Test Data Insertion](assets/profile-test-data-insertion.png)

## Lazy Loading in Action

- **Profile fetching**: Retrieve profile without associated user
- **Initial query**: Only profile table queried initially
- **Lazy proxy**: User field contains lazy-loaded proxy object
- **On-demand loading**: User data fetched when accessed

```java
public void showRelatedEntities() {
    var profile = profileRepository.findById(2L)
        .orElseThrow();
    
    System.out.println(profile.getBio());  // Only profile data loaded
    
    // Accessing user triggers lazy loading
    System.out.println(profile.getUser().getEmail());  // User data loaded now
}
```

![Lazy Loading Method Implementation](assets/lazy-loading-method-implementation.png)

**Initial SQL (profile only):**
```sql
SELECT p1.id, p1.bio, p1.date_of_birth, p1.loyalty_points, p1.user_id
FROM profiles p1 
WHERE p1.id = ?
-- No JOIN to users table initially
```

![Lazy Loading Initial Query](assets/lazy-loading-initial-query.png)

## Lazy Initialization Exception

- **Exception occurrence**: LazyInitializationException when accessing lazy properties
- **Root cause**: Hibernate session closed when trying to load lazy data
- **Transaction boundary**: Repository method transaction ends before lazy access
- **Session requirement**: Lazy loading requires active Hibernate session

![Lazy Initialization Exception](assets/lazy-initialization-exception.png)

**Exception scenario:**
```java
public void showRelatedEntities() {
    var profile = profileRepository.findById(2L).orElseThrow();  // Transaction ends here
    // profile is now detached
    
    System.out.println(profile.getUser().getEmail());  // LazyInitializationException!
}
```

![Exception Causing Code Pattern](assets/exception-causing-code-pattern.png)

**Why exception occurs:**
1. **Repository call**: Transaction starts and ends with findById()
2. **Session closure**: Hibernate session closes after repository method
3. **Detached entity**: Profile becomes detached from persistence context
4. **Lazy access attempt**: Trying to access user triggers exception

## Transaction Boundary Solutions

- **@Transactional annotation**: Extend transaction to encompass entire method
- **Persistence context extension**: Keep session active throughout method execution
- **Lazy loading enablement**: Allow lazy loading within extended transaction
- **Multiple query pattern**: First query for profile, second for user (lazy loading)

```java
@Transactional  // Extends transaction to entire method
public void showRelatedEntities() {
    var profile = profileRepository.findById(2L).orElseThrow();
    
    System.out.println(profile.getBio());        // Profile query
    System.out.println(profile.getUser().getEmail());  // User query (lazy load)
}
```

![Transactional Annotation Solution](assets/transactional-annotation-solution.png)

**Successful lazy loading output:**
```
Profile query: SELECT ... FROM profiles WHERE id = ?
User query: SELECT ... FROM users WHERE id = ?
john@example.com
```

![Successful Lazy Loading Queries](assets/successful-lazy-loading-queries.png)

## Practical Guidelines

- **Eager loading usage**: Use when related data always needed
- **Lazy loading usage**: Use for optional or rarely accessed relationships
- **Performance consideration**: Eager loading for small related objects, lazy for large collections
- **Access pattern analysis**: Choose strategy based on actual application usage patterns

![Fetching Strategy Decision Matrix](assets/fetching-strategy-decision-matrix.png)

**Decision factors:**
- **Data size**: Large collections should be lazy-loaded
- **Access frequency**: Frequently accessed data can be eager-loaded
- **Performance requirements**: Consider query count vs data transfer
- **Memory constraints**: Lazy loading reduces memory usage

**Best practices:**
```java
// Good for authentication
@Entity
public class User {
    @OneToOne(fetch = FetchType.LAZY)  // Profile not always needed
    private Profile profile;
}

// Good for order processing
@Entity  
public class Order {
    @ManyToOne(fetch = FetchType.EAGER)  // Customer always needed
    private Customer customer;
    
    @OneToMany(fetch = FetchType.LAZY)  // Items loaded on demand
    private List<OrderItem> items;
}
```

![Best Practices Implementation](assets/best-practices-implementation.png)

## Key Points

- **Main takeaway**: Fetching strategies control when related entities are loaded - eager loading fetches immediately, lazy loading fetches on-demand
- **Default strategies**: One-to-one and many-to-one use eager loading by default, one-to-many and many-to-many use lazy loading
- **Ownership matters**: Fetch strategy only effective on owning side of one-to-one relationships (entity with foreign key)
- **Transaction dependency**: Lazy loading requires active transaction/session, causing LazyInitializationException if session closed
- **@Transactional solution**: Apply @Transactional to service methods to keep session active for lazy loading
- **Performance considerations**: Eager loading reduces query count but increases memory usage, lazy loading reduces initial load but may cause N+1 queries
- **Strategy selection**: Use eager loading for always-needed small data, lazy loading for optional or large collections
- **Query patterns**: Eager loading uses JOINs for single query, lazy loading uses separate queries when accessed
- **Relationship removal**: Sometimes removing relationships entirely provides best performance for authentication-focused entities
- **Practical application**: Choose strategy based on actual access patterns and performance requirements rather than defaults

## Links/References

- Video: 4.8.5-Fetching-Strategies-Eager-and-Lazy-Loading.mp4 (08:24)
- Previous: [Managing Transactions](4.8.4-Managing-Transactions.md)
- Next: Advanced Querying Techniques
- Reference: [JPA Fetch Strategies](https://docs.oracle.com/javaee/7/tutorial/persistence-entitygarphs002.htm)
- Reference: [Hibernate Lazy Loading](https://docs.jboss.org/hibernate/orm/5.6/userguide/html_single/Hibernate_User_Guide.html#fetching)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

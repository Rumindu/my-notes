# Defining One-To-Many Relationships

<!-- omit from toc -->

## Table of Contents

- [Table of Contents](#table-of-contents)
- [One-To-Many Relationship Overview](#one-to-many-relationship-overview)
- [Implementing the User Side](#implementing-the-user-side)
- [Implementing the Address Side](#implementing-the-address-side)
- [Understanding Relationship Ownership](#understanding-relationship-ownership)
- [Creating Helper Methods](#creating-helper-methods)
- [Testing the Relationship](#testing-the-relationship)
- [Builder Pattern Considerations](#builder-pattern-considerations)
- [ToString Implementation](#tostring-implementation)
- [Avoiding Circular References](#avoiding-circular-references)
- [Additional Helper Methods](#additional-helper-methods)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## One-To-Many Relationship Overview

- **Relationship type**: One-to-Many between User and Address entities
- **Business rule**: One user can have many addresses, each address belongs to one user
- **Implementation types**: Unidirectional (one-sided) or Bidirectional (two-sided)
- **Course approach**: Implementing bidirectional relationship for complete navigation

![One-To-Many Relationship Diagram](assets/one-to-many-relationship-diagram.png)

**Relationship navigation:**
- **Unidirectional**: Navigate from User to Addresses only
- **Bidirectional**: Navigate both ways (User ↔ Address)
- **Database reality**: Foreign key in addresses table points to users table

## Implementing the User Side

- **Collection field**: Add List<Address> field to User entity
- **Initialization**: Initialize to new ArrayList() for immediate use
- **Annotation**: Use @OneToMany to define relationship mapping
- **Import requirement**: Import List from java.util package

```java
@Entity
@Table(name = "users")
public class User {
    // Other fields...
    
    @OneToMany(mappedBy = "user")
    private List<Address> addresses = new ArrayList<>();
    
    // Other methods...
}
```

![User Entity One-To-Many Implementation](assets/user-entity-one-to-many-implementation.png)

**Implementation steps:**
1. Add private List<Address> addresses field
2. Initialize with new ArrayList()
3. Import Address entity from entities package
4. Apply @OneToMany annotation with mappedBy attribute

## Implementing the Address Side

- **Reference field**: Add User field to Address entity
- **Annotation**: Use @ManyToOne to define reverse relationship
- **Join column**: Specify foreign key column with @JoinColumn
- **Column mapping**: Map to user_id column in addresses table

```java
@Entity
@Table(name = "addresses")
public class Address {
    // Other fields...
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    // Other methods...
}
```

![Address Entity Many-To-One Implementation](assets/address-entity-many-to-one-implementation.png)

**Implementation details:**
- **@ManyToOne**: Defines many addresses to one user relationship
- **@JoinColumn**: Specifies foreign key column name
- **Column name**: "user_id" matches database foreign key column
- **Import**: Import User entity from entities package

## Understanding Relationship Ownership

- **Ownership concept**: Each relationship has an owner entity for Hibernate
- **Database perspective**: Address table contains foreign key, so Address owns relationship
- **Conceptual vs Database**: User conceptually owns addresses, but Address owns database relationship
- **MappedBy attribute**: Tells Hibernate which entity owns the relationship

![Relationship Ownership Concept](assets/relationship-ownership-concept-diagram.png)

**Ownership determination:**
- **Owner entity**: Entity with foreign key (Address)
- **Non-owner entity**: Entity with mappedBy attribute (User)
- **MappedBy value**: Name of field in owning entity ("user")
- **SQL generation**: Hibernate uses ownership for correct SQL statements

**MappedBy configuration:**
```java
// Non-owning side (User entity)
@OneToMany(mappedBy = "user")  // "user" is field name in Address entity
private List<Address> addresses = new ArrayList<>();

// Owning side (Address entity)
@ManyToOne
@JoinColumn(name = "user_id")
private User user;  // This field name used in mappedBy
```

![MappedBy Attribute Configuration](assets/mappedby-attribute-configuration.png)

## Creating Helper Methods

- **Encapsulation need**: Two related operations should be grouped together
- **Helper method**: Create addAddress() method in User entity
- **Relationship integrity**: Ensure both sides of relationship are updated
- **IntelliJ assistance**: IDE suggests code completion for common patterns

```java
@Entity
@Table(name = "users")
public class User {
    // Fields...
    
    public void addAddress(Address address) {
        addresses.add(address);
        address.setUser(this);
    }
    
    public void removeAddress(Address address) {
        addresses.remove(address);
        address.setUser(null);
    }
}
```

![Helper Methods Implementation](assets/helper-methods-implementation.png)

**Helper method benefits:**
- **Relationship integrity**: Both sides updated simultaneously
- **Error prevention**: Prevents forgetting to update one side
- **Cleaner code**: Single method call instead of two separate operations
- **Maintainability**: Centralized relationship management logic

## Testing the Relationship

- **Builder pattern**: Add @Builder annotation to Address entity for easy object creation
- **Constructor annotations**: Add @AllArgsConstructor and @NoArgsConstructor to avoid warnings
- **Object creation**: Create User and Address objects to test relationship
- **Relationship wiring**: Use helper method to connect objects

```java
// Add to Address entity
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "addresses")
public class Address {
    // Fields and methods...
}

// Testing in main method
@SpringBootApplication
public class StoreApplication {
    public static void main(String[] args) {
        var user = User.builder()
            .name("John")
            .email("john@example.com")
            .password("password123")
            .build();
            
        var address = Address.builder()
            .street("123 Main St")
            .city("New York")
            .state("NY")
            .zip("10001")
            .build();
            
        user.addAddress(address);
        System.out.println(user);
        
        SpringApplication.run(StoreApplication.class, args);
    }
}
```

![Relationship Testing Code](assets/relationship-testing-code.png)

## Builder Pattern Considerations

- **Initialization issue**: Builder pattern skips field initializations
- **Null pointer exception**: Occurs when accessing uninitialized collections
- **Solution**: Use @Builder.Default annotation for field initialization
- **Alternative**: Avoid builder pattern if initialization is critical

![Builder Pattern Initialization Issue](assets/builder-pattern-initialization-issue.png)

**Builder.Default usage:**
```java
@Entity
@Table(name = "users")
public class User {
    @OneToMany(mappedBy = "user")
    @Builder.Default  // Ensures initialization with builder pattern
    private List<Address> addresses = new ArrayList<>();
}
```

![Builder Default Annotation Solution](assets/builder-default-annotation-solution.png)

**Builder pattern workarounds:**
- **@Builder.Default**: Include field initialization in builder
- **Avoid builder**: Use constructors if initialization is critical
- **Manual initialization**: Initialize collections in constructor

## ToString Implementation

- **Debugging aid**: @ToString annotation generates helpful string representation
- **Object inspection**: See object state during development and testing
- **Lombok generation**: Automatically includes all fields in string output
- **Development tool**: Useful for understanding object relationships

```java
@ToString
@Entity
@Table(name = "users")
public class User {
    // Fields and methods...
}
```

![ToString Annotation Implementation](assets/tostring-annotation-implementation.png)

**ToString output example:**
```
User(id=null, name=John, email=john@example.com, password=password123, 
addresses=[Address(id=null, street=123 Main St, city=New York, state=NY, zip=10001)])
```

![ToString Output Example](assets/tostring-output-example.png)

## Avoiding Circular References

- **Circular reference problem**: Bidirectional relationships create infinite loops
- **Stack overflow**: Occurs when converting objects to string
- **Loop explanation**: User.toString() → Address.toString() → User.toString() → infinite loop
- **Solution**: Exclude fields from toString generation

![Circular Reference Problem Diagram](assets/circular-reference-problem-diagram.png)

**Circular reference fix:**
```java
@ToString
@Entity
@Table(name = "addresses")
public class Address {
    // Other fields included in toString...
    
    @ToString.Exclude  // Exclude from toString to break circular reference
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
```

![ToString Exclude Annotation](assets/tostring-exclude-annotation.png)

**Stack overflow prevention:**
- **@ToString.Exclude**: Excludes specific fields from string representation
- **Strategic exclusion**: Remove reference back to parent entity
- **Debugging clarity**: Maintains useful output while preventing errors

## Additional Helper Methods

- **Complete CRUD operations**: Add methods for both adding and removing relationships
- **Consistency**: Follow same pattern for remove operations
- **Null assignment**: Set relationship to null when removing associations
- **IntelliJ assistance**: IDE provides code completion for common patterns

```java
public void removeAddress(Address address) {
    addresses.remove(address);    // Remove from collection
    address.setUser(null);        // Clear back-reference
}
```

![Remove Address Helper Method](assets/remove-address-helper-method.png)

**Remove method benefits:**
- **Complete lifecycle management**: Handle both add and remove operations
- **Data integrity**: Ensure both sides of relationship are updated
- **Memory management**: Clear references to prevent memory leaks
- **API completeness**: Provide full relationship management interface

## Key Points

- **Main takeaway**: One-to-many relationships require careful implementation of both sides with proper ownership designation using mappedBy attribute
- **Ownership principle**: Entity containing foreign key owns the relationship, while other entity uses mappedBy to reference owning field
- **Bidirectional navigation**: Allows traversing relationships in both directions (User to Addresses, Address to User)
- **Helper methods**: Encapsulate relationship management in methods like addAddress() to ensure both sides are updated consistently
- **Builder pattern issue**: @Builder skips field initializations, requiring @Builder.Default for collections to prevent null pointer exceptions
- **Circular references**: Bidirectional relationships create infinite loops in toString(), solved by using @ToString.Exclude on back-reference fields
- **Annotation usage**: Apply annotations judiciously based on actual needs rather than adding every available annotation
- **Database alignment**: @JoinColumn specifies foreign key column name to match database schema design
- **Relationship integrity**: Always update both sides of bidirectional relationships to maintain data consistency
- **Development practice**: Hand-coding relationships initially helps understand underlying mechanisms before using automated tools

## Links/References

- Video: 4.7.4-Defining-One-To-Many-Relationships.mp4 (09:22)
- Previous: [Exercise - Defining Entities](4.7.3-Exercise-Defining-the-Address-Profile-and-Tag-Entities.md)
- Next: Defining Many-To-Many Relationships
- Reference: [JPA OneToMany Annotation](https://docs.oracle.com/javaee/7/api/javax/persistence/OneToMany.html)
- Reference: [JPA ManyToOne Annotation](https://docs.oracle.com/javaee/7/api/javax/persistence/ManyToOne.html)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

# Exercise: Writing Custom Queries

<!-- omit from toc -->

## Table of Contents

- [Exercise Overview](#exercise-overview)
- [Step 1: Creating Derived Query Method](#step-1-creating-derived-query-method)
- [Step 2: Implementing Service Method](#step-2-implementing-service-method)
- [Step 3: Testing Basic Query](#step-3-testing-basic-query)
- [Step 4: Adding User Email Display](#step-4-adding-user-email-display)
- [Step 5: Handling LazyInitializationException](#step-5-handling-lazyinitializationexception)
- [Step 6: Solving N+1 Problem with EntityGraph](#step-6-solving-n1-problem-with-entitygraph)
- [Step 7: Adding Sorting by Related Entity](#step-7-adding-sorting-by-related-entity)
- [Step 8: Extracting JPQL Query](#step-8-extracting-jpql-query)
- [Step 9: Creating Projection Interface](#step-9-creating-projection-interface)
- [Step 10: Converting to Field Selection](#step-10-converting-to-field-selection)
- [Step 11: Using Field Aliases](#step-11-using-field-aliases)
- [Step 12: Moving Query to Appropriate Repository](#step-12-moving-query-to-appropriate-repository)
- [Step 13: Restoring Entity Relationships](#step-13-restoring-entity-relationships)
- [Step 14: Final Testing and Debugging](#step-14-final-testing-and-debugging)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Exercise Overview

- **Practice consolidation**: Exercise combines multiple concepts from previous lessons
- **Challenge level**: Intermediate to advanced difficulty
- **Time allocation**: Approximately 20 minutes recommended
- **Skills practiced**: Derived queries, projections, EntityGraph, JPQL, N+1 problem solving

![Exercise Overview](assets/exercise-overview.png)

**Concepts covered:**
- **Derived query methods**: Using naming conventions for queries
- **Lazy loading issues**: LazyInitializationException and N+1 problem
- **EntityGraph optimization**: Selective eager loading
- **Projections**: Interface and field-based data transfer
- **Related entity sorting**: Ordering by properties of associated entities

## Step 1: Creating Derived Query Method

- **Repository method**: Add derived query method to ProfileRepository
- **Naming convention**: Use Greater Than comparison for loyalty points
- **Return type**: List of Profile entities
- **Business logic**: Find profiles with loyalty points above threshold

```java
public interface ProfileRepository extends CrudRepository<Profile, Long> {
    
    // Derived query method for loyalty points filtering
    List<Profile> findByLoyaltyPointsGreaterThan(Integer loyaltyPoints);
}
```

![Derived Query Method Creation](assets/derived-query-method-creation.png)

## Step 2: Implementing Service Method

- **Service layer**: Create method to call repository and process results
- **Parameter value**: Use threshold of 2 loyalty points for testing
- **Output format**: Print profile ID for each loyal customer
- **Iteration pattern**: Use forEach for result processing

```java
@Service
public class UserService {
    
    public void printLoyalProfiles() {
        var profiles = profileRepository.findByLoyaltyPointsGreaterThan(2);
        
        // Print only profile IDs
        profiles.forEach(profile -> {
            System.out.println(profile.getId());
        });
    }
}
```

![Service Method Implementation](assets/service-method-implementation.png)

## Step 3: Testing Basic Query

- **Main method call**: Execute service method to test basic functionality
- **Expected output**: Profile IDs that meet loyalty criteria
- **Result verification**: Confirm query returns correct profiles
- **Initial validation**: Basic derived query method working

```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        var context = SpringApplication.run(StoreApplication.class, args);
        var service = context.getBean(UserService.class);
        service.printLoyalProfiles();  // Test basic query
    }
}
```

![Basic Query Testing](assets/basic-query-testing.png)

**Expected output:**
```
2
3
4
```

## Step 4: Adding User Email Display

- **Enhanced output**: Add user email to profile ID display
- **String concatenation**: Combine profile ID with user's email
- **Related entity access**: Navigate from profile to user to email
- **Display format**: "ID: email" pattern for each profile

```java
public void printLoyalProfiles() {
    var profiles = profileRepository.findByLoyaltyPointsGreaterThan(2);
    
    // Print profile ID and associated user email
    profiles.forEach(profile -> {
        System.out.println(profile.getId() + ": " + profile.getUser().getEmail());
    });
}
```

![User Email Display Addition](assets/user-email-display-addition.png)

## Step 5: Handling LazyInitializationException

- **Exception occurrence**: Accessing lazy relationship outside transaction
- **Root cause**: Profile-User relationship uses lazy loading by default
- **Solution approach**: Add @Transactional annotation to service method
- **Transaction context**: Maintain Hibernate session for lazy loading

```java
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
    
    @Transactional  // Required for lazy relationship access
    public void printLoyalProfiles() {
        var profiles = profileRepository.findByLoyaltyPointsGreaterThan(2);
        
        profiles.forEach(profile -> {
            System.out.println(profile.getId() + ": " + profile.getUser().getEmail());
        });
    }
}
```

![LazyInitializationException Handling](assets/lazy-initialization-exception-handling.png)

## Step 6: Solving N+1 Problem with EntityGraph

- **Problem identification**: Multiple queries generated for each profile's user
- **N+1 pattern**: 1 query for profiles + N queries for users
- **Solution**: Use @EntityGraph to eagerly load relationships
- **Performance optimization**: Single query with JOIN instead of multiple queries

```java
public interface ProfileRepository extends CrudRepository<Profile, Long> {
    
    @EntityGraph(attributePaths = {"user"})  // Eagerly load user relationship
    List<Profile> findByLoyaltyPointsGreaterThan(Integer loyaltyPoints);
}
```

![N+1 Problem Solution](assets/n-plus-1-problem-solution.png)

**Query optimization:**
- **Before**: 1 + N queries (N+1 problem)
- **After**: Single JOIN query with EntityGraph
- **Performance gain**: Reduced database round trips

## Step 7: Adding Sorting by Related Entity

- **Sorting requirement**: Order results by user's email address
- **Related entity sorting**: Access property of associated entity
- **Method renaming**: Use Shift+F6 for safe refactoring
- **Naming convention**: OrderByUser_Email syntax

```java
public interface ProfileRepository extends CrudRepository<Profile, Long> {
    
    @EntityGraph(attributePaths = {"user"})
    List<Profile> findByLoyaltyPointsGreaterThanOrderByUserEmail(Integer loyaltyPoints);
}
```

![Related Entity Sorting](assets/related-entity-sorting.png)

**Sorting syntax:**
- **Pattern**: OrderBy + RelatedEntity + Property
- **Example**: OrderByUserEmail for user.email property
- **Generated SQL**: ORDER BY u.email clause in query

## Step 8: Extracting JPQL Query

- **Method name issue**: Long method names become unreadable
- **JPA Buddy tool**: Use Alt+Enter to extract JPQL query
- **Method simplification**: Replace long derived method name with custom query
- **Configuration**: Choose named parameters over indexed parameters

```java
public interface ProfileRepository extends CrudRepository<Profile, Long> {
    
    @Query("SELECT p FROM Profile p WHERE p.loyaltyPoints > :loyaltyPoints ORDER BY p.user.email")
    @EntityGraph(attributePaths = {"user"})
    List<Profile> findLoyalProfiles(@Param("loyaltyPoints") Integer loyaltyPoints);
}
```

![JPQL Query Extraction](assets/jpql-query-extraction.png)

## Step 9: Creating Projection Interface

- **Data transfer optimization**: Create interface for specific data needs
- **DTO package**: Organize projections in dedicated package
- **Interface methods**: Define getter methods for required fields
- **Projection purpose**: Return only ID and email instead of full entities

```java
package com.codewithmosh.store.dtos;

public interface UserSummary {
    Long getId();
    String getEmail();
}
```

![Projection Interface Creation](assets/projection-interface-creation.png)

## Step 10: Converting to Field Selection

- **Return type change**: Modify repository method to return UserSummary projection
- **Service adjustment**: Remove getUser() call since interface provides email directly
- **Compilation error**: Fix service method to match new return type
- **Runtime issue**: Hibernate cannot convert full entities to projections

```java
// Repository change
@Query("SELECT p FROM Profile p WHERE p.loyaltyPoints > :loyaltyPoints ORDER BY p.user.email")
@EntityGraph(attributePaths = {"user"})
List<UserSummary> findLoyalProfiles(@Param("loyaltyPoints") Integer loyaltyPoints);

// Service adjustment
public void printLoyalProfiles() {
    var users = profileRepository.findLoyalProfiles(2);
    users.forEach(user -> {
        System.out.println(user.getId() + ": " + user.getEmail()); // No getUser() needed
    });
}
```

![Field Selection Conversion](assets/field-selection-conversion.png)

## Step 11: Using Field Aliases

- **Mapping issue**: Hibernate cannot map entity fields to projection interface
- **Field selection**: Select specific fields instead of entire entity
- **Alias requirement**: Use AS keyword to map fields to projection methods
- **Query modification**: Select individual fields with proper aliases

```java
@Query("SELECT p.id AS id, p.user.email AS email " +
       "FROM Profile p " +
       "WHERE p.loyaltyPoints > :loyaltyPoints " +
       "ORDER BY p.user.email")
List<UserSummary> findLoyalProfiles(@Param("loyaltyPoints") Integer loyaltyPoints);
```

![Field Aliases Usage](assets/field-aliases-usage.png)

**Field mapping:**
- **p.id AS id**: Maps to UserSummary.getId()
- **p.user.email AS email**: Maps to UserSummary.getEmail()
- **Alias names**: Must match projection interface method names

## Step 12: Moving Query to Appropriate Repository

- **Repository responsibility**: Method returns UserSummary, belongs in UserRepository
- **Code organization**: Move method to conceptually appropriate repository
- **Method renaming**: Change to findLoyalUsers for clarity
- **Query adjustment**: Modify FROM clause to start with User entity

```java
public interface UserRepository extends CrudRepository<User, Long> {
    
    @Query("SELECT u.id AS id, u.email AS email " +
           "FROM User u " +
           "WHERE u.profile.loyaltyPoints > :loyaltyPoints " +
           "ORDER BY u.email")
    List<UserSummary> findLoyalUsers(@Param("loyaltyPoints") Integer loyaltyPoints);
}
```

![Repository Method Movement](assets/repository-method-movement.png)

## Step 13: Restoring Entity Relationships

- **Missing relationship**: User-Profile relationship needed for query
- **Entity modification**: Restore @OneToOne relationship in User entity
- **Relationship access**: Enable u.profile.loyaltyPoints navigation
- **EntityGraph removal**: No longer needed with eager relationship

```java
@Entity
public class User {
    
    @OneToOne
    @JoinColumn(name = "profile_id")
    private Profile profile;  // Restored relationship
    
    // Other fields...
}
```

![Entity Relationship Restoration](assets/entity-relationship-restoration.png)

## Step 14: Final Testing and Debugging

- **Service update**: Change from profileRepository to userRepository
- **Method call**: Use findLoyalUsers instead of findLoyalProfiles
- **Variable naming**: Rename for clarity (profiles â†’ users)
- **Query debugging**: Fix ORDER BY clause reference

```java
@Service
public class UserService {
    
    @Transactional
    public void printLoyalProfiles() {
        var users = userRepository.findLoyalUsers(2);  // Changed repository
        
        users.forEach(user -> {
            System.out.println(user.getId() + ": " + user.getEmail());
        });
    }
}
```

![Final Testing and Debugging](assets/final-testing-debugging.png)

**Common debugging issues:**
- **Parse expression error**: Fix ORDER BY clause to use correct entity reference
- **Repository mismatch**: Ensure service uses correct repository
- **Variable naming**: Update variable names for clarity

## Key Points

- **Main takeaway**: Complex queries often require multiple techniques combined - derived methods, EntityGraph, projections, and custom JPQL
- **N+1 problem prevention**: Use @EntityGraph to avoid multiple queries when accessing lazy relationships in iterations
- **Transaction context**: @Transactional annotation required when accessing lazy relationships outside repository methods
- **Related entity sorting**: Use OrderByRelatedEntityProperty syntax for sorting by associated entity fields
- **Method name complexity**: Extract JPQL queries when derived method names become too long and unreadable
- **Projection benefits**: Interface projections reduce data transfer and provide clean API for specific use cases
- **Field aliases**: Use AS keyword in JPQL to map selected fields to projection interface method names
- **Repository organization**: Place methods in repositories that match their return types and conceptual purpose
- **Query debugging**: Parse errors often indicate incorrect entity references in JPQL - verify relationship navigation paths
- **Best practices**: Combine techniques strategically - use EntityGraph for performance, projections for data optimization, and custom queries for complex logic

## Links/References

- Video: 4.9.7-Exercise-Writing-Custom-Queries.mp4 (08:50)
- Previous: [Calling Stored Procedures](4.9.6-Calling-Stored-Procedures.md)
- Next: Building Dynamic Queries with Specifications
- Reference: [Spring Data JPA Query Methods](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods)
- Reference: [JPQL Field Selection](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage005.htm)
- Reference: [JPA Projections](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#projections)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

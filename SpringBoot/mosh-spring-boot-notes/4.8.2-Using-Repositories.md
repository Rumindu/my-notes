# Using Repositories

<!-- omit from toc -->

## Table of Contents

- [Repository Object Creation](#repository-object-creation)
- [Spring Runtime Implementation](#spring-runtime-implementation)
- [Saving Data to Database](#saving-data-to-database)
- [Viewing SQL Statements](#viewing-sql-statements)
- [Retrieving Data from Database](#retrieving-data-from-database)
- [Handling Optional Results](#handling-optional-results)
- [Lazy Initialization Issues](#lazy-initialization-issues)
- [Retrieving All Records](#retrieving-all-records)
- [Deleting Records](#deleting-records)
- [Cascade Delete Operations](#cascade-delete-operations)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Repository Object Creation

- **Context access**: Use application context to get repository bean instance
- **Bean retrieval**: Call `context.getBean()` with repository class parameter
- **No implementation needed**: Repository interface automatically implemented by Spring
- **Runtime generation**: Actual repository implementation created at application startup

```java
@SpringBootApplication
public class StoreApplication {
    public static void main(String[] args) {
        var context = SpringApplication.run(StoreApplication.class, args);
        var repository = context.getBean(UserRepository.class);
        
        // Repository is ready to use
    }
}
```

![Repository Bean Retrieval from Application Context](assets/repository-bean-retrieval-application-context.png)

## Spring Runtime Implementation

- **Interface-only definition**: Only UserRepository interface was created, no implementation class
- **Spring magic**: Framework generates concrete implementation at runtime
- **Proxy creation**: Spring creates proxy object implementing repository interface
- **Method availability**: All CRUD methods immediately available on repository object

![Spring Repository Runtime Implementation](assets/spring-repository-runtime-implementation-diagram.png)

**Available repository methods:**
- **Save operations**: `save()`, `saveAll()` for persisting entities
- **Find operations**: `findById()`, `findAll()` for data retrieval
- **Delete operations**: `delete()`, `deleteById()`, `deleteAll()` for removal
- **Utility methods**: `count()`, `existsById()` for data verification

## Saving Data to Database

- **Entity creation**: Build entity object using builder pattern
- **Mandatory properties**: Set required fields like name, email, password
- **Repository save**: Call `repository.save()` to persist entity
- **SQL generation**: Hibernate automatically generates INSERT statements

```java
var user = User.builder()
    .name("John")
    .email("john@example.com")
    .password("password123")
    .build();

repository.save(user);  // Persists user to database
```

![User Object Creation and Save Operation](assets/user-object-creation-save-operation.png)

**Save operation benefits:**
- **No SQL required**: Framework handles SQL statement generation
- **Type safety**: Compile-time checking for entity properties
- **Automatic ID**: Database assigns primary key automatically
- **Transaction management**: Spring handles transaction boundaries

## Viewing SQL Statements

- **Configuration requirement**: Enable SQL logging in application.yml
- **YAML structure**: Configure under spring.jpa.show-sql property
- **Development aid**: See actual SQL statements sent to database
- **Debugging tool**: Understand what Hibernate generates behind scenes

```yaml
# application.yml
spring:
  jpa:
    show-sql: true
```

![Application YAML SQL Logging Configuration](assets/application-yaml-sql-logging-configuration.png)

**Console output example:**
```sql
INSERT INTO users (email, name, password) VALUES (?, ?, ?)
```

![Console SQL Statement Output](assets/console-sql-statement-output.png)

**SQL logging benefits:**
- **Transparency**: See exact database operations
- **Performance analysis**: Identify inefficient queries
- **Debugging aid**: Troubleshoot data persistence issues
- **Learning tool**: Understand ORM-generated SQL patterns

## Retrieving Data from Database

- **Find by ID**: Use `repository.findById()` with entity ID parameter
- **Long type casting**: Add 'L' suffix for long literals (1L instead of 1)
- **Optional return**: Method returns Optional<User> not direct User object
- **Null safety**: Optional prevents null pointer exceptions

```java
var userOptional = repository.findById(1L);
var user = userOptional.get();  // Extract user from Optional
System.out.println(user.getEmail());
```

![Repository Find By ID Operation](assets/repository-find-by-id-operation.png)

**Generated SQL example:**
```sql
SELECT u.id, u.email, u.name, u.password FROM users u WHERE u.id=?
```

![Find By ID SQL Generation](assets/find-by-id-sql-generation.png)

## Handling Optional Results

- **Optional benefits**: Prevents null pointer exceptions for missing records
- **Get method**: Extract actual object when record exists
- **OrElse alternative**: Provide fallback value when record not found
- **OrElseThrow option**: Throw exception for missing records

```java
// Option 1: Provide default value
var user = repository.findById(1L)
    .orElse(null);

// Option 2: Throw exception
var user = repository.findById(1L)
    .orElseThrow(() -> new RuntimeException("User not found"));
```

![Optional Handling Strategies](assets/optional-handling-strategies.png)

**Best practices:**
- **Business requirements**: Choose approach based on application needs
- **Error handling**: Consider user experience for missing data
- **Exception types**: Use appropriate exception classes
- **Default values**: Provide meaningful fallbacks when possible

## Lazy Initialization Issues

- **Exception occurrence**: LazyInitializationException when accessing related entities
- **Root cause**: Hibernate session closed before accessing lazy-loaded properties
- **Temporary solution**: Access only direct entity properties (email, name, etc.)
- **Future topic**: Advanced loading strategies covered in later sections

![Lazy Initialization Exception Example](assets/lazy-initialization-exception-example.png)

**Workaround for now:**
```java
// Avoid printing entire user object
System.out.println(user.getEmail());  // Safe - direct property access

// This would cause LazyInitializationException:
// System.out.println(user);  // Unsafe - tries to load relationships
```

![Safe Property Access Pattern](assets/safe-property-access-pattern.png)

## Retrieving All Records

- **Find all method**: Use `repository.findAll()` to get all entities
- **Iterable return**: Method returns Iterable<User> collection
- **ForEach processing**: Use forEach with consumer function for iteration
- **Lambda functions**: Concise syntax for processing each record

```java
repository.findAll().forEach(user -> {
    System.out.println(user.getEmail());
});
```

![Repository Find All Operation](assets/repository-find-all-operation.png)

**Generated SQL:**
```sql
SELECT u.id, u.email, u.name, u.password FROM users u
LEFT JOIN profiles p ON u.id = p.user_id
```

![Find All SQL with Eager Loading](assets/find-all-sql-eager-loading.png)

**Processing patterns:**
- **Consumer interface**: Functional interface for forEach operations
- **Lambda syntax**: Concise way to define processing logic
- **Stream operations**: Can convert to Stream for advanced processing
- **Batch processing**: Efficient way to handle multiple records

## Deleting Records

- **Multiple delete methods**: Various options for removing entities
- **Delete by ID**: Remove entity using primary key value
- **Delete by entity**: Remove using entity object reference
- **Delete all**: Remove all entities from table

```java
// Delete by ID
repository.deleteById(1L);

// Other delete options available:
// repository.delete(userObject);     // Delete specific entity
// repository.deleteAll();            // Delete all entities
```

![Repository Delete Methods](assets/repository-delete-methods.png)

## Cascade Delete Operations

- **Multiple SQL statements**: Delete generates several database operations
- **Relationship handling**: Child records deleted before parent entity
- **Cascade behavior**: Related entities removed automatically
- **Order of operations**: Hibernate manages deletion sequence

![Database Delete Operations Sequence](assets/database-delete-operations-sequence.png)

**Delete operation sequence:**
1. **Select operation**: Load entity and relationships
2. **Child record deletion**: Remove records from wishlist table
3. **Junction table cleanup**: Remove records from user_tags table
4. **Parent deletion**: Finally remove user from users table

```sql
-- Example delete sequence:
SELECT ... FROM users WHERE id=?
DELETE FROM wishlist WHERE user_id=?
DELETE FROM user_tags WHERE user_id=?
DELETE FROM users WHERE id=?
```

![Cascade Delete SQL Statements](assets/cascade-delete-sql-statements.png)

**Cascade considerations:**
- **Data integrity**: Ensures referential integrity maintained
- **Performance impact**: Multiple statements can affect performance
- **Transaction safety**: All operations wrapped in single transaction
- **Relationship cleanup**: Prevents orphaned records in database

## Key Points

- **Main takeaway**: Spring Data repositories provide automatic implementation at runtime, eliminating need for manual repository classes while offering complete CRUD functionality
- **Bean retrieval**: Access repository instances through application context using `getBean()` method with repository class parameter
- **No SQL required**: Repository methods automatically generate appropriate SQL statements through Hibernate ORM
- **Optional handling**: `findById()` returns Optional object requiring proper handling with `get()`, `orElse()`, or `orElseThrow()` methods
- **SQL visibility**: Enable `spring.jpa.show-sql: true` in configuration to view generated SQL statements for debugging and learning
- **Lazy loading issues**: Accessing related entities outside Hibernate session causes LazyInitializationException, requiring careful property access
- **Collection operations**: `findAll()` returns Iterable that can be processed with forEach and lambda functions for batch operations
- **Cascade deletions**: Deleting entities with relationships triggers multiple SQL statements to maintain referential integrity
- **Type considerations**: Use 'L' suffix for long literals when working with ID parameters to ensure correct type matching
- **Development workflow**: Repository pattern simplifies database operations while maintaining type safety and transaction management

## Links/References

- Video: 4.8.2-Using-Repositories.mp4 (06:18)
- Previous: [Defining Repositories](4.8.1-Defining-Repositories.md)
- Next: Entity States and Lifecycle
- Reference: [Spring Data JPA Repository Methods](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods)
- Reference: [Optional Class Documentation](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

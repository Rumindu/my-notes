# Bean Lifecycle Hooks

<!-- omit from toc -->
## Table of Contents

- [Understanding Bean Lifecycle](#understanding-bean-lifecycle)
- [Post-Construct Hook](#post-construct-hook)
  - [Adding @PostConstruct Method](#adding-postconstruct-method)
  - [Testing Post-Construct Behavior](#testing-post-construct-behavior)
  - [Use Cases for Post-Construct](#use-cases-for-post-construct)
- [Pre-Destroy Hook](#pre-destroy-hook)
  - [Adding @PreDestroy Method](#adding-predestroy-method)
  - [Problem with Application Context](#problem-with-application-context)
  - [Using Configurable Application Context](#using-configurable-application-context)
  - [Manually Closing Context](#manually-closing-context)
- [Troubleshooting Port Issues](#troubleshooting-port-issues)
  - [Port Already in Use Error](#port-already-in-use-error)
  - [Finding and Killing Processes (Mac/Linux)](#finding-and-killing-processes-maclinux)
  - [Windows Alternative](#windows-alternative)
- [Testing Complete Lifecycle](#testing-complete-lifecycle)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Understanding Bean Lifecycle

- **Lifecycle stages**: Spring beans go through initialization, dependency injection, and destruction
- **Hook opportunities**: Can execute custom code at different lifecycle stages
- **Common use cases**: Resource initialization, cleanup, configuration setup
- **Annotations**: @PostConstruct and @PreDestroy for lifecycle management

![Bean Lifecycle Overview](assets/bean-lifecycle-overview.png)

**Lifecycle flow:**
1. Bean creation (constructor called)
2. Dependency injection
3. @PostConstruct method execution
4. Bean ready for use
5. @PreDestroy method execution (before destruction)
6. Bean destruction

## Post-Construct Hook

### Adding @PostConstruct Method

```java
@Service
public class OrderService {
    private PaymentService paymentService;
    
    public OrderService(PaymentService paymentService) {
        System.out.println("OrderService created");
        this.paymentService = paymentService;
    }
    
    @PostConstruct
    public void init() {  // Method name doesn't matter
        System.out.println("OrderService post construct");
    }
    
    public void placeOrder() {
        paymentService.processPayment(10.0);
    }
}
```

![PostConstruct Method Implementation](assets/postconstruct-method-implementation.png)

**Key points:**
- **Method name**: Can be anything - name doesn't matter
- **@PostConstruct**: Annotation tells Spring to call this method after bean creation
- **Timing**: Called after constructor and dependency injection
- **Purpose**: Perform initialization that requires dependencies to be available

### Testing Post-Construct Behavior

**Remove prototype scope for cleaner output:**
```java
@Configuration
public class AppConfig {
    
    @Bean
    // @Scope("prototype")  // Remove this for cleaner terminal output
    public OrderService orderService() {
        if (paymentGateway.equals("stripe")) {
            return new OrderService(stripe());
        } else {
            return new OrderService(payPal());
        }
    }
}
```

![Removing Prototype Scope](assets/removing-prototype-scope-cleanup.png)

**Expected output:**
```
OrderService created
OrderService post construct
```

![PostConstruct Test Output](assets/postconstruct-test-output.png)

**Execution order**: Constructor runs first, then @PostConstruct method

### Use Cases for Post-Construct

- **Database connections**: Opening database connection pools
- **Network connections**: Establishing network connections
- **Resource initialization**: Setting up resources that require dependencies
- **Configuration validation**: Validating injected configuration
- **Cache warming**: Pre-loading frequently used data

![PostConstruct Use Cases](assets/postconstruct-use-cases.png)

## Pre-Destroy Hook

### Adding @PreDestroy Method

```java
@Service
public class OrderService {
    private PaymentService paymentService;
    
    public OrderService(PaymentService paymentService) {
        System.out.println("OrderService created");
        this.paymentService = paymentService;
    }
    
    @PostConstruct
    public void init() {
        System.out.println("OrderService post construct");
    }
    
    @PreDestroy
    public void cleanup() {  // Method name doesn't matter
        System.out.println("OrderService pre destroy");
    }
    
    public void placeOrder() {
        paymentService.processPayment(10.0);
    }
}
```

![PreDestroy Method Implementation](assets/predestroy-method-implementation.png)

**Purpose**: Execute cleanup logic before bean is destroyed

### Problem with Application Context

**Initial test - no pre-destroy message:**
```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(StoreApplication.class, args);
        
        OrderService orderService = context.getBean(OrderService.class);
        orderService.placeOrder();
        
        // Application ends, but context is not explicitly closed
    }
}
```

![Application Context No Cleanup](assets/application-context-no-cleanup.png)

**Problem**: Application context is not closed, so @PreDestroy methods don't execute

### Using Configurable Application Context

```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(StoreApplication.class, args);
        
        OrderService orderService = context.getBean(OrderService.class);
        orderService.placeOrder();
        
        // Now we can manually close the context
        context.close();
    }
}
```

![Configurable Application Context](assets/configurable-application-context.png)

**ConfigurableApplicationContext interface:**
- **Extends**: ApplicationContext interface
- **Additional capability**: Provides close() method for manual context shutdown
- **Purpose**: Allows explicit control over application context lifecycle

![ConfigurableApplicationContext Interface](assets/configurable-interface-inheritance.png)

### Manually Closing Context

```java
context.close();  // Triggers @PreDestroy methods
```

**Benefits of manual close:**
- **@PreDestroy execution**: Ensures cleanup methods are called
- **Resource cleanup**: Properly releases resources
- **Graceful shutdown**: Controlled application termination

![Manual Context Close](assets/manual-context-close.png)

## Troubleshooting Port Issues

### Port Already in Use Error

**Error message**: "Port 8080 was already in use"

![Port 8080 Already in Use Error](assets/port-8080-already-in-use-error.png)

**Cause**: Another process is listening on port 8080

### Finding and Killing Processes (Mac/Linux)

**Step 1: Find process using port**
```bash
lsof -i :8080
```

![Finding Process on Port 8080](assets/finding-process-port-8080.png)

**Step 2: Kill the process**
```bash
kill -9 42962  # Replace with actual process ID
```

![Killing Process by PID](assets/killing-process-by-pid.png)

**Commands explanation:**
- **lsof -i :8080**: Lists processes using port 8080
- **kill -9 PID**: Force kills process with specified Process ID

### Windows Alternative

**For Windows users**: Use ChatGPT or online resources to find equivalent commands
- **Alternative**: Use Task Manager to find and kill processes
- **Command line**: `netstat` and `taskkill` commands available

![Windows Process Management](assets/windows-process-management.png)

## Testing Complete Lifecycle

**After resolving port issue:**

**Expected output:**
```
OrderService created
OrderService post construct
PayPal
10.0
OrderService pre destroy
```

![Complete Lifecycle Test Output](assets/complete-lifecycle-test-output.png)

**Verification**: All lifecycle hooks execute in correct order:
1. Constructor
2. @PostConstruct
3. Normal operation
4. @PreDestroy (when context closes)

## Key Points

- **Main takeaway**: Use @PostConstruct and @PreDestroy annotations to hook into bean lifecycle for initialization and cleanup
- **@PostConstruct timing**: Called after constructor and dependency injection, perfect for initialization requiring dependencies
- **@PreDestroy timing**: Called before bean destruction, ideal for resource cleanup
- **Method naming**: Method names for lifecycle hooks don't matter, annotations determine behavior
- **Context closure**: Use ConfigurableApplicationContext to manually close context and trigger @PreDestroy methods
- **Resource management**: PostConstruct for opening connections, PreDestroy for closing them
- **Graceful shutdown**: Proper lifecycle management ensures clean resource cleanup
- **Common use cases**: Database connections, file handles, network connections, cache cleanup
- **Troubleshooting**: Port conflicts can be resolved by finding and killing conflicting processes

## Links/References

- Video: 3.13-Bean-Lifecycle-Hooks.mp4 (3m 58s)
- Previous: [Bean Scopes](3.12-Bean-Scopes.md)
- Next: Spring Framework Summary

---

**Created**: July 30, 2025  
**Last Modified**: July 30, 2025

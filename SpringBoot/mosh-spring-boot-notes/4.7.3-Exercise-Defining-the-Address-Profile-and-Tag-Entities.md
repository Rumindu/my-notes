# Exercise - Defining the Address, Profile and Tag Entities

<!-- omit from toc -->

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Exercise Overview](#exercise-overview)
- [Exercise Requirements](#exercise-requirements)
- [Address Entity Implementation](#address-entity-implementation)
- [Tag Entity Implementation](#tag-entity-implementation)
- [Profile Entity Implementation](#profile-entity-implementation)
- [Column Annotation Considerations](#column-annotation-considerations)
- [Nullable Attribute Best Practices](#nullable-attribute-best-practices)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Exercise Overview

- **Practice objective**: Define three entities (Address, Profile, Tag) with proper JPA annotations
- **Focus area**: Entity mapping and field definitions without relationships
- **Time estimate**: 10 minutes maximum
- **Skills practiced**: JPA annotations, Lombok integration, database mapping

![Exercise Entity Overview Diagram](assets/exercise-entity-overview-diagram.png)

**Entities to implement:**
- Address entity with location fields
- Profile entity with user details
- Tag entity for content categorization

## Exercise Requirements

- **Entity definition**: Create proper JPA entity classes
- **Field mapping**: Map class fields to database columns
- **Lombok usage**: Apply @Getter and @Setter annotations
- **No relationships**: Focus only on individual entity structure
- **Database mapping**: Ensure proper column mapping

![Exercise Requirements Checklist](assets/exercise-requirements-checklist.png)

**Key requirements:**
- Use JPA annotations (@Entity, @Table, @Id, @GeneratedValue)
- Apply Lombok annotations for boilerplate reduction
- Map fields to appropriate database columns
- Exclude relationship definitions for now

## Address Entity Implementation

- **Annotations used**: @Getter, @Setter, @Entity, @Table
- **Table mapping**: Maps to "addresses" table in database
- **Lombok strategy**: Use only essential annotations (avoid constructor/builder for now)
- **Field structure**: ID, street, city, zip, and state fields

```java
@Getter
@Setter
@Entity
@Table(name = "addresses")
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;
    
    @Column(name = "street")
    private String street;
    
    @Column(name = "city")
    private String city;
    
    @Column(name = "zip")
    private String zip;
    
    @Column(name = "state")
    private String state;
}
```

![Address Entity Class Structure](assets/address-entity-class-structure.png)

**Implementation details:**
- **@Table annotation**: Maps class to "addresses" database table
- **ID field**: Long type with auto-generation strategy
- **String fields**: Standard VARCHAR mapping for address components
- **Column mapping**: Explicit @Column annotations for all fields

## Tag Entity Implementation

- **Simple structure**: Most straightforward entity with minimal fields
- **Standard annotations**: Same annotation pattern as other entities
- **Field composition**: ID and name fields only
- **Use case**: Content categorization and labeling

```java
@Getter
@Setter
@Entity
@Table(name = "tags")
public class Tag {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;
    
    @Column(name = "name")
    private String name;
}
```

![Tag Entity Class Structure](assets/tag-entity-class-structure.png)

**Tag entity characteristics:**
- **Minimal design**: Only essential fields for tagging functionality
- **Name field**: String type for tag label storage
- **Standard ID**: Auto-generated Long primary key
- **Table mapping**: Maps to "tags" database table

## Profile Entity Implementation

- **Complex fields**: Multiple data types including LocalDate and Integer
- **User details**: Extended information beyond basic user data
- **Data variety**: String, LocalDate, and Integer field types
- **Business purpose**: Store additional user profile information

```java
@Getter
@Setter
@Entity
@Table(name = "profiles")
public class Profile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;
    
    @Column(name = "bio")
    private String bio;
    
    @Column(name = "phone_number")
    private String phoneNumber;
    
    @Column(name = "date_of_birth")
    private LocalDate dateOfBirth;
    
    @Column(name = "loyalty_points")
    private Integer loyaltyPoints;
}
```

![Profile Entity Class Structure](assets/profile-entity-class-structure.png)

**Profile field details:**
- **Bio field**: String type for user biography
- **Phone number**: String type for contact information
- **Date of birth**: LocalDate for proper date handling
- **Loyalty points**: Integer for point accumulation system

## Column Annotation Considerations

- **ID column annotation**: Previously forgotten in User entity, now properly applied
- **Consistent mapping**: All fields should have explicit @Column annotations
- **Best practice**: Always specify column names for clarity
- **Database alignment**: Ensures Java fields map correctly to database columns

![Column Annotation Best Practices](assets/column-annotation-best-practices.png)

**Column annotation benefits:**
- Explicit field-to-column mapping
- Protection against field name refactoring
- Clear database schema documentation
- Consistency across all entities

## Nullable Attribute Best Practices

- **Flyway approach**: Database constraints defined in migration scripts
- **Not needed here**: nullable=false not required when using proper migrations
- **Database-level control**: Constraints managed at database schema level
- **Simplification**: Removing nullable attributes for cleaner code

![Nullable Attribute Strategy](assets/nullable-attribute-strategy-comparison.png)

**When to use nullable attributes:**
- **Hibernate table generation**: Required when letting Hibernate create tables
- **Migration-based approach**: Not needed with Flyway migrations
- **Validation purpose**: Doesn't provide application-level validation
- **Best practice**: Define constraints in database migration scripts

**Code simplification example:**
```java
// Not needed with Flyway migrations
@Column(name = "street", nullable = false)  // Remove nullable
private String street;

// Simplified version
@Column(name = "street")  // Database constraint in migration
private String street;
```

![Migration vs Hibernate Table Generation](assets/migration-vs-hibernate-table-generation.png)

## Key Points

- **Main takeaway**: Entity definition requires proper JPA annotations (@Entity, @Table, @Id, @GeneratedValue) combined with Lombok annotations for boilerplate reduction
- **Lombok strategy**: Use essential annotations (@Getter, @Setter) initially, add constructors and builders only when specifically needed
- **Column mapping**: Apply @Column annotations to all fields including ID for explicit database column mapping and refactoring protection
- **Nullable attributes**: When using Flyway migrations, nullable constraints should be defined in database scripts rather than JPA annotations
- **Entity complexity**: Address entity handles location data, Tag provides simple categorization, Profile manages extended user information with varied data types
- **Data type variety**: Entities demonstrate String, Long, LocalDate, and Integer field mappings for different business requirements
- **Migration approach**: Flyway-based database versioning eliminates need for nullable=false annotations in entity definitions
- **Field consistency**: All entities follow same annotation pattern for maintainability and team consistency
- **Database alignment**: Explicit column names ensure Java code aligns properly with database schema design
- **Exercise progression**: Successfully completing entity definitions prepares for upcoming relationship mapping lessons

## Links/References

- Video: 4.7.3-Exercise-Defining-the-Address_-Profile-and-Tag-Entities.mp4 (02:39)
- Previous: [Simplifying Code with Lombok](4.7.2-Simplifying-Code-with-Lombok.md)
- Next: Entity Relationships and Mapping
- Reference: [JPA Column Annotation](https://docs.oracle.com/javaee/7/api/javax/persistence/Column.html)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

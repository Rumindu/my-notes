# Controlling Bean Selection

<!-- omit from toc -->
## Table of Contents

- [The Multiple Bean Problem](#the-multiple-bean-problem)
  - [Adding Service to Stripe Payment Service](#adding-service-to-stripe-payment-service)
  - [Running with Multiple Implementations](#running-with-multiple-implementations)
  - [Understanding the Error](#understanding-the-error)
- [Solution 1: Using @Primary Annotation](#solution-1-using-primary-annotation)
  - [Marking the Default Bean](#marking-the-default-bean)
  - [Testing Primary Bean Selection](#testing-primary-bean-selection)
  - [Primary Annotation Limitations](#primary-annotation-limitations)
- [Solution 2: Using @Qualifier Annotation](#solution-2-using-qualifier-annotation)
  - [Specifying Implementation in Constructor](#specifying-implementation-in-constructor)
  - [The Bean Name Error](#the-bean-name-error)
  - [Assigning Names to Beans](#assigning-names-to-beans)
  - [Complete Qualifier Setup](#complete-qualifier-setup)
  - [Testing Qualifier Selection](#testing-qualifier-selection)
- [Understanding Coupling Concerns](#understanding-coupling-concerns)
  - [Addressing Coupling Questions](#addressing-coupling-questions)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## The Multiple Bean Problem

### Adding Service to Stripe Payment Service

```java
@Service
public class StripePaymentService implements PaymentService {
    
    @Override
    public void processPayment(double amount) {
        System.out.println("Stripe");
        System.out.println(amount);
    }
}
```

![Service Annotation on Stripe](assets/service-annotation-stripe.png)

**Setup**: Now both PayPalPaymentService and StripePaymentService have @Service annotation

### Running with Multiple Implementations

**Error occurs**: Application fails to start with bean selection error

![Multiple Bean Implementation Error](assets/multiple-bean-implementation-error.png)

### Understanding the Error

**Error message**: "OrderService required a single bean, but two were found"

![Bean Selection Conflict Error](assets/bean-selection-conflict-error.png)

**Root cause**: 
- Spring finds two beans implementing PaymentService interface
- Cannot determine which implementation to inject into OrderService
- Both PayPalPaymentService and StripePaymentService are valid candidates

## Solution 1: Using @Primary Annotation

### Marking the Default Bean

```java
@Service
@Primary  // Marks this as the default implementation
public class StripePaymentService implements PaymentService {
    
    @Override
    public void processPayment(double amount) {
        System.out.println("Stripe");
        System.out.println(amount);
    }
}
```

![Primary Annotation on Stripe](assets/primary-annotation-stripe.png)

**Purpose**: @Primary marks the preferred bean when multiple candidates exist

### Testing Primary Bean Selection

**Expected output:**
```
Stripe
10.0
```

![Application Output with Primary](assets/application-output-primary.png)

**Result**: Error is resolved and Stripe payment service is used by default

### Primary Annotation Limitations

- **Single primary only**: Cannot apply @Primary to multiple classes
- **Global default**: Primary bean becomes default for entire application
- **Limitation**: What if specific classes need different implementations?

![Primary Annotation Limitations](assets/primary-annotation-limitations.png)

## Solution 2: Using @Qualifier Annotation

### Specifying Implementation in Constructor

```java
@Service
public class OrderService {
    private PaymentService paymentService;
    
    public OrderService(@Qualifier("payPal") PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public void placeOrder() {
        paymentService.processPayment(10.0);
    }
}
```

![Qualifier Annotation in Constructor](assets/qualifier-annotation-constructor.png)

**Purpose**: @Qualifier specifies which exact implementation to use

### The Bean Name Error

**Error message**: "No bean or managed object with the name 'payPal'"

![Bean Name Not Found Error](assets/bean-name-not-found-error.png)

**Problem**: Spring doesn't recognize "payPal" as a valid bean name
**Solution**: Must assign names to beans using service annotation

### Assigning Names to Beans

```java
@Service("payPal")  // Assign name "payPal" to this bean
public class PayPalPaymentService implements PaymentService {
    
    @Override
    public void processPayment(double amount) {
        System.out.println("PayPal");
        System.out.println(amount);
    }
}

@Service("stripe")  // Assign name "stripe" to this bean
@Primary
public class StripePaymentService implements PaymentService {
    
    @Override
    public void processPayment(double amount) {
        System.out.println("Stripe");
        System.out.println(amount);
    }
}
```

![Named Service Beans](assets/named-service-beans.png)

### Complete Qualifier Setup

**Current configuration:**
- **Stripe**: Default/primary payment service (used globally)
- **PayPal**: Specific implementation (used only in OrderService via @Qualifier)
- **OrderService**: Explicitly requests PayPal implementation

![Complete Qualifier Configuration](assets/complete-qualifier-configuration.png)

### Testing Qualifier Selection

**Expected output:**
```
PayPal
10.0
```

![Application Output with Qualifier](assets/application-output-qualifier.png)

**Verification**: OrderService uses PayPal despite Stripe being the primary bean

## Understanding Coupling Concerns

### Addressing Coupling Questions

**Common concern**: "Isn't using 'payPal' creating coupling between OrderService and PayPalPaymentService?"

**Answer**: No coupling is created because:
- **No class reference**: OrderService doesn't reference PayPalPaymentService class
- **Name-based selection**: Only uses bean name ("payPal") assigned elsewhere
- **Interface dependency**: Still depends only on PaymentService interface
- **Loose coupling maintained**: Can change implementation by changing bean names

![No Coupling with Qualifier](assets/no-coupling-qualifier.png)

**Key insight**: @Qualifier uses bean names, not class references, preserving loose coupling

## Key Points

- **Main takeaway**: Use @Primary for default implementation and @Qualifier for specific implementation selection when multiple beans exist
- **Multiple bean problem**: Spring cannot choose between multiple implementations of the same interface without guidance
- **@Primary usage**: Marks the preferred bean when multiple candidates are available - only one primary allowed per interface
- **@Qualifier usage**: Specifies exact implementation to use in specific injection points using bean names
- **Bean naming**: Use @Service("name") to assign custom names to beans for @Qualifier reference
- **No coupling concern**: @Qualifier uses bean names, not class references, maintaining loose coupling
- **Flexibility**: Can have global default (Primary) while using specific implementations in certain classes (Qualifier)
- **Common scenario**: Useful when different parts of application need different implementations of same interface
- **Best practice**: Combine @Primary and @Qualifier for maximum flexibility in dependency injection

## Links/References

- Video: 3.7-Controlling-Bean-Selection.mp4 (2m 56s)
- Previous: [Configuring Beans Using Annotations](3.6-Configuring-Beans-Using-Annotations.md)
- Next: Component Scanning

---

**Created**: July 30, 2025  
**Last Modified**: July 30, 2025

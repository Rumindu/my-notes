# Writing Dynamic Queries

<!-- omit from toc -->

## Table of Contents

- [Dynamic Queries Overview](#dynamic-queries-overview)
- [Limitations of Static Query Methods](#limitations-of-static-query-methods)
- [Dynamic Query Solutions](#dynamic-query-solutions)
- [Query by Example Introduction](#query-by-example-introduction)
- [Criteria API Introduction](#criteria-api-introduction)
- [Specifications Introduction](#specifications-introduction)
- [Sorting and Pagination Introduction](#sorting-and-pagination-introduction)
- [Segment Learning Objectives](#segment-learning-objectives)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Dynamic Queries Overview

- **Flexible query requirements**: Queries need to adapt based on varying user input
- **Runtime query construction**: Build queries dynamically based on available criteria
- **User-driven filtering**: Handle search forms with optional filter parameters
- **Scalable query solutions**: Avoid creating dozens of hardcoded query methods

![Dynamic Queries Overview](assets/dynamic-queries-overview.png)

**Dynamic query scenarios:**
- **Search forms**: Users can filter by name, category, price range, etc.
- **Optional parameters**: Some filters may be empty or null
- **Conditional logic**: Different combinations of search criteria
- **Complex filtering**: Multiple fields with various comparison operators

## Limitations of Static Query Methods

- **Fixed query structure**: Derived query methods and @Query have predetermined conditions
- **Parameter combinations**: Cannot handle optional or conditional parameters
- **Method explosion**: Need separate methods for each parameter combination
- **Maintenance overhead**: Managing multiple similar query methods becomes complex

![Static Query Limitations](assets/static-query-limitations.png)

**Problems with static approaches:**
- **findByName()**: Only searches by name
- **findByNameAndCategory()**: Requires both parameters
- **findByNameOrCategory()**: Limited OR logic
- **Combinatorial explosion**: N parameters = 2^N possible method combinations

## Dynamic Query Solutions

- **Query by Example**: Use example entities to define search criteria
- **Criteria API**: Programmatically build queries with conditional logic
- **Specifications**: Create reusable, composable query components
- **Sorting and Pagination**: Handle result ordering and large datasets efficiently

![Dynamic Query Solutions](assets/dynamic-query-solutions.png)

**Solution comparison:**
- **Query by Example**: Simple, entity-based filtering
- **Criteria API**: Full programmatic control over query construction
- **Specifications**: Reusable query components with composition
- **Pagination**: Efficient handling of large result sets

## Query by Example Introduction

- **Entity-based filtering**: Use example entity instances to define search criteria
- **Simple implementation**: Minimal code required for basic filtering
- **Automatic matching**: Framework matches non-null fields in example entity
- **Limited flexibility**: Best for simple equality-based searches

![Query by Example Introduction](assets/query-by-example-introduction.png)

**Query by Example benefits:**
- **Intuitive approach**: Use actual entity objects as search templates
- **Minimal boilerplate**: Less code than traditional query methods
- **Type safety**: Compile-time checking of entity properties
- **Automatic null handling**: Framework ignores null fields in example

**Use cases:**
- **Simple search forms**: Basic filtering with equality comparisons
- **Prototype-based queries**: Search for entities similar to a given example
- **Quick filtering**: Rapid implementation of basic search functionality

## Criteria API Introduction

- **Programmatic query building**: Construct queries using Java code
- **Type-safe queries**: Compile-time validation of entity references
- **Complex conditions**: Support for advanced filtering logic
- **Dynamic construction**: Add conditions based on runtime parameters

![Criteria API Introduction](assets/criteria-api-introduction.png)

**Criteria API capabilities:**
- **Conditional logic**: Add WHERE clauses based on parameter availability
- **Join operations**: Navigate entity relationships programmatically
- **Aggregate functions**: COUNT, SUM, AVG, MIN, MAX operations
- **Subqueries**: Nested query construction for complex scenarios

**Advanced features:**
- **Metamodel usage**: Type-safe property references
- **Expression building**: Complex predicate construction
- **Root and path navigation**: Entity relationship traversal
- **Parameter binding**: Safe parameter substitution

## Specifications Introduction

- **Reusable query logic**: Create composable query components
- **Specification pattern**: Encapsulate query conditions in separate classes
- **Combination support**: AND, OR, NOT operations between specifications
- **Clean separation**: Separate query logic from repository implementation

![Specifications Introduction](assets/specifications-introduction.png)

**Specification benefits:**
- **Reusability**: Same specification used across different queries
- **Composability**: Combine simple specifications into complex queries
- **Testability**: Unit test individual specification components
- **Readability**: Clear, descriptive specification names

**Implementation pattern:**
- **Specification interface**: Define query conditions
- **Specification classes**: Implement specific filtering logic
- **Repository integration**: Use JpaSpecificationExecutor interface
- **Service layer**: Combine specifications based on business logic

## Sorting and Pagination Introduction

- **Large dataset handling**: Efficiently process and display large result sets
- **Performance optimization**: Limit memory usage and query execution time
- **User experience**: Provide ordered, pageable data for UI consumption
- **Database efficiency**: Use LIMIT and OFFSET for optimal query performance

![Sorting and Pagination Introduction](assets/sorting-pagination-introduction.png)

**Sorting capabilities:**
- **Single field sorting**: Order by one property ascending/descending
- **Multi-field sorting**: Complex ordering with multiple properties
- **Dynamic sorting**: Runtime determination of sort criteria
- **Null handling**: Control null value positioning in results

**Pagination features:**
- **Page-based access**: Retrieve specific page numbers
- **Size control**: Configure number of records per page
- **Total count**: Provide pagination metadata for UI
- **Navigation**: Support for first, last, next, previous operations

## Segment Learning Objectives

- **Master dynamic querying**: Understand when and how to use flexible query approaches
- **Compare techniques**: Evaluate Query by Example vs Criteria API vs Specifications
- **Implement solutions**: Build dynamic queries for real-world scenarios
- **Optimize performance**: Use pagination and sorting for efficient data access

![Segment Learning Objectives](assets/segment-learning-objectives.png)

**Skills to be developed:**
- **Query by Example**: Entity-based filtering implementation
- **Criteria API**: Programmatic query construction
- **Specifications**: Reusable query component creation
- **Pagination**: Efficient large dataset handling
- **Best practices**: Choose appropriate technique for specific requirements

## Key Points

- **Main takeaway**: Dynamic queries solve the limitation of static query methods by allowing flexible, runtime-constructed queries based on varying user input
- **Query by Example**: Simplest approach using entity instances as search templates, best for basic equality-based filtering
- **Criteria API**: Most powerful approach providing full programmatic control over query construction with type safety
- **Specifications**: Best balance of reusability and composability, allowing query logic to be encapsulated in testable components
- **Sorting and pagination**: Essential for handling large datasets efficiently and providing good user experience
- **Problem scope**: Addresses the combinatorial explosion of query methods needed for different parameter combinations
- **Solution evaluation**: Each approach has specific strengths - choose based on complexity requirements and reusability needs
- **Performance considerations**: Dynamic queries can handle large datasets more efficiently than loading all data and filtering in memory
- **User-driven scenarios**: Particularly valuable for search forms, filters, and reporting features where users specify criteria
- **Spring Data integration**: All approaches integrate seamlessly with Spring Data JPA repository pattern

## Links/References

- Video: 4.10.0-Writing-Dynamic-Queries.mp4 (01:09)
- Previous: [Exercise: Writing Custom Queries](4.9.7-Exercise-Writing-Custom-Queries.md)
- Next: Query by Example
- Reference: [Spring Data JPA Dynamic Queries](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#query-by-example)
- Reference: [JPA Criteria API](https://docs.oracle.com/javaee/7/tutorial/persistence-criteria.htm)
- Reference: [Spring Data Specifications](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#specifications)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

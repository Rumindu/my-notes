# Dynamic Queries Using Criteria API

<!-- omit from toc -->

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Criteria API Overview](#criteria-api-overview)
- [Creating Custom Repository Interface](#creating-custom-repository-interface)
- [Extending Main Repository Interface](#extending-main-repository-interface)
- [Implementing Service Layer Methods](#implementing-service-layer-methods)
- [Understanding Repository Implementation Requirements](#understanding-repository-implementation-requirements)
- [Creating Repository Implementation Class](#creating-repository-implementation-class)
- [Entity Manager and Persistence Context](#entity-manager-and-persistence-context)
- [Building Dynamic Queries with CriteriaBuilder](#building-dynamic-queries-with-criteriabuilder)
- [Creating Query Root and Criteria Query](#creating-query-root-and-criteria-query)
- [Dynamic Predicate Construction](#dynamic-predicate-construction)
- [String Matching with LIKE Operator](#string-matching-with-like-operator)
- [Numeric Range Filtering](#numeric-range-filtering)
- [Assembling and Executing Queries](#assembling-and-executing-queries)
- [Testing Dynamic Query Behavior](#testing-dynamic-query-behavior)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Criteria API Overview

- **Dynamic querying**: Build queries at runtime based on changing conditions using Java code
- **Programmatic approach**: Construct SQL queries using Java APIs instead of static JPQL or SQL strings
- **Runtime flexibility**: Add or remove query conditions based on parameter values
- **Type-safe queries**: Compile-time checking prevents many query errors

![Criteria API Overview](assets/criteria-api-overview.png)

**Use cases for Criteria API:**
- **Advanced search forms**: Multiple optional filter criteria
- **Conditional queries**: Query conditions that change based on business logic
- **Complex filtering**: Dynamic combinations of WHERE clauses
- **Runtime query construction**: Building queries based on user input or configuration

## Creating Custom Repository Interface

- **Separate interface**: Create dedicated interface for criteria-based queries
- **Naming convention**: Use descriptive names like ProductCriteriaRepository
- **Method signatures**: Define methods that accept multiple optional parameters
- **Parameter flexibility**: Allow null values for optional search criteria

```java
// Create custom repository interface
public interface ProductCriteriaRepository {
    
    // Method with multiple optional parameters
    List<Product> findProductsByCriteria(
        String name,           // Optional name filter
        BigDecimal minPrice,   // Optional minimum price
        BigDecimal maxPrice    // Optional maximum price
    );
    
    // Could add more criteria methods as needed
    // List<Product> findProductsByAdvancedCriteria(SearchCriteria criteria);
}
```

![Custom Repository Interface](assets/custom-repository-interface.png)

## Extending Main Repository Interface

- **Interface composition**: Main repository extends both JPA Repository and custom criteria repository
- **Multiple inheritance**: Combine built-in methods with custom criteria methods
- **Single repository**: Client code uses one repository interface for all query types
- **Method availability**: All query methods accessible through main repository interface

```java
// Extend main repository with criteria capability
public interface ProductRepository extends 
    JpaRepository<Product, Long>, 
    ProductCriteriaRepository {
    
    // Derived query methods still available
    List<Product> findByName(String name);
    
    // Custom @Query methods still available
    @Query("SELECT p FROM Product p WHERE p.price > :price")
    List<Product> findMostExpensiveProducts(@Param("price") BigDecimal price);
    
    // Criteria methods now available via inheritance
    // List<Product> findProductsByCriteria(...) inherited
}
```

![Repository Interface Extension](assets/repository-interface-extension.png)

## Implementing Service Layer Methods

- **Service integration**: Add methods in service layer to use criteria-based queries
- **Parameter handling**: Pass optional criteria values, using null for unused filters
- **Method naming**: Use descriptive names that indicate criteria-based querying
- **Result processing**: Handle returned results same as other query methods

```java
@Service
public class UserService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public void fetchProductsByCriteria() {
        // Call criteria method with optional parameters
        List<Product> products = productRepository.findProductsByCriteria(
            null,                           // name filter (not used)
            BigDecimal.valueOf(1),          // minimum price
            BigDecimal.valueOf(10)          // maximum price
        );
        
        // Process results
        products.forEach(System.out::println);
    }
}
```

![Service Layer Implementation](assets/service-layer-implementation.png)

## Understanding Repository Implementation Requirements

- **Custom implementation needed**: Spring cannot generate implementation for criteria methods automatically
- **Naming convention**: Implementation class must follow specific naming pattern
- **Interface implementation**: Implementation class must implement custom repository interface
- **Spring recognition**: Spring automatically detects and wires implementation classes

![Repository Implementation Requirements](assets/repository-implementation-requirements.png)

**Error without implementation:**
- **Hibernate interpretation**: Tries to parse method name as derived query
- **Property not found**: Looks for "criteria" property in Product entity
- **Exception thrown**: "No property criteria found for type product"
- **Solution required**: Must provide custom implementation class

## Creating Repository Implementation Class

- **Naming pattern**: Interface name + "Impl" suffix (ProductCriteriaRepositoryImpl)
- **Interface implementation**: Implement the custom repository interface
- **Repository annotation**: Add @Repository for Spring component scanning
- **Constructor injection**: Use @AllArgsConstructor for dependency injection

```java
@Repository
@AllArgsConstructor
public class ProductCriteriaRepositoryImpl implements ProductCriteriaRepository {
    
    @PersistenceContext
    private final EntityManager entityManager;
    
    @Override
    public List<Product> findProductsByCriteria(
        String name, 
        BigDecimal minPrice, 
        BigDecimal maxPrice) {
        // Implementation using Criteria API
        // ... (implementation details in following sections)
    }
}
```

![Repository Implementation Class](assets/repository-implementation-class.png)

## Entity Manager and Persistence Context

- **EntityManager**: JPA interface for interacting with persistence context
- **@PersistenceContext**: Annotation for injecting EntityManager instance
- **Hibernate access**: Direct access to underlying Hibernate functionality
- **Query construction**: Foundation for building dynamic criteria queries

```java
@Repository
@AllArgsConstructor
public class ProductCriteriaRepositoryImpl implements ProductCriteriaRepository {
    
    // EntityManager for direct JPA/Hibernate access
    @PersistenceContext
    private final EntityManager entityManager;
    
    // EntityManager provides:
    // - getCriteriaBuilder() for query construction
    // - createQuery() for query execution
    // - Access to persistence context operations
}
```

![EntityManager and Persistence Context](assets/entitymanager-persistence-context.png)

## Building Dynamic Queries with CriteriaBuilder

- **CriteriaBuilder**: Factory for creating query elements (predicates, expressions, functions)
- **Query construction**: Start point for building type-safe dynamic queries
- **Method availability**: Provides methods for all SQL operations (like, equal, greaterThan, etc.)
- **Builder pattern**: Chain method calls to construct complex query conditions

```java
@Override
public List<Product> findProductsByCriteria(
    String name, BigDecimal minPrice, BigDecimal maxPrice) {
    
    // 1. Get CriteriaBuilder from EntityManager
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    
    // CriteriaBuilder provides methods for:
    // - like(), equal(), notEqual()
    // - greaterThan(), lessThan(), between()
    // - and(), or(), not()
    // - All SQL operators and functions
}
```

![CriteriaBuilder Usage](assets/criteriabuilder-usage.png)

## Creating Query Root and Criteria Query

- **CriteriaQuery**: Represents the overall query structure
- **Root entity**: Defines the main table/entity being queried (FROM clause)
- **Type safety**: Generic types ensure compile-time type checking
- **Query foundation**: Establishes base structure for adding conditions

```java
@Override
public List<Product> findProductsByCriteria(
    String name, BigDecimal minPrice, BigDecimal maxPrice) {
    
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    
    // 2. Create CriteriaQuery for Product entity
    CriteriaQuery<Product> cq = cb.createQuery(Product.class);
    
    // 3. Define root entity (FROM products)
    Root<Product> root = cq.from(Product.class);
    
    // This establishes: "FROM products" part of SQL query
    // Root provides access to entity fields for conditions
}
```

![Query Root and CriteriaQuery](assets/query-root-criteriaquery.png)

## Dynamic Predicate Construction

- **Predicate list**: Collection to store dynamic query conditions
- **Conditional addition**: Add predicates only when parameters are not null
- **Jakarta Persistence**: Use jakarta.persistence.criteria.Predicate for conditions
- **Dynamic building**: Construct WHERE clause conditions based on runtime values

```java
@Override
public List<Product> findProductsByCriteria(
    String name, BigDecimal minPrice, BigDecimal maxPrice) {
    
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Product> cq = cb.createQuery(Product.class);
    Root<Product> root = cq.from(Product.class);
    
    // 4. Create list for dynamic predicates
    List<Predicate> predicates = new ArrayList<>();
    
    // Add conditions only if parameters are not null
    // This allows for flexible, optional filtering
}
```

![Dynamic Predicate Construction](assets/dynamic-predicate-construction.png)

## String Matching with LIKE Operator

- **LIKE operator**: Pattern matching for string fields using CriteriaBuilder.like()
- **Wildcard patterns**: Automatic addition of % wildcards for substring matching
- **Root field access**: Use root.get("fieldName") to reference entity properties
- **String concatenation**: Combine wildcards with parameter values for flexible matching

```java
// 5. Add name filter if provided
if (name != null) {
    predicates.add(
        cb.like(
            root.get("name"),                    // Field reference
            "%" + name + "%"                     // Pattern with wildcards
        )
    );
    // Generates: WHERE name LIKE '%parameterValue%'
}
```

![String Matching with LIKE](assets/string-matching-like.png)

## Numeric Range Filtering

- **Range conditions**: Use greaterThanOrEqualTo() and lessThanOrEqualTo() for numeric ranges
- **Field type safety**: Root.get() provides type-safe field access
- **Comparison operators**: Full range of comparison methods available
- **Boundary conditions**: Flexible minimum and maximum value filtering

```java
// 6. Add minimum price filter if provided
if (minPrice != null) {
    predicates.add(
        cb.greaterThanOrEqualTo(
            root.get("price"),                   // Price field
            minPrice                             // Minimum value
        )
    );
    // Generates: WHERE price >= minPrice
}

// 7. Add maximum price filter if provided
if (maxPrice != null) {
    predicates.add(
        cb.lessThanOrEqualTo(
            root.get("price"),                   // Price field
            maxPrice                             // Maximum value
        )
    );
    // Generates: WHERE price <= maxPrice
}
```

![Numeric Range Filtering](assets/numeric-range-filtering.png)

## Assembling and Executing Queries

- **Query assembly**: Combine SELECT, WHERE clauses using CriteriaQuery methods
- **Predicate array**: Convert predicate list to array for where() method
- **Query execution**: Use EntityManager.createQuery() and getResultList()
- **SQL generation**: Hibernate generates optimized SQL from criteria query

```java
@Override
public List<Product> findProductsByCriteria(
    String name, BigDecimal minPrice, BigDecimal maxPrice) {
    
    // ... predicate construction code above ...
    
    // 8. Assemble final query
    cq.select(root)                              // SELECT root entity
      .where(predicates.toArray(new Predicate[0])); // WHERE predicates
    
    // 9. Execute query and return results
    return entityManager
        .createQuery(cq)                         // Create executable query
        .getResultList();                        // Execute and get results
}
```

![Query Assembly and Execution](assets/query-assembly-execution.png)

## Testing Dynamic Query Behavior

- **Runtime flexibility**: Different parameter combinations produce different SQL queries
- **Null parameter handling**: Null values excluded from WHERE clause automatically
- **SQL generation**: Hibernate shows generated SQL with actual parameter values
- **Parameter modification**: Change criteria values to see different query results

```java
// Test different parameter combinations

// Example 1: Price range only
List<Product> products1 = repository.findProductsByCriteria(
    null,                    // No name filter
    BigDecimal.valueOf(1),   // Min price = 1
    BigDecimal.valueOf(10)   // Max price = 10
);
// Generates: WHERE price >= 1 AND price <= 10

// Example 2: Name and minimum price
List<Product> products2 = repository.findProductsByCriteria(
    "product",              // Name contains "product"  
    BigDecimal.valueOf(1),  // Min price = 1
    null                    // No max price limit
);
// Generates: WHERE name LIKE '%product%' AND price >= 1
```

![Testing Dynamic Queries](assets/testing-dynamic-queries.png)

![Generated SQL Output](assets/generated-sql-output.png)

## Key Points

- **Main takeaway**: Criteria API enables building dynamic queries programmatically using Java code, allowing runtime construction of complex WHERE clauses based on changing conditions
- **Implementation pattern**: Create separate criteria repository interface, implement with custom class using EntityManager and CriteriaBuilder
- **Query construction**: Use CriteriaBuilder to create query elements, CriteriaQuery for overall structure, and Root for entity field access
- **Dynamic conditions**: Build predicate lists conditionally, adding only non-null parameter conditions to allow flexible filtering
- **Type safety**: Criteria API provides compile-time type checking and prevents many SQL syntax errors
- **String matching**: Use CriteriaBuilder.like() with wildcard patterns for flexible text searching
- **Numeric ranges**: Employ greaterThanOrEqualTo() and lessThanOrEqualTo() for boundary condition filtering
- **Repository integration**: Main repository interface extends both JpaRepository and custom criteria repository for unified access
- **Execution process**: Assemble query with select() and where() methods, then execute via EntityManager.createQuery().getResultList()
- **Runtime flexibility**: Same method produces different SQL queries based on parameter values - ideal for advanced search functionality and conditional business logic

## Links/References

- Video: 4.10.2-Dynamic-Queries-Using-Criteria-API.mp4 (09:59)
- Previous: [Query by Example](4.10.1-Query-by-Example.md)
- Next: JPA Specifications for Complex Queries
- Reference: [JPA Criteria API Documentation](https://docs.oracle.com/javaee/7/tutorial/persistence-criteria.htm)
- Reference: [Spring Data JPA Specifications](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#specifications)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

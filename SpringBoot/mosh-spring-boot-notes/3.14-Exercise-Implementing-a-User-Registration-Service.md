# Exercise: Implementing a User Registration Service

<!-- omit from toc -->
## Table of Contents

- [Exercise Overview](#exercise-overview)
- [System Requirements](#system-requirements)
- [Class Diagram Analysis](#class-diagram-analysis)
  - [User Repository Interface](#user-repository-interface)
  - [Notification Service Interface](#notification-service-interface)
  - [User Service Class](#user-service-class)
- [Implementation Steps](#implementation-steps)
- [Solution Walkthrough](#solution-walkthrough)
  - [User Entity Class](#user-entity-class)
  - [User Repository Implementation](#user-repository-implementation)
  - [Enhanced Notification Service](#enhanced-notification-service)
  - [User Service Implementation](#user-service-implementation)
  - [Application Configuration](#application-configuration)
  - [Main Application Testing](#main-application-testing)
- [Testing the Application](#testing-the-application)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Exercise Overview

- **Purpose**: Design and implement a user registration service that practices dependency injection concepts
- **Core functionality**: Allow users to register with name, email, and password
- **Features**: Save users to repository and send notification after registration
- **Configuration**: Mail server settings configurable via application.yaml
- **Simulation**: No actual emails sent - just demonstration of notification flow

![Exercise Overview Diagram](assets/user-registration-exercise-overview.png)

**Key learning objectives:**
- Practice dependency injection with multiple interfaces
- Implement repository pattern for data storage
- Use @Value annotation for external configuration
- Handle duplicate user registration scenarios
- Apply service layer design patterns

## System Requirements

- **User registration**: Accept name, email, and password input
- **Data persistence**: Save users to in-memory repository
- **Notification system**: Send welcome message after successful registration
- **Configuration management**: External mail server settings via YAML
- **Duplicate prevention**: Detect and prevent duplicate email registrations
- **Error handling**: Throw exceptions for duplicate users

![System Requirements Flow](assets/user-registration-system-requirements.png)

**Technical requirements:**
- Use Spring Boot dependency injection
- Implement interface-based design
- Configure mail settings externally
- Handle edge cases (duplicates)

## Class Diagram Analysis

### User Repository Interface

```java
public interface UserRepository {
    void save(User user);
    User findByEmail(String email);  // For duplicate detection
}
```

![User Repository Interface Design](assets/user-repository-interface-design.png)

**Purpose:**
- **Abstraction**: Wrapper around database operations
- **Future extensibility**: Can add find, delete, update methods
- **Single implementation**: InMemoryUserRepository for this exercise

### Notification Service Interface

```java
public interface NotificationService {
    void send(String message, String recipientEmail);
}
```

![Notification Service Interface Design](assets/notification-service-interface-design.png)

**Enhanced interface:**
- **Two parameters**: Message content and recipient email
- **Single implementation**: EmailNotificationService
- **Extensibility**: Future SMS or push notification implementations

### User Service Class

- **Dependencies**: UserRepository and NotificationService interfaces
- **Main method**: registerUser() that coordinates the registration process
- **Flow**: Check for duplicates → Save user → Send notification
- **Error handling**: Throw exception for duplicate emails

![User Service Class Design](assets/user-service-class-design.png)

## Implementation Steps

**Step-by-step approach:**
1. Create User entity class with required fields
2. Define UserRepository interface with save and findByEmail methods
3. Implement InMemoryUserRepository using HashMap storage
4. Enhance NotificationService interface with recipient parameter
5. Update EmailNotificationService with configurable mail settings
6. Create UserService class with registration logic
7. Configure application.yaml with mail settings
8. Test with duplicate registration scenarios

![Implementation Steps Flow](assets/implementation-steps-flow.png)

**Time allocation**: Approximately 20 minutes for complete implementation

## Solution Walkthrough

### User Entity Class

```java
public class User {
    private String name;
    private String email;
    private String password;
    private String id;  // Optional: for unique identification
    
    public User(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }
    
    // Standard getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}
```

![User Entity Implementation](assets/user-entity-implementation.png)

**Entity features:**
- **Four fields**: name, email, password, id
- **Constructor**: Initialize user with required data
- **Standard methods**: Complete getters and setters

### User Repository Implementation

```java
@Repository
public class InMemoryUserRepository implements UserRepository {
    private Map<String, User> users = new HashMap<>();
    
    @Override
    public void save(User user) {
        System.out.println("Saving user: " + user);
        users.put(user.getEmail(), user);
    }
    
    @Override
    public User findByEmail(String email) {
        return users.getOrDefault(email, null);
    }
}
```

![InMemory Repository Implementation](assets/inmemory-repository-implementation.png)

**Implementation details:**
- **@Repository annotation**: Marks as Spring repository bean
- **HashMap storage**: In-memory data storage using email as key
- **getOrDefault method**: Returns null if user not found
- **Print statement**: Shows save operation for demonstration

### Enhanced Notification Service

```java
@Service
public class EmailNotificationService implements NotificationService {
    @Value("${mail.host}")
    private String host;
    
    @Value("${mail.port}")
    private int port;
    
    @Override
    public void send(String message, String recipientEmail) {
        System.out.println("Sending email...");
        System.out.println("To: " + recipientEmail);
        System.out.println("Message: " + message);
        System.out.println("Mail server: " + host + ":" + port);
    }
}
```

![Enhanced Notification Service](assets/enhanced-notification-service.png)

**Configuration features:**
- **@Value annotations**: Inject mail settings from application.yaml
- **External configuration**: Host and port configurable
- **Enhanced send method**: Displays all notification details

### User Service Implementation

```java
@Service
public class UserService {
    private UserRepository userRepository;
    private NotificationService notificationService;
    
    public UserService(UserRepository userRepository, 
                      NotificationService notificationService) {
        this.userRepository = userRepository;
        this.notificationService = notificationService;
    }
    
    public void registerUser(User user) {
        // Check for duplicate user
        User existingUser = userRepository.findByEmail(user.getEmail());
        if (existingUser != null) {
            throw new IllegalArgumentException(
                "User with email " + user.getEmail() + " already exists");
        }
        
        // Save user
        userRepository.save(user);
        
        // Send notification
        notificationService.send(
            "You registered successfully!", 
            user.getEmail()
        );
    }
}
```

![User Service Implementation](assets/user-service-implementation.png)

**Service logic:**
- **Constructor injection**: Inject both dependencies
- **Duplicate check**: Query repository before saving
- **Exception handling**: Throw IllegalArgumentException for duplicates
- **Notification flow**: Send welcome message after successful save

### Application Configuration

```yaml
# application.yaml
mail:
  host: smtp.example.com
  port: 587
```

![Application YAML Configuration](assets/application-yaml-configuration.png)

**Configuration structure:**
- **mail section**: Top-level configuration key
- **host and port**: Subkeys for mail server settings
- **Demo values**: Not real mail server - just for demonstration

### Main Application Testing

```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        ConfigurableApplicationContext context = 
            SpringApplication.run(StoreApplication.class, args);
        
        UserService userService = context.getBean(UserService.class);
        
        User user = new User("John Doe", "john@example.com", "password123");
        
        // First registration - should succeed
        userService.registerUser(user);
        
        // Second registration - should fail with exception
        userService.registerUser(user);
        
        context.close();
    }
}
```

![Main Application Testing](assets/main-application-testing.png)

**Test scenario:**
- **Same user twice**: Register identical user to test duplicate detection
- **Expected behavior**: First succeeds, second throws exception

## Testing the Application

**Expected output for successful registration:**
```
Saving user: User@hashcode
Sending email...
To: john@example.com
Message: You registered successfully!
Mail server: smtp.example.com:587
```

![Successful Registration Output](assets/successful-registration-output.png)

**Expected output for duplicate registration:**
```
Exception in thread "main" java.lang.IllegalArgumentException: 
User with email john@example.com already exists
```

![Duplicate Registration Exception](assets/duplicate-registration-exception.png)

**Verification points:**
- **User saved**: Repository save method called
- **Notification sent**: Email details displayed with configuration
- **Duplicate prevention**: Exception thrown for second registration
- **Configuration injection**: Mail host and port properly injected

## Key Points

- **Main takeaway**: Successfully implemented a complete user registration system using Spring Boot dependency injection patterns
- **Interface design**: Used repository and notification service interfaces for loose coupling and testability
- **Configuration management**: External mail settings via @Value annotation and application.yaml provide flexibility
- **Error handling**: Proper duplicate user detection prevents data inconsistency
- **Dependency injection**: Constructor injection used throughout for required dependencies
- **Repository pattern**: In-memory implementation simulates database operations
- **Service layer**: UserService coordinates between repository and notification services
- **Testing approach**: Duplicate registration scenario validates error handling
- **Real-world application**: Pattern applies to actual user registration systems with real databases and email services
- **Extensibility**: Interface-based design allows easy addition of new repository or notification implementations

## Links/References

- Video: 3.14-Exercise-Implementing-a-User-Registration-Service.mp4 (5m 47s)
- Previous: [Bean Lifecycle Hooks](3.13-Bean-Lifecycle-Hooks.md)
- Next: Summary of Dependency Injection Section

---

**Created**: July 30, 2025  
**Last Modified**: July 30, 2025

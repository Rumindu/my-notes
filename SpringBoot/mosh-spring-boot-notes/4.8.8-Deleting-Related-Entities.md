# Deleting Related Entities

<!-- omit from toc -->

## Table of Contents

- [Deleting Related Entities Overview](#deleting-related-entities-overview)
- [Creating Delete Related Method](#creating-delete-related-method)
- [Initial Delete Attempt](#initial-delete-attempt)
- [Understanding Hibernate Delete Behavior](#understanding-hibernate-delete-behavior)
- [IntelliJ Navigation Shortcut](#intellij-navigation-shortcut)
- [Identifying Relationship Issues](#identifying-relationship-issues)
- [Implementing Cascade Remove](#implementing-cascade-remove)
- [Data Integrity Violation Analysis](#data-integrity-violation-analysis)
- [Database Foreign Key Constraints](#database-foreign-key-constraints)
- [Foreign Key Action Options](#foreign-key-action-options)
- [Application-Level Cascading](#application-level-cascading)
- [Multiple Cascade Types](#multiple-cascade-types)
- [Testing Complete Delete Operation](#testing-complete-delete-operation)
- [Deleting Child Entities](#deleting-child-entities)
- [Lazy Initialization in Delete Operations](#lazy-initialization-in-delete-operations)
- [Orphan Entity Problem](#orphan-entity-problem)
- [Orphan Removal Solution](#orphan-removal-solution)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Deleting Related Entities Overview

- **Complex operation**: Deleting entities with relationships requires careful handling
- **Referential integrity**: Database constraints prevent orphaned records
- **Cascade operations**: Automatic deletion of related entities
- **Orphan management**: Handling entities without parent references

![Deleting Related Entities Overview](assets/deleting-related-entities-overview.png)

**Deletion challenges:**
- **Foreign key constraints**: Database prevents deletion of referenced entities
- **Relationship management**: Related entities must be handled appropriately
- **Data integrity**: Ensure no orphaned records remain
- **Cascade configuration**: Proper setup required for automatic cleanup

## Creating Delete Related Method

- **Service method**: Add deleteRelated method to UserService
- **Simple deletion**: Use repository.deleteById() to remove user
- **Testing approach**: Observe Hibernate behavior during deletion
- **Method structure**: Basic delete operation to understand default behavior

```java
@Service
public class UserService {
    
    public void deleteRelated() {
        userRepository.deleteById(1L);
    }
}
```

![Delete Related Method Creation](assets/delete-related-method-creation.png)

## Initial Delete Attempt

- **Application execution**: Run deleteRelated method to observe behavior
- **Console monitoring**: Watch SQL statements generated by Hibernate
- **Unexpected behavior**: SELECT statement generated but no DELETE
- **Analysis requirement**: Understand why deletion didn't occur

```java
// In main method
var service = context.getBean(UserService.class);
service.deleteRelated();
```

![Initial Delete Attempt Execution](assets/initial-delete-attempt-execution.png)

## Understanding Hibernate Delete Behavior

- **Pre-deletion fetch**: Hibernate fetches entity before deletion
- **Relationship validation**: Ensures referential integrity can be maintained
- **Eager loading**: Related entities loaded due to default fetch strategies
- **Safety check**: Framework verifies deletion won't violate constraints

![Hibernate Delete Behavior Analysis](assets/hibernate-delete-behavior-analysis.png)

**Generated SQL pattern:**
```sql
SELECT u1.id, u1.email, u1.name, u1.password,
       p1.id, p1.bio, p1.date_of_birth, p1.loyalty_points
FROM users u1
LEFT JOIN profiles p1 ON u1.id = p1.user_id
WHERE u1.id = ?
-- No DELETE statement follows
```

![Pre-Delete Select Statement](assets/pre-delete-select-statement.png)

**Why SELECT before DELETE:**
- **Relationship discovery**: Hibernate needs to know what related entities exist
- **Constraint checking**: Verify that deletion won't violate database integrity
- **Cascade planning**: Determine what related entities need handling
- **State validation**: Ensure entity is in valid state for deletion

## IntelliJ Navigation Shortcut

- **Quick navigation**: Command+F12 (Mac) or Ctrl+F12 (Windows) for class members
- **Function key**: Hold Function key with F12 on Mac
- **Member filtering**: Type to filter specific fields or methods
- **Direct jump**: Press Enter to navigate to selected member

![IntelliJ Class Member Navigation](assets/intellij-class-member-navigation.png)

**Navigation workflow:**
1. **Open member list**: Use keyboard shortcut in class
2. **Filter members**: Type field name (e.g., "profile")
3. **Select target**: Choose from filtered results
4. **Navigate**: Press Enter to jump to field

![Class Member Filter Dialog](assets/class-member-filter-dialog.png)

## Identifying Relationship Issues

- **Profile relationship**: One-to-One relationship prevents user deletion
- **Missing cascade**: No cascade configuration for related entity handling
- **Deletion blocked**: Hibernate doesn't know how to handle profile entity
- **Solution requirement**: Enable cascade delete operations

```java
@Entity
public class User {
    @OneToOne(mappedBy = "user")  // No cascade configuration
    private Profile profile;      // Blocks deletion
}
```

![Relationship Issue Identification](assets/relationship-issue-identification.png)

## Implementing Cascade Remove

- **Cascade attribute**: Add cascade = CascadeType.REMOVE to relationship
- **Automatic deletion**: Profile entity deleted when user deleted
- **Referential integrity**: Maintains database consistency
- **Single operation**: One delete command handles multiple entities

```java
@Entity
public class User {
    @OneToOne(mappedBy = "user", cascade = CascadeType.REMOVE)
    private Profile profile;
}
```

![Cascade Remove Implementation](assets/cascade-remove-implementation.png)

## Data Integrity Violation Analysis

- **Exception occurrence**: Data integrity violation after adding cascade
- **Foreign key constraint**: Database prevents deletion due to address references
- **SQL execution**: Multiple delete operations before failure
- **Root cause**: Addresses table references user but lacks cascade handling

![Data Integrity Violation Exception](assets/data-integrity-violation-exception.png)

**SQL execution sequence:**
```sql
SELECT ... FROM users u1 LEFT JOIN profiles p1 ...  -- Fetch user and profile
DELETE FROM wishlist WHERE user_id = ?             -- Delete wishlist entries
DELETE FROM user_tags WHERE user_id = ?            -- Delete user tags
DELETE FROM profiles WHERE user_id = ?             -- Delete profile (cascade)
DELETE FROM users WHERE id = ?                     -- Fails due to addresses
```

![Delete Operation SQL Sequence](assets/delete-operation-sql-sequence.png)

## Database Foreign Key Constraints

- **Foreign key definition**: Addresses table has foreign key to users table
- **Constraint action**: ON DELETE NO ACTION prevents user deletion
- **Database-level protection**: Prevents orphaned address records
- **Action options**: Various strategies for handling parent deletion

![Database Foreign Key Constraints](assets/database-foreign-key-constraints.png)

**Foreign key constraint details:**
```sql
-- Addresses table foreign key
CONSTRAINT fk_addresses_user_id 
FOREIGN KEY (user_id) REFERENCES users(id) 
ON DELETE NO ACTION
```

![Foreign Key Constraint Definition](assets/foreign-key-constraint-definition.png)

## Foreign Key Action Options

- **NO ACTION**: Prevent deletion if child records exist (default)
- **RESTRICT**: Similar to NO ACTION, prevents parent deletion
- **SET NULL**: Set foreign key to NULL when parent deleted (creates orphans)
- **SET DEFAULT**: Set foreign key to default value (usually 0)
- **CASCADE**: Delete child records when parent deleted

![Foreign Key Action Options](assets/foreign-key-action-options.png)

**Action comparison:**
- **NO ACTION/RESTRICT**: Safest but requires manual cleanup
- **SET NULL**: Creates orphan records (generally undesirable)
- **SET DEFAULT**: May create invalid references
- **CASCADE**: Automatic cleanup but requires careful consideration

**Database vs Application cascading:**
- **Database CASCADE**: Handled by database engine
- **Application cascading**: Handled by Hibernate/JPA
- **Control considerations**: Application cascading provides more control
- **Environment constraints**: Database changes may not be allowed

## Application-Level Cascading

- **Alternative approach**: Handle cascading in application rather than database
- **Organizational constraints**: Database changes may require approval
- **Multiple applications**: Other apps may depend on same database
- **Flexibility**: Application-level control over cascade behavior

![Application Level Cascading Approach](assets/application-level-cascading-approach.png)

## Multiple Cascade Types

- **Combine operations**: Multiple cascade types on same relationship
- **Array syntax**: Use braces to specify multiple cascade types
- **PERSIST and REMOVE**: Common combination for complete lifecycle management
- **Selective cascading**: Choose specific operations to cascade

```java
@Entity
public class User {
    @OneToMany(mappedBy = "user", cascade = {CascadeType.PERSIST, CascadeType.REMOVE})
    private List<Address> addresses = new ArrayList<>();
}
```

![Multiple Cascade Types Implementation](assets/multiple-cascade-types-implementation.png)

**Cascade type combinations:**
- **PERSIST + REMOVE**: Full lifecycle management
- **PERSIST + MERGE**: Creation and updates only
- **Custom combinations**: Based on specific business requirements

## Testing Complete Delete Operation

- **Successful deletion**: All related entities deleted in correct order
- **SQL statements**: Multiple DELETE operations for related entities
- **Order dependency**: Child entities deleted before parent
- **Complete cleanup**: No orphaned records remain

![Complete Delete Operation Success](assets/complete-delete-operation-success.png)

**Successful delete sequence:**
```sql
SELECT ... FROM users ...              -- Fetch user and relationships
DELETE FROM wishlist WHERE user_id=?   -- Delete wishlist entries
DELETE FROM user_tags WHERE user_id=?  -- Delete user tags
DELETE FROM profiles WHERE user_id=?   -- Delete profile
DELETE FROM addresses WHERE user_id=?  -- Delete addresses (cascade)
DELETE FROM users WHERE id=?           -- Delete user
```

![Successful Delete SQL Sequence](assets/successful-delete-sql-sequence.png)

## Deleting Child Entities

- **Child entity removal**: Remove address from user without deleting user
- **Orphan creation**: Address becomes orphan when removed from user
- **Helper method usage**: Use removeAddress() helper method
- **Database constraints**: User ID column may not allow NULL values

```java
public void deleteChildEntity() {
    var user = userRepository.findById(3L).orElseThrow();
    var address = user.getAddresses().get(0);  // Get first address
    user.removeAddress(address);               // Remove from user
    userRepository.save(user);                 // Save changes
}
```

![Child Entity Deletion Method](assets/child-entity-deletion-method.png)

## Lazy Initialization in Delete Operations

- **LazyInitializationException**: Accessing lazy-loaded collection outside transaction
- **Transaction boundary**: Repository method transaction ends before collection access
- **Solution requirement**: Extend transaction scope with @Transactional
- **Context necessity**: Persistence context needed for lazy loading

![Lazy Initialization Exception](assets/lazy-initialization-exception-delete.png)

**Exception cause:**
1. **Repository call**: findById() creates short transaction
2. **Transaction end**: Persistence context closed after repository method
3. **Lazy access**: getAddresses() tries to load collection without context
4. **Exception thrown**: LazyInitializationException occurs

**Solution:**
```java
@Transactional  // Extend transaction scope
public void deleteChildEntity() {
    var user = userRepository.findById(3L).orElseThrow();
    var address = user.getAddresses().get(0);  // Now works - context active
    user.removeAddress(address);
    userRepository.save(user);
}
```

![Transactional Annotation Solution](assets/transactional-annotation-solution-delete.png)

## Orphan Entity Problem

- **Orphan creation**: Address entity loses parent reference (user_id = NULL)
- **Database constraint**: user_id column doesn't allow NULL values
- **Data integrity violation**: Cannot save orphan entity to database
- **Business logic issue**: Orphan addresses don't make business sense

![Orphan Entity Problem](assets/orphan-entity-problem.png)

**removeAddress() helper method behavior:**
```java
public void removeAddress(Address address) {
    addresses.remove(address);    // Remove from collection
    address.setUser(null);        // Creates orphan - user_id becomes NULL
}
```

![Remove Address Helper Method](assets/remove-address-helper-method.png)

**Database constraint violation:**
```sql
-- This fails because user_id cannot be NULL
UPDATE addresses SET user_id = NULL WHERE id = ?
```

![Orphan Entity Database Error](assets/orphan-entity-database-error.png)

## Orphan Removal Solution

- **orphanRemoval attribute**: Set to true on relationship annotation
- **Automatic deletion**: Hibernate deletes orphan entities automatically
- **Clean removal**: No NULL assignment, direct entity deletion
- **Data integrity**: Maintains referential integrity without orphans

```java
@Entity
public class User {
    @OneToMany(mappedBy = "user", 
               cascade = {CascadeType.PERSIST, CascadeType.REMOVE},
               orphanRemoval = true)  // Automatically delete orphans
    private List<Address> addresses = new ArrayList<>();
}
```

![Orphan Removal Implementation](assets/orphan-removal-implementation.png)

**Orphan removal behavior:**
- **Entity tracking**: Hibernate tracks entities removed from collection
- **Automatic deletion**: Orphaned entities deleted from database
- **Clean operation**: No NULL assignments or constraint violations
- **Business alignment**: Matches business logic (addresses need users)

**Successful orphan removal:**
```sql
SELECT ... FROM users ...           -- Load user and addresses
SELECT ... FROM addresses ...       -- Verify address exists
DELETE FROM addresses WHERE id=?    -- Delete orphaned address directly
```

![Successful Orphan Removal SQL](assets/successful-orphan-removal-sql.png)

## Key Points

- **Main takeaway**: Deleting entities with relationships requires proper cascade configuration and orphan removal settings to maintain referential integrity
- **Hibernate pre-fetch**: Framework fetches entities before deletion to verify relationships and plan cascade operations
- **Cascade types**: Use CascadeType.REMOVE to automatically delete related entities when parent is deleted
- **Multiple cascades**: Combine cascade types (PERSIST, REMOVE) using array syntax for complete lifecycle management
- **Foreign key constraints**: Database-level constraints prevent deletion of referenced entities unless properly configured
- **Application vs database cascading**: Application-level cascading provides more control and flexibility than database-level CASCADE
- **Orphan removal**: Set orphanRemoval = true to automatically delete entities removed from parent collections
- **Transaction scope**: Use @Transactional for operations involving lazy-loaded collections to avoid LazyInitializationException
- **Data integrity**: Proper cascade and orphan removal configuration prevents orphaned records and constraint violations
- **IntelliJ productivity**: Use Cmd+F12/Ctrl+F12 shortcut for quick navigation to class members during development

## Links/References

- Video: 4.8.8-Deleting-Related-Entities.mp4 (10:08)
- Previous: [Persisting Related Entities](4.8.7-Persisting-Related-Entities.md)
- Next: Advanced Entity Relationships
- Reference: [JPA Cascade Types](https://docs.oracle.com/javaee/7/api/javax/persistence/CascadeType.html)
- Reference: [Hibernate Orphan Removal](https://docs.jboss.org/hibernate/orm/5.6/userguide/html_single/Hibernate_User_Guide.html#pc-cascade-orphan)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

# Calling Stored Procedures

<!-- omit from toc -->

## Table of Contents

- [Stored Procedures Overview](#stored-procedures-overview)
- [When to Use Stored Procedures](#when-to-use-stored-procedures)
- [Creating Migration for Stored Procedure](#creating-migration-for-stored-procedure)
- [MySQL Stored Procedure Syntax](#mysql-stored-procedure-syntax)
- [Delimiter Configuration](#delimiter-configuration)
- [Stored Procedure Implementation](#stored-procedure-implementation)
- [Running the Migration](#running-the-migration)
- [Verifying Stored Procedure Creation](#verifying-stored-procedure-creation)
- [Testing Stored Procedure in Database](#testing-stored-procedure-in-database)
- [Repository Integration with @Procedure](#repository-integration-with-procedure)
- [Service Method Implementation](#service-method-implementation)
- [Transaction Requirements](#transaction-requirements)
- [Testing the Integration](#testing-the-integration)
- [Generated SQL Analysis](#generated-sql-analysis)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Stored Procedures Overview

- **Database functions**: Stored procedures are functions that exist within the database
- **Complex query management**: Move complex SQL logic from application to database
- **Performance benefits**: Compiled and optimized execution plans
- **Centralized logic**: Business rules stored in database for consistency

![Stored Procedures Overview](assets/stored-procedures-overview.png)

**Benefits of stored procedures:**
- **Performance optimization**: Pre-compiled execution plans
- **Reduced network traffic**: Send parameters instead of full queries
- **Centralized business logic**: Database-level rule enforcement
- **Security**: Controlled data access through procedure interfaces

## When to Use Stored Procedures

- **Complex queries**: Multi-table joins with complex business logic
- **Performance-critical operations**: Queries requiring optimal execution plans
- **Batch operations**: Processing large datasets efficiently
- **Legacy system integration**: Working with existing database procedures

![When to Use Stored Procedures](assets/when-use-stored-procedures.png)

**Use case evaluation:**
- **Simple queries**: JPQL/HQL usually sufficient
- **Complex aggregations**: Stored procedures can be more efficient
- **Multi-step operations**: Database transactions with multiple operations
- **Reporting queries**: Complex analytical queries benefit from procedures

## Creating Migration for Stored Procedure

- **Migration file**: Create new Flyway migration for stored procedure
- **Version numbering**: Follow sequential versioning (V10__)
- **Descriptive naming**: Use clear names indicating procedure purpose
- **Database-specific**: Syntax depends on database engine (MySQL, PostgreSQL, etc.)

```sql
-- Migration file: V10__add_find_products_proc.sql
-- Create stored procedure for finding products by price range
```

![Migration File Creation](assets/migration-file-creation.png)

**Migration naming convention:**
- **Version prefix**: V10__ (sequential number)
- **Descriptive name**: add_find_products_proc
- **File extension**: .sql for SQL migrations
- **Underscore separator**: Double underscore after version

## MySQL Stored Procedure Syntax

- **CREATE PROCEDURE**: MySQL keyword for procedure creation
- **Case insensitive**: Keywords can be uppercase or lowercase
- **Convention preference**: Most developers prefer uppercase for SQL keywords
- **Parameter definition**: Specify parameter names and data types

```sql
CREATE PROCEDURE FindProductsByPrice(
    IN minPrice DECIMAL(10,2),
    IN maxPrice DECIMAL(10,2)
)
BEGIN
    -- Procedure body goes here
END
```

![MySQL Stored Procedure Syntax](assets/mysql-stored-procedure-syntax.png)

## Delimiter Configuration

- **Default delimiter**: MySQL uses semicolon (;) as statement terminator
- **Procedure conflict**: Semicolons inside procedures conflict with default delimiter
- **Temporary change**: Change delimiter during procedure creation
- **Common alternatives**: // or $$ used as temporary delimiters

```sql
DELIMITER $$

CREATE PROCEDURE FindProductsByPrice(
    IN minPrice DECIMAL(10,2),
    IN maxPrice DECIMAL(10,2)
)
BEGIN
    -- Multiple statements can use semicolons here;
    SELECT * FROM products WHERE price BETWEEN minPrice AND maxPrice;
END$$

DELIMITER ;
```

![Delimiter Configuration](assets/delimiter-configuration.png)

**Delimiter workflow:**
1. **Change delimiter**: `DELIMITER $$`
2. **Create procedure**: Use $$ to end procedure definition
3. **Reset delimiter**: `DELIMITER ;` back to default
4. **Internal semicolons**: Safe to use within procedure body

## Stored Procedure Implementation

- **Explicit column selection**: Avoid SELECT * for security and performance
- **Parameter usage**: Reference procedure parameters in WHERE clause
- **Business logic**: Include ordering and filtering logic
- **Best practices**: Select only required columns

```sql
DELIMITER $$

CREATE PROCEDURE FindProductsByPrice(
    IN minPrice DECIMAL(10,2),
    IN maxPrice DECIMAL(10,2)
)
BEGIN
    SELECT id, name, description, price, category_id
    FROM products
    WHERE price BETWEEN minPrice AND maxPrice
    ORDER BY name;
END$$

DELIMITER ;
```

![Stored Procedure Implementation](assets/stored-procedure-implementation.png)

**Implementation considerations:**
- **Column selection**: id, name, description, price, category_id (no SELECT *)
- **Parameter binding**: minPrice and maxPrice used in WHERE clause
- **Ordering**: ORDER BY name for consistent results
- **Data types**: DECIMAL(10,2) matches product table price column

## Running the Migration

- **Maven command**: Use Flyway Maven plugin to run migrations
- **Migration execution**: Flyway applies new migration to database
- **Version tracking**: Migration version recorded in schema_version table
- **Error handling**: Migration fails if syntax errors exist

![Running Migration Command](assets/running-migration-command.png)

**Migration process:**
1. **Execute migration**: `mvn flyway:migrate`
2. **Version check**: Flyway identifies new migration V10
3. **SQL execution**: Stored procedure created in database
4. **Version update**: schema_version table updated with V10

![Migration Success Output](assets/migration-success-output.png)

## Verifying Stored Procedure Creation

- **Database explorer**: Use IDE database tool to verify creation
- **Routines section**: Stored procedures appear under Routines
- **Procedure listing**: FindProductsByPrice visible in database
- **Structure verification**: Confirm procedure exists and is callable

![Database Routines Verification](assets/database-routines-verification.png)

**Verification steps:**
1. **Refresh database**: Update database view in IDE
2. **Navigate to routines**: Expand database â†’ Routines
3. **Locate procedure**: FindProductsByPrice should be listed
4. **Inspect definition**: View procedure parameters and body

## Testing Stored Procedure in Database

- **Query console**: Open database query console for testing
- **CALL statement**: Use CALL keyword to execute stored procedure
- **Parameter values**: Provide test values for procedure parameters
- **Result verification**: Confirm procedure returns expected data

![Database Query Console Testing](assets/database-query-console-testing.png)

**Test execution:**
```sql
-- Test with no expected results
CALL FindProductsByPrice(1, 5);

-- Test with expected results  
CALL FindProductsByPrice(1, 50);
```

![Stored Procedure Test Results](assets/stored-procedure-test-results.png)

## Repository Integration with @Procedure

- **@Procedure annotation**: Replace @Query with @Procedure
- **Procedure name**: Specify stored procedure name as parameter
- **Parameter simplification**: Remove @Param annotations
- **Cleaner code**: Less annotation overhead

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Replace @Query with @Procedure
    @Procedure("FindProductsByPrice")
    List<Product> findProducts(BigDecimal minPrice, BigDecimal maxPrice);
    
    // Old @Query approach (removed)
    // @Query("SELECT p FROM Product p WHERE p.price BETWEEN :min AND :max ORDER BY p.name")
    // List<Product> findProducts(@Param("min") BigDecimal min, @Param("max") BigDecimal max);
}
```

![Repository Procedure Integration](assets/repository-procedure-integration.png)

## Service Method Implementation

- **Method call**: Call repository method with BigDecimal parameters
- **Parameter conversion**: Use BigDecimal.valueOf() for numeric literals
- **Testing values**: Use appropriate price range for testing
- **Result handling**: Process returned list of products

```java
@Service
public class UserService {
    
    public void fetchProducts() {
        var products = productRepository.findProducts(
            BigDecimal.valueOf(1),   // minPrice
            BigDecimal.valueOf(15)   // maxPrice
        );
        
        products.forEach(System.out::println);
    }
}
```

![Service Method Implementation](assets/service-method-implementation.png)

## Transaction Requirements

- **Transaction context**: Stored procedure calls require transaction
- **@Transactional annotation**: Add to service method calling procedure
- **Exception prevention**: Avoid "Invalid data access API usage exception"
- **Import requirement**: Import from Spring transaction package

```java
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
    
    @Transactional  // Required for stored procedure calls
    public void fetchProducts() {
        var products = productRepository.findProducts(
            BigDecimal.valueOf(1),
            BigDecimal.valueOf(15)
        );
        
        products.forEach(System.out::println);
    }
}
```

![Transaction Requirements](assets/transaction-requirements.png)

## Testing the Integration

- **Main method**: Call service method from main application class
- **Application execution**: Run Spring Boot application to test
- **Exception handling**: Handle transaction-related exceptions
- **Result observation**: Verify stored procedure execution

```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        var context = SpringApplication.run(StoreApplication.class, args);
        var service = context.getBean(UserService.class);
        service.fetchProducts();  // Test stored procedure call
    }
}
```

![Testing Integration](assets/testing-integration.png)

**Error without @Transactional:**
```
Invalid data access API usage exception: 
You're trying to execute a procedure method without a surrounding transaction
```

![Transaction Exception Error](assets/transaction-exception-error.png)

## Generated SQL Analysis

- **Procedure call**: Hibernate generates CALL statement for stored procedure
- **Additional queries**: Related entity queries (categories) executed separately
- **Eager loading**: Category relationships loaded due to fetch strategy
- **Performance observation**: Monitor total query count and execution time

![Generated SQL Analysis](assets/generated-sql-analysis.png)

**SQL execution pattern:**
```sql
-- Main stored procedure call
CALL FindProductsByPrice(?, ?);

-- Additional eager loading queries
SELECT c.* FROM categories c WHERE c.id = ?;
```

![SQL Execution Pattern](assets/sql-execution-pattern.png)

**Query analysis:**
- **Stored procedure**: Single CALL statement with parameters
- **Category queries**: Separate queries for eager-loaded relationships
- **Parameter binding**: Hibernate handles parameter substitution
- **Result mapping**: Procedure results mapped to Product entities

## Key Points

- **Main takeaway**: Stored procedures move complex SQL logic into the database and can be called from Spring repositories using @Procedure annotation
- **Database-specific syntax**: Stored procedure creation syntax varies by database engine (MySQL, PostgreSQL, SQL Server, etc.)
- **Delimiter management**: Change MySQL delimiter temporarily during procedure creation to handle internal semicolons
- **Migration approach**: Use Flyway migrations to create stored procedures as part of database schema evolution
- **Repository integration**: Replace @Query with @Procedure annotation and specify procedure name as parameter
- **Transaction requirement**: Stored procedure calls must be executed within @Transactional context to avoid exceptions
- **Parameter simplification**: @Procedure eliminates need for @Param annotations since parameters are passed by position
- **Performance benefits**: Pre-compiled execution plans and reduced network traffic for complex queries
- **Column selection**: Always specify explicit columns in procedures instead of SELECT * for security and performance
- **Testing workflow**: Test procedures directly in database console before integrating with application code

## Links/References

- Video: 4.9.6-Calling-Stored-Procedures.mp4 (08:50)
- Previous: [Avoiding the N+1 Problem](4.9.5-Avoiding-the-N-1-Problem.md)
- Next: Building Dynamic Queries with Specifications
- Reference: [Spring Data JPA Stored Procedures](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.stored-procedures)
- Reference: [MySQL Stored Procedures](https://dev.mysql.com/doc/refman/8.0/en/stored-programs.html)
- Reference: [Flyway Database Migrations](https://flywaydb.org/documentation/concepts/migrations)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

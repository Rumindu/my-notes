# Derived Query Methods

<!-- omit from toc -->

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Derived Query Methods Overview](#derived-query-methods-overview)
- [Built-in Repository Methods](#built-in-repository-methods)
- [Creating Custom Query Methods](#creating-custom-query-methods)
- [String Field Query Conventions](#string-field-query-conventions)
- [Case-Insensitive String Queries](#case-insensitive-string-queries)
- [Numeric Field Query Conventions](#numeric-field-query-conventions)
- [Null Checking Conventions](#null-checking-conventions)
- [Combining Conditions with Logical Operators](#combining-conditions-with-logical-operators)
- [Sorting Results](#sorting-results)
- [Limiting Results](#limiting-results)
- [Derived Query Method Limitations](#derived-query-method-limitations)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Derived Query Methods Overview

- **Custom queries**: Need to find data by specific criteria beyond basic CRUD operations
- **Naming conventions**: Spring generates SQL queries automatically based on method names
- **Runtime generation**: SQL statements created dynamically when application starts
- **No implementation needed**: Just define method signatures following conventions

![Derived Query Methods Overview](assets/derived-query-methods-overview.png)

**Common use cases:**
- **Category filtering**: Find products in specific category
- **Name searching**: Filter products by name patterns
- **Price ranges**: Find products within price limits
- **Custom business logic**: Any field-based filtering requirements

## Built-in Repository Methods

- **Standard CRUD operations**: Repository interfaces provide basic data access methods
- **findById()**: Retrieve single entity by primary key
- **existsById()**: Check if entity exists (returns boolean)
- **findAll()**: Retrieve all entities of given type
- **findAllById()**: Retrieve multiple entities by ID collection
- **count()**: Get total number of entities

```java
// Built-in repository methods
public interface ProductRepository extends CrudRepository<Product, Long> {
    // These methods are automatically available:
    // Optional<Product> findById(Long id)
    // boolean existsById(Long id)
    // Iterable<Product> findAll()
    // Iterable<Product> findAllById(Iterable<Long> ids)
    // long count()
}
```

![Built-in Repository Methods Interface](assets/builtin-repository-methods-interface.png)

## Creating Custom Query Methods

- **Method signature**: Define method in repository interface
- **Naming convention**: Start with `findBy` followed by field name
- **Automatic implementation**: Spring generates SQL query based on method name
- **Parameter binding**: Method parameters automatically mapped to query conditions

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Basic find by field
    List<Product> findByName(String name);
    // Generates: SELECT * FROM products WHERE name = ?
    
    List<Product> findByCategory(String category);
    // Generates: SELECT * FROM products WHERE category = ?
    
    List<Product> findByDescription(String description);
    // Generates: SELECT * FROM products WHERE description = ?
}
```

![Custom Query Method Creation](assets/custom-query-method-creation.png)

**Method naming rules:**
- **findBy prefix**: Required starting keyword for query methods
- **Field name**: Exact property name from entity class
- **Return type**: List<Entity>, Optional<Entity>, or Entity
- **Parameters**: Match the fields being queried

## String Field Query Conventions

- **Exact matching**: Default behavior with equals operator
- **Pattern matching**: Use `Like` keyword for SQL LIKE operator
- **Substring search**: `Containing` or `Contains` for partial matches
- **Prefix matching**: `StartingWith` or `StartsWith` for beginning matches
- **Suffix matching**: `EndingWith` for ending matches

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Exact match (default)
    List<Product> findByName(String name);
    // WHERE name = ?
    
    // Pattern matching with LIKE
    List<Product> findByNameLike(String pattern);
    // WHERE name LIKE ?
    
    // Contains substring
    List<Product> findByNameContaining(String keyword);
    List<Product> findByNameContains(String keyword);
    // WHERE name LIKE %keyword%
    
    // Starts with pattern
    List<Product> findByNameStartingWith(String prefix);
    List<Product> findByNameStartsWith(String prefix);
    // WHERE name LIKE prefix%
    
    // Ends with pattern
    List<Product> findByNameEndingWith(String suffix);
    // WHERE name LIKE %suffix
}
```

![String Query Conventions Examples](assets/string-query-conventions-examples.png)

## Case-Insensitive String Queries

- **Case sensitivity**: Default string comparisons are case-sensitive
- **IgnoreCase keyword**: Add to method name for case-insensitive queries
- **All string conventions**: Works with Like, Contains, StartsWith, etc.
- **SQL UPPER/LOWER**: Hibernate generates appropriate case conversion

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Case-sensitive (default)
    List<Product> findByNameContaining(String keyword);
    
    // Case-insensitive
    List<Product> findByNameContainingIgnoreCase(String keyword);
    List<Product> findByNameLikeIgnoreCase(String pattern);
    List<Product> findByNameStartingWithIgnoreCase(String prefix);
    List<Product> findByNameEndingWithIgnoreCase(String suffix);
}
```

![Case Insensitive Query Examples](assets/case-insensitive-query-examples.png)

## Numeric Field Query Conventions

- **Exact comparison**: Default equals operator for numeric fields
- **Range comparisons**: Greater than, less than, between operators
- **Boundary conditions**: Greater/less than or equal variations
- **Multiple parameters**: Between requires min and max parameters

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Exact numeric match
    List<Product> findByPrice(BigDecimal price);
    // WHERE price = ?
    
    // Greater than comparisons
    List<Product> findByPriceGreaterThan(BigDecimal price);
    // WHERE price > ?
    
    List<Product> findByPriceGreaterThanEqual(BigDecimal price);
    // WHERE price >= ?
    
    // Less than comparisons
    List<Product> findByPriceLessThan(BigDecimal price);
    // WHERE price < ?
    
    List<Product> findByPriceLessThanEqual(BigDecimal price);
    // WHERE price <= ?
    
    // Range queries
    List<Product> findByPriceBetween(BigDecimal min, BigDecimal max);
    // WHERE price BETWEEN ? AND ?
}
```

![Numeric Query Conventions Examples](assets/numeric-query-conventions-examples.png)

## Null Checking Conventions

- **Null values**: Handle nullable database columns
- **IsNull keyword**: Find records where field is null
- **IsNotNull keyword**: Find records where field has value
- **Database NULL**: Direct SQL NULL comparison

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Find records with null description
    List<Product> findByDescriptionIsNull();
    // WHERE description IS NULL
    
    // Find records with non-null description
    List<Product> findByDescriptionIsNotNull();
    // WHERE description IS NOT NULL
}
```

![Null Checking Query Examples](assets/null-checking-query-examples.png)

## Combining Conditions with Logical Operators

- **Multiple conditions**: Combine different field criteria
- **AND operator**: All conditions must be true
- **OR operator**: At least one condition must be true
- **Complex queries**: Chain multiple logical operators

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // AND operator - both conditions must be true
    List<Product> findByNameAndCategory(String name, String category);
    // WHERE name = ? AND category = ?
    
    List<Product> findByPriceGreaterThanAndDescriptionIsNotNull(BigDecimal price);
    // WHERE price > ? AND description IS NOT NULL
    
    // OR operator - either condition can be true
    List<Product> findByNameOrCategory(String name, String category);
    // WHERE name = ? OR category = ?
}
```

![Logical Operators Query Examples](assets/logical-operators-query-examples.png)

## Sorting Results

- **OrderBy keyword**: Add sorting to query methods
- **Field specification**: Specify which field to sort by
- **Sort direction**: Optional Asc (ascending) or Desc (descending)
- **Default order**: Ascending if direction not specified

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Sort by name (ascending by default)
    List<Product> findByNameOrderByName(String name);
    // WHERE name = ? ORDER BY name ASC
    
    // Sort by price ascending
    List<Product> findByNameOrderByPriceAsc(String name);
    // WHERE name = ? ORDER BY price ASC
    
    // Sort by price descending
    List<Product> findByNameOrderByPriceDesc(String name);
    // WHERE name = ? ORDER BY price DESC
    
    // Multiple sort fields
    List<Product> findByNameOrderByPriceAscNameDesc(String name);
    // WHERE name = ? ORDER BY price ASC, name DESC
}
```

![Sorting Query Examples](assets/sorting-query-examples.png)

## Limiting Results

- **Top keyword**: Limit number of results returned
- **First keyword**: Alternative to Top (same functionality)
- **Numeric limit**: Hardcoded in method name
- **Combined with sorting**: Get top N results after ordering

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Get top 5 products by name
    List<Product> findTop5ByName(String name);
    // WHERE name = ? LIMIT 5
    
    // Get first 5 products by name, sorted by price
    List<Product> findTop5ByNameOrderByPrice(String name);
    // WHERE name = ? ORDER BY price ASC LIMIT 5
    
    // Alternative syntax with First
    List<Product> findFirst5ByNameOrderByPriceDesc(String name);
    // WHERE name = ? ORDER BY price DESC LIMIT 5
    
    // Get single result (top 1)
    Optional<Product> findFirstByNameOrderByPriceAsc(String name);
    // WHERE name = ? ORDER BY price ASC LIMIT 1
}
```

![Limiting Results Query Examples](assets/limiting-results-query-examples.png)

## Derived Query Method Limitations

- **Hardcoded limits**: Cannot change limit values dynamically at runtime
- **Static method names**: All query criteria fixed in method signature
- **Complex queries**: Difficult to express complex business logic
- **Performance concerns**: Generated queries may not be optimized
- **Alternative solutions**: Custom @Query annotations or Criteria API for flexibility

![Derived Query Limitations Diagram](assets/derived-query-limitations-diagram.png)

**Limitation examples:**
- **Dynamic limits**: Cannot change `findTop5By...` to `findTop10By...` at runtime
- **Conditional criteria**: Cannot optionally include/exclude WHERE conditions
- **Complex joins**: Multi-table queries become unwieldy with naming conventions
- **Advanced SQL**: Cannot use database-specific functions or advanced SQL features

## Key Points

- **Main takeaway**: Derived query methods use naming conventions to automatically generate SQL queries without writing implementation code
- **Naming patterns**: Start with `findBy` followed by field names and optional keywords (Like, Contains, GreaterThan, etc.)
- **String operations**: Support exact match, pattern matching (Like), substring search (Contains), prefix/suffix matching with optional case-insensitive variants
- **Numeric comparisons**: Handle exact matches, range queries (GreaterThan, LessThan, Between), and boundary conditions
- **Null handling**: Use IsNull and IsNotNull keywords for nullable column queries
- **Logical operators**: Combine multiple conditions with And/Or operators in method names
- **Sorting capability**: Add OrderBy with field names and optional Asc/Desc direction specifiers
- **Result limiting**: Use Top or First keywords with numeric values to limit query results
- **Automatic implementation**: Spring Data JPA generates complete method implementations at runtime based on method signatures
- **Static limitations**: Hardcoded limits and criteria in method names prevent dynamic runtime changes - consider @Query or Criteria API for complex scenarios

## Links/References

- Video: 4.9.1-Derived-Query-Methods.mp4 (05:24)
- Previous: [Creating Repositories](4.8.0-Creating-Repositories.md)
- Next: Custom Query Methods with @Query
- Reference: [Spring Data JPA Query Methods](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods)
- Reference: [Repository Query Keywords](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

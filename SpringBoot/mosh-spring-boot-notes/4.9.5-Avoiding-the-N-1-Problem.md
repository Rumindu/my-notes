# Avoiding the N+1 Problem

<!-- omit from toc -->

## Table of Contents

- [N+1 Problem Overview](#n1-problem-overview)
- [Lazy Loading Benefits and Drawbacks](#lazy-loading-benefits-and-drawbacks)
- [Creating Test Scenario](#creating-test-scenario)
- [Demonstrating the N+1 Problem](#demonstrating-the-n1-problem)
- [Analyzing Initial Query Results](#analyzing-initial-query-results)
- [Profile Relationship Optimization](#profile-relationship-optimization)
- [Understanding N+1 Query Pattern](#understanding-n1-query-pattern)
- [N+1 Problem Scale Impact](#n1-problem-scale-impact)
- [Solution Options Overview](#solution-options-overview)
- [Entity Graph Solution Implementation](#entity-graph-solution-implementation)
- [Custom Query Method Requirements](#custom-query-method-requirements)
- [JPQL Query with Entity Graph](#jpql-query-with-entity-graph)
- [Testing the Solution](#testing-the-solution)
- [Performance Comparison](#performance-comparison)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## N+1 Problem Overview

- **Performance issue**: Common problem with lazy loading in ORM frameworks
- **Query multiplication**: One initial query followed by N additional queries
- **Lazy loading trigger**: Accessing related entities causes separate database queries
- **Scalability concern**: Problem becomes severe with large datasets

![N+1 Problem Overview](assets/n-plus-1-problem-overview.png)

**N+1 Problem formula:**
- **1 query**: Initial query to fetch parent entities
- **N queries**: One additional query for each parent entity's relationships
- **Total**: N+1 database round trips instead of 1 optimized query
- **Performance impact**: Exponential increase in database load

## Lazy Loading Benefits and Drawbacks

- **Benefits**: Prevents loading unnecessary data, improves memory usage
- **Performance gain**: Faster initial queries when relationships not needed
- **Drawbacks**: N+1 problem when relationships are accessed
- **Trade-off**: Memory efficiency vs query efficiency

![Lazy Loading Benefits Drawbacks](assets/lazy-loading-benefits-drawbacks.png)

**When lazy loading works well:**
- **Selective access**: Only some entities need related data
- **Memory constraints**: Large datasets where full loading is impractical
- **API endpoints**: Different endpoints need different levels of data

**When lazy loading causes problems:**
- **Bulk operations**: Processing all entities and their relationships
- **Reporting queries**: Need complete data for analysis
- **UI display**: Showing lists with related entity information

## Creating Test Scenario

- **Method rename**: Change method to process multiple users
- **Bulk operation**: Fetch all users and display with addresses
- **Iteration pattern**: Loop through users and access lazy relationships
- **Test setup**: Create scenario that triggers N+1 problem

```java
@Service
public class UserService {
    
    public void fetchUsers() {  // Renamed from fetchUser
        // Fetch all users from database
        var users = userRepository.findAll();
        
        // Iterate and access lazy relationships
        users.forEach(user -> {
            System.out.println(user);  // Print user info
            user.getAddresses().forEach(System.out::println);  // Trigger lazy loading
        });
    }
}
```

![Test Scenario Creation](assets/test-scenario-creation.png)

## Demonstrating the N+1 Problem

- **Initial query**: Single query to fetch all users
- **Lazy loading trigger**: Accessing addresses for each user
- **Multiple queries**: One query per user for their addresses
- **Observable pattern**: Easy to see in SQL query logs

![Demonstrating N+1 Problem](assets/demonstrating-n-plus-1-problem.png)

**Query execution pattern:**
1. **Initial query**: `SELECT * FROM users`
2. **First user addresses**: `SELECT * FROM addresses WHERE user_id = 1`
3. **Second user addresses**: `SELECT * FROM addresses WHERE user_id = 2`
4. **Pattern continues**: One query per user in the result set

## Analyzing Initial Query Results

- **Multiple query types**: User queries, profile queries, address queries
- **Profile relationship queries**: Additional queries for user-profile relationships
- **Query optimization**: Some relationships handled with separate SELECT statements
- **JOIN vs separate queries**: Hibernate chooses query strategy based on relationships

![Initial Query Results Analysis](assets/initial-query-results-analysis.png)

**Query breakdown:**
- **User selection**: Main query to fetch all users
- **Profile queries**: Multiple queries for user profiles (one-to-one relationship)
- **Address queries**: Lazy loading queries triggered by access
- **Total queries**: 1 + N (profiles) + N (addresses) = 1 + 2N queries

## Profile Relationship Optimization

- **Relationship evaluation**: Assess necessity of user-profile relationship
- **Authentication context**: User accounts typically don't need profile details
- **Field removal**: Remove profile relationship to eliminate unnecessary queries
- **Performance improvement**: Reduce query overhead for authentication scenarios

```java
@Entity
public class User {
    private Long id;
    private String name;
    private String email;
    
    // Remove profile relationship for authentication use cases
    // @OneToOne
    // private Profile profile;  // Removed to eliminate extra queries
    
    @OneToMany(mappedBy = "user")
    private List<Address> addresses = new ArrayList<>();
}
```

![Profile Relationship Optimization](assets/profile-relationship-optimization.png)

## Understanding N+1 Query Pattern

- **Pattern identification**: Clear sequence of database queries
- **User iteration**: Each user access triggers address query
- **Query timing**: Queries executed when lazy relationship accessed
- **Performance degradation**: Linear increase in queries with data size

![N+1 Query Pattern Understanding](assets/n-plus-1-query-pattern.png)

**Query sequence example:**
```sql
-- Initial query (1)
SELECT * FROM users;

-- Address queries (N)
SELECT * FROM addresses WHERE user_id = 1;
SELECT * FROM addresses WHERE user_id = 2;
SELECT * FROM addresses WHERE user_id = 3;
-- ... continues for each user
```

![Query Sequence Example](assets/query-sequence-example.png)

## N+1 Problem Scale Impact

- **Small scale**: Few users, manageable query overhead
- **Large scale**: Million users = 1,000,001 database queries
- **Performance degradation**: Database connection exhaustion, slow response times
- **Scalability blocker**: Prevents application from handling large datasets efficiently

![N+1 Problem Scale Impact](assets/n-plus-1-problem-scale-impact.png)

**Scale comparison:**
- **10 users**: 11 queries (acceptable)
- **1,000 users**: 1,001 queries (concerning)
- **1,000,000 users**: 1,000,001 queries (catastrophic)
- **Database impact**: Connection pool exhaustion, query queue buildup

## Solution Options Overview

- **Eager loading**: Set fetch = FetchType.EAGER globally
- **Entity graph**: Selective eager loading for specific queries
- **Custom queries**: Write optimized JPQL/SQL with JOINs
- **Batch fetching**: Load relationships in batches

![Solution Options Overview](assets/solution-options-overview.png)

**Solution comparison:**
- **Eager loading**: Simple but affects all queries globally
- **Entity graph**: Targeted solution for specific use cases
- **Custom queries**: Full control but more complex
- **Batch fetching**: Good compromise but requires configuration

## Entity Graph Solution Implementation

- **Repository method**: Create method with entity graph annotation
- **Attribute paths**: Specify relationships to eagerly load
- **Method naming**: Use descriptive names for clarity
- **Selective loading**: Apply only to queries that need relationships

```java
public interface UserRepository extends CrudRepository<User, Long> {
    
    @EntityGraph(attributePaths = {"addresses"})
    List<User> findAllWithAddresses();
    
    // Alternative with more explicit naming
    @EntityGraph(attributePaths = {"addresses"})
    List<User> findAllUsersWithAddresses();
}
```

![Entity Graph Solution Implementation](assets/entity-graph-solution-implementation.png)

## Custom Query Method Requirements

- **Naming convention**: Method names must follow Spring Data patterns
- **Custom query annotation**: Use @Query for non-standard method names
- **JPQL requirement**: Provide explicit query when conventions don't apply
- **Exception handling**: UnsatisfiedDependencyException for invalid method names

```java
public interface UserRepository extends CrudRepository<User, Long> {
    
    // This breaks convention and requires @Query
    @Query("SELECT u FROM User u")
    @EntityGraph(attributePaths = {"addresses"})
    List<User> findAllWithAddresses();
}
```

![Custom Query Method Requirements](assets/custom-query-method-requirements.png)

**Exception details:**
```
UnsatisfiedDependencyException: No property 'findAllWithAddresses' found for type User
```

## JPQL Query with Entity Graph

- **Simple JPQL**: Basic query to select all users
- **Entity graph handling**: Framework handles JOIN operations automatically
- **No explicit JOINs**: Entity graph annotation manages relationship loading
- **Clean syntax**: Minimal query code with maximum functionality

```java
@Query("SELECT u FROM User u")
@EntityGraph(attributePaths = {"addresses"})
List<User> findAllWithAddresses();
```

![JPQL Query with Entity Graph](assets/jpql-query-entity-graph.png)

**Why no explicit JOIN needed:**
- **Automatic handling**: @EntityGraph tells Hibernate to JOIN automatically
- **Query simplicity**: Just select the main entity
- **Framework optimization**: Hibernate generates optimal JOIN query
- **Developer convenience**: Less code, same performance benefit

## Testing the Solution

- **Service method update**: Change repository call to use entity graph method
- **Query execution**: Observe single optimized query generation
- **Performance verification**: Confirm elimination of N+1 queries
- **Result validation**: Ensure all data still accessible

```java
@Service
public class UserService {
    
    public void fetchUsers() {
        // Use entity graph method to avoid N+1 problem
        var users = userRepository.findAllWithAddresses();
        
        users.forEach(user -> {
            System.out.println(user);
            user.getAddresses().forEach(System.out::println);  // No additional queries
        });
    }
}
```

![Testing the Solution](assets/testing-the-solution.png)

## Performance Comparison

- **Before optimization**: 1 + N queries (N+1 problem)
- **After optimization**: Single query with JOINs
- **Query structure**: LEFT JOIN to fetch users and addresses together
- **Performance gain**: Significant reduction in database round trips

![Performance Comparison](assets/performance-comparison.png)

**Optimized query structure:**
```sql
-- Single optimized query with entity graph
SELECT u.*, a.* 
FROM users u 
LEFT JOIN addresses a ON u.id = a.user_id;
```

![Optimized Query Structure](assets/optimized-query-structure.png)

**Performance metrics:**
- **Database round trips**: N+1 â†’ 1 (massive reduction)
- **Network overhead**: Eliminated multiple request/response cycles
- **Connection usage**: Single connection vs N+1 connections
- **Query execution time**: Single query vs multiple sequential queries

## Key Points

- **Main takeaway**: N+1 problem occurs when lazy loading triggers one database query per entity to fetch related data, resulting in N+1 total queries instead of 1 optimized query
- **Problem identification**: Watch for patterns where initial query fetches N entities, followed by N additional queries to load relationships for each entity
- **Scale impact**: Problem becomes catastrophic with large datasets - 1 million users would generate 1,000,001 database queries
- **Entity graph solution**: Use @EntityGraph annotation to selectively eager load relationships for specific repository methods without affecting global fetch strategy
- **Custom query requirement**: Non-standard method names need @Query annotation even with @EntityGraph to provide explicit JPQL
- **Performance optimization**: Single JOIN query replaces N+1 separate queries, dramatically reducing database round trips and connection usage
- **Relationship evaluation**: Consider removing unnecessary relationships (like user-profile for authentication) to eliminate query overhead
- **Selective optimization**: Apply entity graph only to methods that need related data, keeping other queries efficient with lazy loading
- **Query simplicity**: Entity graph handles JOIN operations automatically - just write simple JPQL to select main entity
- **Best practice**: Monitor query patterns in development to identify and prevent N+1 problems before they reach production

## Links/References

- Video: 4.9.5-Avoiding-the-N-1-Problem.mp4 (05:21)
- Previous: [Efficiently Loading Entities with @EntityGraph](4.9.4-Efficiently-Loading-Entities-with-_EntityGraph.md)
- Next: Building Dynamic Queries
- Reference: [N+1 Query Problem](https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping)
- Reference: [Hibernate N+1 Problem](https://docs.jboss.org/hibernate/orm/5.6/userguide/html_single/Hibernate_User_Guide.html#fetching-strategies-dynamic-fetching-entity-graph)
- Reference: [Spring Data JPA Performance](https://www.baeldung.com/spring-data-jpa-query-by-example)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

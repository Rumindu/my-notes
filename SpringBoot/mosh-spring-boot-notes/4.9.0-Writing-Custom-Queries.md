# Writing Custom Queries

<!-- omit from toc -->

## Table of Contents

- [Custom Queries Introduction](#custom-queries-introduction)
- [Derived Query Methods Overview](#derived-query-methods-overview)
- [Query Annotation Approach](#query-annotation-approach)
- [Projections for Selective Data Fetching](#projections-for-selective-data-fetching)
- [Entity Graph for Load Optimization](#entity-graph-for-load-optimization)
- [N+1 Problem and Solutions](#n1-problem-and-solutions)
- [Stored Procedures Integration](#stored-procedures-integration)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Custom Queries Introduction

- **Section overview**: Comprehensive exploration of custom query writing techniques
- **Multiple approaches**: Various methods for creating flexible database queries
- **Performance focus**: Techniques for optimizing query execution and data loading
- **Practical application**: Real-world solutions for common querying challenges

![Custom Queries Section Introduction](assets/custom-queries-section-introduction.png)

**Learning objectives:**
- **Query methods**: Master derived query method naming conventions
- **Custom queries**: Write flexible queries using @Query annotation
- **Data optimization**: Use projections and entity graphs for performance
- **Problem solving**: Address N+1 problem and integrate stored procedures

## Derived Query Methods Overview

- **Convention-based**: Create queries by following specific naming patterns
- **No implementation**: Spring Data JPA generates implementation automatically
- **Method names**: Query logic derived from method name structure
- **Type safety**: Compile-time validation of query method signatures

![Derived Query Methods Concept](assets/derived-query-methods-concept.png)

**Key characteristics:**
- **Naming convention**: Method names follow specific patterns (findBy, countBy, deleteBy)
- **Property navigation**: Navigate entity relationships using property names
- **Query generation**: Framework automatically generates SQL based on method names
- **IDE support**: IntelliJ and other IDEs provide autocomplete for method names

**Common derived query examples:**
```java
// Examples of derived query method naming patterns
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Find by single property
    List<User> findByName(String name);
    
    // Find by multiple properties
    List<User> findByNameAndEmail(String name, String email);
    
    // Find with ordering
    List<User> findByNameOrderByEmailAsc(String name);
    
    // Count operations
    long countByName(String name);
    
    // Existence checks
    boolean existsByEmail(String email);
}
```

![Derived Query Method Examples](assets/derived-query-method-examples.png)

## Query Annotation Approach

- **@Query annotation**: Write custom JPQL or native SQL queries
- **Greater flexibility**: Handle complex queries beyond naming convention limits
- **Explicit control**: Specify exact query logic and structure
- **Parameter binding**: Use named or positional parameters in queries

![Query Annotation Flexibility](assets/query-annotation-flexibility.png)

**@Query annotation benefits:**
- **Complex queries**: Handle joins, subqueries, and advanced SQL features
- **Performance tuning**: Write optimized queries for specific use cases
- **Native SQL support**: Use database-specific features when needed
- **Custom projections**: Return specific fields or calculated values

**Query annotation examples:**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // JPQL query with named parameter
    @Query("SELECT u FROM User u WHERE u.name = :name")
    List<User> findUsersByName(@Param("name") String name);
    
    // Native SQL query
    @Query(value = "SELECT * FROM users WHERE email LIKE %:domain%", 
           nativeQuery = true)
    List<User> findUsersByEmailDomain(@Param("domain") String domain);
    
    // Custom projection query
    @Query("SELECT u.name, u.email FROM User u WHERE u.active = true")
    List<UserProjection> findActiveUserProjections();
}
```

![Query Annotation Examples Code](assets/query-annotation-examples-code.png)

## Projections for Selective Data Fetching

- **Selective loading**: Fetch only required fields instead of entire entities
- **Performance improvement**: Reduce memory usage and network transfer
- **Multiple types**: Interface-based, class-based, and dynamic projections
- **Query optimization**: Generate more efficient SQL statements

![Projections Performance Benefits](assets/projections-performance-benefits.png)

**Projection advantages:**
- **Reduced overhead**: Load only necessary data from database
- **Network efficiency**: Transfer smaller result sets over network
- **Memory optimization**: Consume less application memory
- **Query performance**: Faster execution with fewer columns selected

**Projection types:**
```java
// Interface-based projection
public interface UserSummary {
    String getName();
    String getEmail();
    LocalDateTime getCreatedAt();
}

// Class-based projection (DTO)
public class UserDto {
    private String name;
    private String email;
    
    public UserDto(String name, String email) {
        this.name = name;
        this.email = email;
    }
    // Getters and setters
}

// Dynamic projection usage
public interface UserRepository extends JpaRepository<User, Long> {
    <T> List<T> findByActive(boolean active, Class<T> type);
}
```

![Projection Types Implementation](assets/projection-types-implementation.png)

## Entity Graph for Load Optimization

- **Powerful optimization tool**: Control entity loading strategies at query level
- **Fetch strategy override**: Temporarily override lazy/eager loading defaults
- **Graph definition**: Specify which relationships to load in single query
- **Performance tuning**: Reduce number of database queries executed

![Entity Graph Loading Optimization](assets/entity-graph-loading-optimization.png)

**Entity graph benefits:**
- **Query reduction**: Load related entities in single database call
- **Flexible loading**: Override default fetch strategies per query
- **Performance control**: Fine-tune data loading for specific use cases
- **N+1 prevention**: Eliminate multiple queries for related entities

**Entity graph implementation:**
```java
// Define named entity graph
@Entity
@NamedEntityGraph(
    name = "User.addresses", 
    attributeNodes = @NamedAttributeNode("addresses")
)
public class User {
    // Entity fields
}

// Use entity graph in repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @EntityGraph("User.addresses")
    List<User> findByActive(boolean active);
    
    // Ad-hoc entity graph
    @EntityGraph(attributePaths = {"addresses", "orders"})
    Optional<User> findById(Long id);
}
```

![Entity Graph Implementation Code](assets/entity-graph-implementation-code.png)

## N+1 Problem and Solutions

- **Common performance issue**: Single query followed by N additional queries
- **Lazy loading cause**: Accessing related entities triggers individual queries
- **Performance impact**: Exponential increase in database calls
- **Solution strategies**: Entity graphs, fetch joins, batch fetching

![N Plus One Problem Illustration](assets/n-plus-one-problem-illustration.png)

**N+1 problem scenario:**
```java
// This code can cause N+1 problem
List<User> users = userRepository.findAll();  // 1 query
for (User user : users) {
    user.getAddresses().size();               // N additional queries
}
```

**Solution approaches:**
- **Entity graphs**: Load related entities in single query
- **JOIN FETCH**: Use JPQL with explicit joins
- **Batch fetching**: Configure Hibernate batch size
- **Projection usage**: Avoid loading relationships when not needed

![N Plus One Problem Solutions](assets/n-plus-one-problem-solutions.png)

## Stored Procedures Integration

- **Database procedures**: Call existing stored procedures from repositories
- **Legacy integration**: Work with existing database logic and procedures
- **Complex operations**: Handle business logic implemented in database
- **Parameter mapping**: Pass parameters and receive results from procedures

![Stored Procedures Integration](assets/stored-procedures-integration.png)

**Stored procedure benefits:**
- **Legacy support**: Integrate with existing database procedures
- **Performance**: Leverage database-optimized logic
- **Complex operations**: Handle multi-step database operations
- **Centralized logic**: Keep business logic in database layer

**Stored procedure usage:**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Call stored procedure
    @Procedure("update_user_statistics")
    void updateUserStatistics(@Param("user_id") Long userId);
    
    // Call function with return value
    @Procedure(procedureName = "calculate_user_score")
    Integer calculateUserScore(@Param("user_id") Long userId);
    
    // Named stored procedure
    @NamedStoredProcedureQuery(
        name = "User.updateStatus",
        procedureName = "update_user_status",
        parameters = {
            @StoredProcedureParameter(mode = ParameterMode.IN, name = "user_id", type = Long.class),
            @StoredProcedureParameter(mode = ParameterMode.IN, name = "status", type = String.class)
        }
    )
    void updateUserStatus(Long userId, String status);
}
```

![Stored Procedure Usage Examples](assets/stored-procedure-usage-examples.png)

## Key Points

- **Main takeaway**: Multiple approaches available for writing custom queries, each suited for different scenarios and complexity levels
- **Derived queries**: Use naming conventions for simple queries - Spring Data JPA automatically generates implementation based on method names
- **@Query annotation**: Provides maximum flexibility for complex queries using JPQL or native SQL when naming conventions aren't sufficient
- **Projections**: Load only required data fields instead of entire entities to improve performance and reduce memory usage
- **Entity graphs**: Powerful tool for optimizing entity loading by controlling which relationships to fetch in single query
- **N+1 problem**: Common performance issue with lazy loading that can be solved using entity graphs, fetch joins, or batch fetching
- **Stored procedures**: Integrate with existing database procedures for legacy support and complex database operations
- **Performance focus**: All techniques aim to create efficient, flexible, and optimized queries for better application performance
- **Strategy selection**: Choose appropriate querying strategy based on complexity, performance requirements, and existing infrastructure
- **Combination approach**: Often best to combine multiple techniques (projections + entity graphs, derived queries + @Query) for optimal results

## Links/References

- Video: 4.9.0-Writing-Custom-Queries.mp4 (00:57)
- Previous: [Exercise: Managing Products and Wishlists](4.8.9-Exercise-Managing-Products-and-Wishlists.md)
- Next: Derived Query Methods
- Reference: [Spring Data JPA Query Methods](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods)
- Reference: [JPA Entity Graphs](https://docs.oracle.com/javaee/7/tutorial/persistence-entitygraphs.htm)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

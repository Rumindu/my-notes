# Exercise: Understanding Fetching Strategies

<!-- omit from toc -->

## Table of Contents

- [Exercise Overview](#exercise-overview)
- [Problem Description](#problem-description)
- [Creating the Fetch Method](#creating-the-fetch-method)
- [IntelliJ Shortcut for Field Declaration](#intellij-shortcut-for-field-declaration)
- [Database Cleanup and Migration](#database-cleanup-and-migration)
- [Setting Up Test Data](#setting-up-test-data)
- [Running the Initial Test](#running-the-initial-test)
- [Analyzing Eager Loading Queries](#analyzing-eager-loading-queries)
- [Understanding the Query Chain](#understanding-the-query-chain)
- [Implementing Lazy Loading Solution](#implementing-lazy-loading-solution)
- [Verifying the Solution](#verifying-the-solution)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Exercise Overview

- **Exercise goal**: Understand fetch strategies by retrieving address and inspecting SQL queries
- **Problem identification**: Notice eager loading of associated user and profile entities
- **Performance impact**: Unnecessary data retrieval when only address information needed
- **Solution approach**: Apply lazy loading to avoid unnecessary queries

![Exercise Overview Diagram](assets/exercise-fetching-strategies-overview.png)

**Exercise requirements:**
- **Address retrieval**: Write code to fetch address by ID
- **SQL inspection**: Observe generated queries in console
- **Performance analysis**: Identify unnecessary eager loading
- **Optimization**: Apply lazy loading where appropriate

## Problem Description

- **Display scenario**: When showing address information, user account details not needed
- **Unnecessary data**: Email, password, and profile information loaded unnecessarily
- **Performance concern**: Multiple table joins for simple address display
- **Optimization opportunity**: Use lazy loading to reduce query complexity

![Problem Description Scenario](assets/problem-description-scenario.png)

**Specific issues:**
- **Address display**: Only need street, city, state, zip information
- **User details**: Email, password not relevant for address display
- **Profile data**: Bio, loyalty points unnecessary for address context
- **Query overhead**: Multiple JOINs increase query complexity and data transfer

## Creating the Fetch Method

- **Service method**: Add fetchAddress method to UserService class
- **Repository usage**: Use AddressRepository to retrieve address by ID
- **Error handling**: Include orElseThrow() for missing address scenarios
- **Method structure**: Follow standard repository access pattern

```java
@Service
public class UserService {
    
    public void fetchAddress() {
        var address = addressRepository.findById(1L)
            .orElseThrow();
        
        // Address retrieved for analysis
    }
}
```

![Fetch Address Method Creation](assets/fetch-address-method-creation.png)

## IntelliJ Shortcut for Field Declaration

- **IDE productivity tip**: Type repository name directly in method without declaring field first
- **Auto-completion**: Press Enter when IntelliJ suggests repository
- **Automatic field creation**: IDE automatically declares field at class level
- **Time saving**: No need to manually navigate to field declarations

![IntelliJ Field Declaration Shortcut](assets/intellij-field-declaration-shortcut.png)

**Shortcut workflow:**
1. **Type repository name**: Start typing in method (e.g., "addressRepository")
2. **Accept suggestion**: Press Enter when IDE shows completion
3. **Automatic field**: IntelliJ creates private field declaration automatically
4. **Constructor injection**: Field added to constructor parameters

![Auto-Generated Repository Field](assets/auto-generated-repository-field.png)

## Database Cleanup and Migration

- **Clean start**: Run Flyway clean to remove all existing tables
- **Migration reset**: Re-run all migrations for fresh database state
- **Maven integration**: Use Maven window for Flyway operations
- **Data consistency**: Ensure clean test environment

![Maven Flyway Clean Operation](assets/maven-flyway-clean-operation.png)

**Cleanup commands:**
```bash
# Via Maven window
flyway:clean    # Remove all tables
flyway:migrate  # Re-run all migrations
```

![Flyway Migration Execution](assets/flyway-migration-execution.png)

**Benefits of cleanup:**
- **Fresh state**: Remove any inconsistent test data
- **Schema validation**: Ensure migrations work correctly
- **Performance baseline**: Clean database for accurate testing
- **Reproducible results**: Consistent starting point for exercise

## Setting Up Test Data

- **User creation**: Add test user with basic information
- **Profile creation**: Create associated profile for user
- **Address creation**: Add address linked to test user
- **Data relationships**: Ensure proper foreign key connections

![Test Data Setup Process](assets/test-data-setup-process.png)

**User record:**
```sql
INSERT INTO users (name, email, password) 
VALUES ('Mosh', 'programming with mosh@gmail.com', '1234');
```

![User Record Creation](assets/user-record-creation.png)

**Profile record:**
```sql
INSERT INTO profiles (user_id, bio) 
VALUES (1, 'bio');
```

![Profile Record Creation](assets/profile-record-creation.png)

**Address record:**
```sql
INSERT INTO addresses (street, city, zip, state, user_id) 
VALUES ('Street', 'City', 'Zip', 'State', 1);
```

![Address Record Creation](assets/address-record-creation.png)

## Running the Initial Test

- **Application execution**: Run Spring Boot application with fetchAddress method
- **Console monitoring**: Observe SQL queries generated by Hibernate
- **Query analysis**: Identify all tables being queried
- **Performance measurement**: Note complexity of generated SQL

```java
// In StoreApplication main method
var service = context.getBean(UserService.class);
service.fetchAddress();
```

![Initial Test Execution](assets/initial-test-execution.png)

## Analyzing Eager Loading Queries

- **Query complexity**: Multiple table joins for single address retrieval
- **Table aliases**: A1 for addresses, U1 for users, P1 for profiles
- **Column selection**: All columns from all related tables retrieved
- **Performance impact**: Unnecessary data transfer and processing

![Eager Loading Query Analysis](assets/eager-loading-query-analysis.png)

**Generated SQL structure:**
```sql
SELECT a1.id, a1.street, a1.city, a1.zip, a1.state, a1.user_id,
       u1.id, u1.email, u1.name, u1.password,
       p1.id, p1.bio, p1.date_of_birth, p1.loyalty_points
FROM addresses a1
LEFT JOIN users u1 ON a1.user_id = u1.id
LEFT JOIN profiles p1 ON u1.id = p1.user_id
WHERE a1.id = ?
```

![Complex Eager Loading SQL](assets/complex-eager-loading-sql.png)

**Query components:**
- **Addresses table**: Primary data source (A1 alias)
- **Users join**: LEFT JOIN to retrieve user information
- **Profiles join**: LEFT JOIN to retrieve profile information
- **All columns**: Every column from all three tables selected

## Understanding the Query Chain

- **Address-User relationship**: Many-to-One triggers eager loading by default
- **User-Profile relationship**: One-to-One triggers eager loading by default
- **Cascading effect**: Loading address cascades to user, then to profile
- **Default behavior**: Spring Data JPA follows relationship annotations

![Query Chain Analysis](assets/query-chain-analysis.png)

**Relationship chain:**
1. **Address retrieved**: Primary target entity
2. **User loaded**: Many-to-One relationship (eager by default)
3. **Profile loaded**: One-to-One relationship (eager by default)
4. **Full cascade**: All related entities loaded automatically

![Relationship Cascade Diagram](assets/relationship-cascade-diagram.png)

**Default fetch strategies:**
- **@ManyToOne**: EAGER loading (single object, minimal overhead)
- **@OneToOne**: EAGER loading (single object, predictable size)
- **Performance assumption**: Single objects won't cause memory issues

## Implementing Lazy Loading Solution

- **Address entity modification**: Change ManyToOne fetch strategy to LAZY
- **Relationship annotation**: Add fetch = FetchType.LAZY parameter
- **Performance optimization**: Prevent unnecessary user and profile loading
- **Selective loading**: Load related entities only when explicitly accessed

```java
@Entity
public class Address {
    
    @ManyToOne(fetch = FetchType.LAZY)  // Change from default EAGER to LAZY
    @JoinColumn(name = "user_id")
    private User user;
    
    // Other fields...
}
```

![Lazy Loading Implementation](assets/lazy-loading-implementation.png)

**Implementation details:**
- **Fetch strategy**: Explicitly set to FetchType.LAZY
- **Relationship preservation**: @JoinColumn annotation remains unchanged
- **Behavioral change**: User entity loaded only when accessed
- **Performance gain**: Eliminates unnecessary JOINs

## Verifying the Solution

- **Re-run application**: Execute same fetchAddress method after lazy loading change
- **SQL comparison**: Compare new queries with previous eager loading queries
- **Performance improvement**: Observe simplified query structure
- **Validation**: Confirm only address table queried

![Solution Verification Process](assets/solution-verification-process.png)

**Optimized SQL result:**
```sql
SELECT a1.id, a1.street, a1.city, a1.zip, a1.state, a1.user_id
FROM addresses a1
WHERE a1.id = ?
-- No JOINs to users or profiles tables
```

![Simplified Lazy Loading SQL](assets/simplified-lazy-loading-sql.png)

**Performance improvements:**
- **Single table query**: Only addresses table accessed
- **Reduced data transfer**: Only address columns retrieved
- **Faster execution**: No complex JOINs required
- **Memory efficiency**: Less data loaded into memory

![Performance Comparison Chart](assets/performance-comparison-chart.png)

## Key Points

- **Main takeaway**: Default eager loading can cause unnecessary data retrieval and performance overhead when displaying entities with relationships
- **Fetch strategy impact**: ManyToOne and OneToOne relationships use eager loading by default, causing cascading data retrieval
- **Performance optimization**: Apply FetchType.LAZY to relationships when related data not immediately needed
- **Query analysis**: Always inspect generated SQL to understand actual database operations and identify optimization opportunities
- **IntelliJ productivity**: Use IDE shortcuts like auto-field declaration to improve development efficiency
- **Database cleanup**: Use Flyway clean and migrate for consistent test environments and reproducible results
- **Relationship cascading**: Loading one entity can trigger loading of multiple related entities through relationship chains
- **Selective loading**: Lazy loading allows loading related entities only when explicitly accessed, improving performance
- **SQL complexity**: Eager loading creates complex queries with multiple JOINs, while lazy loading creates simpler, focused queries
- **Practical consideration**: Choose fetch strategy based on actual usage patterns rather than accepting defaults

## Links/References

- Video: 4.8.6-Exercise-Understanding-Fetching-Strategies.mp4 (04:02)
- Previous: [Fetching Strategies: Eager and Lazy Loading](4.8.5-Fetching-Strategies-Eager-and-Lazy-Loading.md)
- Next: Advanced Query Optimization
- Reference: [JPA Fetch Types](https://docs.oracle.com/javaee/7/api/javax/persistence/FetchType.html)
- Reference: [Hibernate Performance Tuning](https://docs.jboss.org/hibernate/orm/5.6/userguide/html_single/Hibernate_User_Guide.html#fetching)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

# What is Dependency Injection

<!-- omit from toc -->
## Table of Contents

- [Understanding Dependency Injection](#understanding-dependency-injection)
- [Real-World Example: E-commerce Order Service](#real-world-example-e-commerce-order-service)
- [Problems with Tight Coupling](#problems-with-tight-coupling)
- [The Restaurant Analogy](#the-restaurant-analogy)
- [Solution: Using Interfaces for Loose Coupling](#solution-using-interfaces-for-loose-coupling)
- [Benefits of Loose Coupling](#benefits-of-loose-coupling)
- [What is Dependency Injection](#what-is-dependency-injection)
- [Code Implementation](#code-implementation)
  - [Creating the Order Service](#creating-the-order-service)
  - [Creating the Stripe Payment Service](#creating-the-stripe-payment-service)
  - [Tight Coupling Implementation](#tight-coupling-implementation)
  - [Extracting an Interface](#extracting-an-interface)
  - [Interface Structure](#interface-structure)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Understanding Dependency Injection

- **Common misconception**: Many students find dependency injection confusing or complex
- **Reality**: It's actually a very simple concept
- **Definition**: A design pattern where dependencies are provided to a class rather than created within it
- **Purpose**: Reduces tight coupling between classes and improves flexibility

![Dependency Injection Overview Concept](assets/dependency-injection-overview-concept.png)

## Real-World Example: E-commerce Order Service

- **Scenario**: Building an e-commerce application with order processing
- **Components**: Order service handles placing orders, payment service processes payments
- **Dependency relationship**: Order service depends on payment service (like Stripe)
- **Current problem**: Order service is tightly coupled to Stripe payment service

![E-commerce Order Service Architecture](assets/ecommerce-order-service-architecture.png)

## Problems with Tight Coupling

### Problem 1: Limited Flexibility
- **Issue**: Order service can only use Stripe payment service
- **Impact**: Switching to PayPal requires modifying order service code
- **Consequences**: Code must be recompiled and retested
- **Ripple effect**: Changes can impact other classes that depend on order service

### Problem 2: Testing Difficulties
- **Issue**: Cannot test order service in isolation
- **Reason**: Order service is tightly coupled to Stripe payment service
- **Impact**: Testing order service logic requires bringing in payment service dependencies
- **Result**: Unit tests become integration tests

![Problems with Tight Coupling Diagram](assets/tight-coupling-problems-diagram.png)

## The Restaurant Analogy

### Good Dependency (Loose Coupling)
- **Restaurant needs**: A chef (general dependency)
- **Flexibility**: If current chef becomes unavailable, hire another chef
- **Result**: Normal, manageable dependency

### Bad Dependency (Tight Coupling)
- **Restaurant depends on**: John (specific chef)
- **Problem**: If John becomes unavailable, cannot replace him
- **Result**: Restaurant is in trouble - tight coupling

![Restaurant Chef Analogy Diagram](assets/restaurant-chef-analogy.png)

## Solution: Using Interfaces for Loose Coupling

- **Goal**: Order service should depend on payment service interface, not specific implementation
- **Interface role**: Acts as a contract defining capabilities without implementation
- **Flexibility**: Any payment provider (Stripe, PayPal) can implement the interface
- **Result**: Order service doesn't care which specific provider is used

### Interface Benefits
- **Contract definition**: Lists methods/capabilities a class should have
- **No implementation**: Contains no logic or algorithms
- **Provider agnostic**: Order service works with any payment provider that implements interface

![Interface Decoupling Solution](assets/interface-decoupling-solution.png)

## Benefits of Loose Coupling

- **Easy provider switching**: Replace Stripe with PayPal without modifying order service
- **No recompilation**: Order service class remains unchanged
- **Isolated testing**: Test order service without relying on specific payment provider
- **Flexibility**: Support multiple payment providers simultaneously

![Benefits of Loose Coupling](assets/loose-coupling-benefits.png)

## What is Dependency Injection

- **Definition**: The process of providing (injecting) dependencies to a class
- **Analogy**: Like injecting medicine into a body, we inject objects into classes
- **Implementation**: Multiple ways to achieve dependency injection (covered in future lessons)
- **Key concept**: Dependencies are provided from outside rather than created internally

![Dependency Injection Process](assets/dependency-injection-process.png)

## Code Implementation

### Creating the Order Service

```java
public class OrderService {
    
    public void placeOrder() {
        // In real application, pass order object as parameter
        // Keeping simple to focus on dependency injection
    }
}
```

![Order Service Class Creation](assets/order-service-class-creation.png)

### Creating the Stripe Payment Service

```java
public class StripePaymentService {
    
    public void processPayment(double amount) {
        // In real application, pass payment object with credit card details
        System.out.println("Stripe");
        System.out.println(amount);
    }
}
```

![Stripe Payment Service Implementation](assets/stripe-payment-service-implementation.png)

### Tight Coupling Implementation

```java
public class OrderService {
    
    public void placeOrder() {
        // Tightly coupled to StripePaymentService
        StripePaymentService paymentService = new StripePaymentService();
        paymentService.processPayment(10.0);
    }
}
```

![Tight Coupling Code Example](assets/tight-coupling-code-example.png)

**Problems with this approach:**
- Cannot test OrderService in isolation
- Must modify OrderService to switch payment providers
- Requires recompilation and retesting when changes are made

### Extracting an Interface

**IntelliJ Process:**
1. **Navigate to**: StripePaymentService class
2. **Access menu**: Refactor → Extract → Interface
3. **Interface name**: Remove "Stripe" prefix, use "PaymentService"
4. **Select methods**: Choose `processPayment` method for interface
5. **Confirm**: Click Refactor button

![Extract Interface Dialog](assets/extract-interface-dialog.png)

**IntelliJ prompts:**
- "Interface has been successfully created" - Click Yes
- "Use interface where possible" (programming against interfaces) - Accept

![Interface Extraction Success](assets/interface-extraction-success.png)

### Interface Structure

```java
public interface PaymentService {
    void processPayment(double amount);
}

// StripePaymentService now implements the interface
public class StripePaymentService implements PaymentService {
    @Override
    public void processPayment(double amount) {
        System.out.println("Stripe");
        System.out.println(amount);
    }
}
```

![Payment Service Interface Structure](assets/payment-service-interface-structure.png)

**Interface characteristics:**
- **No implementation**: Contains only method declarations
- **No logic**: No algorithms or business logic
- **Contract definition**: Defines what capabilities implementing classes must have
- **Analogy**: Like a chef that can cook, but how they cook depends on implementation

![Interface Navigation in IDE](assets/interface-navigation-ide.png)

## Key Points

- **Main takeaway**: Dependency injection solves tight coupling problems by using interfaces to decouple classes
- **When to use**: When classes depend on other classes and you need flexibility to change implementations
- **Common misconception**: Dependency injection is complex - it's actually a simple concept
- **Interface role**: Acts as a contract between dependent classes and their dependencies
- **Real-world benefit**: Easy to switch between different service providers (Stripe, PayPal, etc.)
- **Testing advantage**: Enables isolated unit testing by removing concrete dependencies
- **Design principle**: "Program against interfaces, not implementations"
- **Next step**: Modify OrderService to use PaymentService interface instead of concrete StripePaymentService

## Links/References

- Video: 3.2-What-is-Dependency-Injection.mp4 (7m 42s)
- Previous: [Introduction to Dependency Injection](3.1-Introduction-to-Dependency-Injection.md)
- Next: Implementing Dependency Injection with Constructors

---

**Created**: July 30, 2025  
**Last Modified**: July 30, 2025

# Constructor Injection

<!-- omit from toc -->
## Table of Contents

- [Constructor Injection Overview](#constructor-injection-overview)
- [Implementing Constructor Injection](#implementing-constructor-injection)
  - [Adding Constructor to OrderService](#adding-constructor-to-orderservice)
  - [Storing Dependency as Field](#storing-dependency-as-field)
  - [Using Injected Dependency](#using-injected-dependency)
- [Testing Constructor Injection](#testing-constructor-injection)
  - [Setting Up Console Application](#setting-up-console-application)
  - [Injecting Stripe Payment Service](#injecting-stripe-payment-service)
  - [Running the Application](#running-the-application)
- [Adding Another Payment Provider](#adding-another-payment-provider)
  - [Creating PayPal Payment Service](#creating-paypal-payment-service)
  - [Implementing Interface Methods](#implementing-interface-methods)
  - [Testing PayPal Integration](#testing-paypal-integration)
- [Benefits Demonstrated](#benefits-demonstrated)
- [Open-Closed Principle](#open-closed-principle)
  - [Principle Definition](#principle-definition)
  - [Real-World Application](#real-world-application)
  - [Important Guidelines](#important-guidelines)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Constructor Injection Overview

- **Recommended approach**: Constructor injection is the preferred way to inject dependencies
- **How it works**: Dependencies are passed as constructor parameters
- **Benefits**: Ensures required dependencies are provided at object creation time
- **Immutability**: Creates immutable dependency relationships

![Constructor Injection Concept](assets/constructor-injection-concept.png)

## Implementing Constructor Injection

### Adding Constructor to OrderService

```java
public class OrderService {
    
    public OrderService(PaymentService paymentService) {
        // Constructor receives dependency as parameter
    }
}
```

![Constructor Definition in OrderService](assets/constructor-definition-orderservice.png)

**Steps in IDE:**
1. **Create constructor**: `public OrderService` + Tab for completion
2. **Add parameter**: `PaymentService paymentService` + Tab
3. **IntelliJ assistance**: IDE provides code completion suggestions

### Storing Dependency as Field

```java
public class OrderService {
    private PaymentService paymentService; // Field to store injected dependency
    
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService; // Store dependency in field
    }
}
```

![Field Declaration and Assignment](assets/field-declaration-dependency-storage.png)

**IntelliJ Features:**
- **Auto-detection**: IDE automatically suggests field assignment code
- **Tab completion**: Press Tab to accept suggested code
- **Field creation**: Automatically declares private field when needed

### Using Injected Dependency

```java
public class OrderService {
    private PaymentService paymentService;
    
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public void placeOrder() {
        // Use injected dependency instead of creating new instance
        paymentService.processPayment(10.0);
    }
}
```

![Using Injected Dependency in Method](assets/using-injected-dependency-method.png)

**Key change**: Replace `new StripePaymentService()` with injected `paymentService` field

## Testing Constructor Injection

### Setting Up Console Application

```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        // SpringApplication.run(StoreApplication.class, args); // Commented out
        
        // Running as console application for testing
        OrderService orderService = new OrderService(new StripePaymentService());
        orderService.placeOrder();
    }
}
```

![Console Application Setup](assets/console-application-setup.png)

**Setup steps:**
1. **Comment out Spring**: Remove Spring Boot auto-start
2. **Create OrderService**: Instantiate with constructor injection
3. **Pass dependency**: Inject StripePaymentService through constructor

### Injecting Stripe Payment Service

- **Dependency injection point**: Constructor parameter allows choosing implementation
- **Flexibility**: Can pass `new StripePaymentService()` or any other PaymentService implementation
- **Runtime decision**: Choose which payment provider to use at object creation time

![Stripe Payment Service Injection](assets/stripe-payment-service-injection.png)

### Running the Application

**Expected output:**
```
Stripe
10.0
```

![Application Output with Stripe](assets/application-output-stripe.png)

**Verification**: Application successfully uses Stripe payment service through constructor injection

## Adding Another Payment Provider

### Creating PayPal Payment Service

```java
public class PayPalPaymentService implements PaymentService {
    // Implementation will be added
}
```

![Creating PayPal Payment Service Class](assets/creating-paypal-payment-service.png)

**Steps:**
1. **Create new class**: Add `PayPalPaymentService` to package
2. **Implement interface**: Add `implements PaymentService`
3. **Tab completion**: Use IDE assistance for interface implementation

### Implementing Interface Methods

```java
public class PayPalPaymentService implements PaymentService {
    
    @Override
    public void processPayment(double amount) {
        System.out.println("PayPal");
        System.out.println(amount);
    }
}
```

![PayPal Interface Implementation](assets/paypal-interface-implementation.png)

**IntelliJ assistance:**
1. **Error detection**: IDE shows error for missing interface methods
2. **Quick fix**: Alt + Enter â†’ "Implement methods"  
3. **Method selection**: Choose methods from interface to implement
4. **Auto-generation**: IDE generates method stubs automatically

![Implement Methods Dialog](assets/implement-methods-dialog.png)

### Testing PayPal Integration

```java
public static void main(String[] args) {
    // Switch from Stripe to PayPal
    OrderService orderService = new OrderService(new PayPalPaymentService());
    orderService.placeOrder();
}
```

![PayPal Integration Test](assets/paypal-integration-test.png)

**Expected output:**
```
PayPal
10.0
```

![Application Output with PayPal](assets/application-output-paypal.png)

## Benefits Demonstrated

- **No OrderService changes**: Switching payment providers didn't require modifying OrderService class
- **Easy extension**: Added PayPal support by creating new class only
- **Runtime flexibility**: Choose payment provider at object creation time
- **Loose coupling**: OrderService works with any PaymentService implementation

![Benefits of Constructor Injection](assets/constructor-injection-benefits.png)

## Open-Closed Principle

### Principle Definition

- **Open for extension**: Classes should allow new functionality to be added
- **Closed for modification**: Existing code should not need to be changed
- **Goal**: Add features by creating new classes, not modifying existing ones
- **Benefit**: Reduces risk of introducing bugs in working code

![Open-Closed Principle Diagram](assets/open-closed-principle-diagram.png)

### Real-World Application

**Our example demonstrates:**
- **Extension**: Added PayPal support without changing OrderService
- **No modification**: OrderService class remained unchanged
- **New functionality**: Created PayPalPaymentService class only
- **Reduced risk**: No chance of breaking existing OrderService logic

### Important Guidelines

- **Tool, not rule**: Principles are guidelines to help build better software
- **Use with common sense**: Don't apply blindly to every situation
- **Add value**: Apply when it makes sense and provides real benefits
- **Avoid over-engineering**: Don't create complex solutions for simple problems

**Warning about misuse:**
- **Blind application**: Applying principles everywhere leads to over-engineered code
- **Common mistake**: Blaming OOP when principles are misused
- **Balanced approach**: Use principles judiciously with practical considerations

![Principle Guidelines and Best Practices](assets/principle-guidelines-best-practices.png)

## Key Points

- **Main takeaway**: Constructor injection is the recommended way to implement dependency injection in classes
- **When to use**: For all required dependencies that a class needs to function properly
- **Implementation steps**: Add constructor parameter, store in field, use injected dependency
- **Flexibility benefit**: Easy to switch between different implementations at runtime
- **Open-Closed Principle**: Extend functionality by adding new classes, not modifying existing ones
- **Best practice**: Use dependency injection to achieve loose coupling between classes
- **IDE assistance**: Modern IDEs provide excellent support for implementing interfaces and dependency injection
- **Testing advantage**: Constructor injection makes it easy to provide mock implementations for testing
- **Principle application**: Use OOP principles as tools to guide design decisions, not rigid rules

## Links/References

- Video: 3.3-Constructor-Injection.mp4 (4m 54s)
- Previous: [What is Dependency Injection](3.2-What-is-Dependency-Injection.md)
- Next: Field and Setter Injection

---

**Created**: July 30, 2025  
**Last Modified**: July 30, 2025

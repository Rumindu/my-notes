# Composable Queries Using Specifications API

<!-- omit from toc -->

## Table of Contents

- [Specifications API Overview](#specifications-api-overview)
- [Extending Repository with JpaSpecificationExecutor](#extending-repository-with-jpaspecificationexecutor)
- [Understanding JpaSpecificationExecutor Interface](#understanding-jpaspecificationexecutor-interface)
- [Creating Specifications Package Structure](#creating-specifications-package-structure)
- [Building Specification Utility Class](#building-specification-utility-class)
- [Understanding Specification Interface](#understanding-specification-interface)
- [Implementing String Matching Specifications](#implementing-string-matching-specifications)
- [Creating Numeric Range Specifications](#creating-numeric-range-specifications)
- [Composing Specifications in Service Layer](#composing-specifications-in-service-layer)
- [Starting with Empty Specifications](#starting-with-empty-specifications)
- [Dynamic Specification Composition](#dynamic-specification-composition)
- [Executing Specification-Based Queries](#executing-specification-based-queries)
- [Testing Composable Query Behavior](#testing-composable-query-behavior)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Specifications API Overview

- **Built on Criteria API**: Specifications provide a higher-level abstraction over the verbose Criteria API
- **Reusable components**: Create modular, reusable query components that can be combined
- **Composable queries**: Build complex queries by combining simple specification objects
- **Cleaner syntax**: More maintainable approach compared to raw Criteria API implementation

![Specifications API Overview](assets/specifications-api-overview.png)

**Advantages over Criteria API:**
- **Reduced verbosity**: Less boilerplate code for common query patterns
- **Better reusability**: Individual specifications can be reused across different queries
- **Easier composition**: Combine specifications using logical operators (and, or, not)
- **Improved maintainability**: Modular approach makes code easier to understand and modify

## Extending Repository with JpaSpecificationExecutor

- **Interface extension**: Add JpaSpecificationExecutor to repository interface
- **Generic type**: Specify entity type for type-safe specification operations
- **Multiple inheritance**: Combine with existing JpaRepository and custom repository interfaces
- **Specification methods**: Gain access to findAll(), findOne(), count(), and exists() methods that accept Specification objects

```java
// Extend repository with specification capability
public interface ProductRepository extends 
    JpaRepository<Product, Long>, 
    ProductCriteriaRepository,
    JpaSpecificationExecutor<Product> {
    
    // All existing methods still available
    // Plus specification-based methods from JpaSpecificationExecutor
}
```

![Repository with JpaSpecificationExecutor](assets/repository-jpaspecificationexecutor.png)

## Understanding JpaSpecificationExecutor Interface

- **Specification methods**: Interface provides overloaded methods for specification-based querying
- **Method variants**: findAll(), findOne(), count(), exists() all accept Specification parameters
- **Type safety**: Generic interface ensures compile-time type checking
- **Spring Data integration**: Seamlessly integrates with existing Spring Data JPA infrastructure

![JpaSpecificationExecutor Interface Methods](assets/jpaspecificationexecutor-interface-methods.png)

**Available specification methods:**
- **Optional<T> findOne(Specification<T> spec)**: Find single entity matching specification
- **List<T> findAll(Specification<T> spec)**: Find all entities matching specification
- **long count(Specification<T> spec)**: Count entities matching specification
- **boolean exists(Specification<T> spec)**: Check if any entity matches specification

## Creating Specifications Package Structure

- **Package organization**: Create dedicated package for specification classes
- **Separation of concerns**: Keep specifications separate from repositories and entities
- **Modular structure**: Organize specifications by entity type or functional area
- **Naming conventions**: Use descriptive names like ProductSpecifications or ProductSpec

```java
// Package structure
// src/main/java/com/example/repositories/specifications/
// └── ProductSpecifications.java
```

![Specifications Package Structure](assets/specifications-package-structure.png)

## Building Specification Utility Class

- **Static utility methods**: Create class with static methods for generating specifications
- **Naming conventions**: Use descriptive method names like hasName(), priceGreaterThan()
- **Return type**: All methods return Specification<EntityType> objects
- **Parameter handling**: Accept filter values as method parameters

```java
public class ProductSpecifications {
    
    // Static utility method for name filtering
    public static Specification<Product> hasName(String name) {
        // Implementation returns Specification<Product>
    }
    
    // Static utility method for minimum price filtering
    public static Specification<Product> priceGreaterThanOrEqualTo(BigDecimal minPrice) {
        // Implementation returns Specification<Product>
    }
    
    // Static utility method for maximum price filtering
    public static Specification<Product> priceLessThanOrEqualTo(BigDecimal maxPrice) {
        // Implementation returns Specification<Product>
    }
}
```

![Specification Utility Class](assets/specification-utility-class.png)

## Understanding Specification Interface

- **Functional interface**: Single abstract method toPredicate() makes it suitable for lambda expressions
- **Method signature**: toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb)
- **Parameter familiarity**: Same parameters as used in Criteria API implementation
- **Lambda implementation**: Can be implemented using concise lambda expressions

```java
// Specification interface structure
@FunctionalInterface
public interface Specification<T> {
    
    // Single abstract method - enables lambda usage
    Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb);
    
    // Default methods for composition (and, or, not) - ignore for now
    // These are helper utility methods for combining specifications
}
```

![Specification Interface Structure](assets/specification-interface-structure.png)

## Implementing String Matching Specifications

- **Lambda expressions**: Use lambda syntax for concise specification implementation
- **LIKE operator**: Implement string pattern matching using CriteriaBuilder.like()
- **Wildcard patterns**: Add % wildcards for substring matching functionality
- **Field access**: Use Root.get() method to access entity properties

```java
public class ProductSpecifications {
    
    public static Specification<Product> hasName(String name) {
        // Lambda implementation with familiar Criteria API parameters
        return (root, query, cb) -> {
            return cb.like(
                root.get("name"),        // Field reference
                "%" + name + "%"         // Pattern with wildcards
            );
        };
        // Generates: WHERE name LIKE '%parameter%'
    }
}
```

![String Matching Specifications](assets/string-matching-specifications.png)

## Creating Numeric Range Specifications

- **Comparison operators**: Use CriteriaBuilder methods for numeric comparisons
- **Range filtering**: Implement minimum and maximum value specifications separately
- **Type safety**: Root.get() provides type-safe access to numeric fields
- **Reusable components**: Individual range specifications can be combined as needed

```java
public class ProductSpecifications {
    
    public static Specification<Product> priceGreaterThanOrEqualTo(BigDecimal minPrice) {
        return (root, query, cb) -> {
            return cb.greaterThanOrEqualTo(
                root.get("price"),       // Price field
                minPrice                 // Minimum value
            );
        };
        // Generates: WHERE price >= minPrice
    }
    
    public static Specification<Product> priceLessThanOrEqualTo(BigDecimal maxPrice) {
        return (root, query, cb) -> {
            return cb.lessThanOrEqualTo(
                root.get("price"),       // Price field
                maxPrice                 // Maximum value
            );
        };
        // Generates: WHERE price <= maxPrice
    }
}
```

![Numeric Range Specifications](assets/numeric-range-specifications.png)

## Composing Specifications in Service Layer

- **Service method**: Create service methods that accept multiple optional parameters
- **Specification composition**: Build complex queries by combining individual specifications
- **Dynamic building**: Add specifications conditionally based on parameter values
- **Logical operators**: Use and(), or(), not() methods for specification composition

```java
@Service
public class UserService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public void fetchProductsBySpecifications(
        String name, 
        BigDecimal minPrice, 
        BigDecimal maxPrice) {
        
        // Build specification dynamically
        // Implementation details in following sections
    }
}
```

![Service Layer Specification Composition](assets/service-layer-specification-composition.png)

## Starting with Empty Specifications

- **Neutral starting point**: Use Specification.where(null) as base specification
- **Identity specification**: Empty specification that matches all records
- **Composition foundation**: Starting point for adding conditions dynamically
- **Null-safe operations**: Safe to combine with other specifications using logical operators

```java
public void fetchProductsBySpecifications(
    String name, BigDecimal minPrice, BigDecimal maxPrice) {
    
    // Start with empty/neutral specification
    Specification<Product> spec = Specification.where(null);
    
    // This creates a specification that doesn't filter anything
    // Equivalent to "WHERE 1=1" or no WHERE clause
}
```

![Empty Specification Starting Point](assets/empty-specification-starting-point.png)

## Dynamic Specification Composition

- **Conditional composition**: Add specifications only when parameters are not null
- **and() method**: Combine specifications using logical AND operator
- **Method chaining**: Chain multiple and() calls to build complex conditions
- **Runtime flexibility**: Same code produces different queries based on parameter values

```java
public void fetchProductsBySpecifications(
    String name, BigDecimal minPrice, BigDecimal maxPrice) {
    
    Specification<Product> spec = Specification.where(null);
    
    // Add name filter if provided
    if (name != null) {
        spec = spec.and(ProductSpecifications.hasName(name));
    }
    
    // Add minimum price filter if provided
    if (minPrice != null) {
        spec = spec.and(ProductSpecifications.priceGreaterThanOrEqualTo(minPrice));
    }
    
    // Add maximum price filter if provided
    if (maxPrice != null) {
        spec = spec.and(ProductSpecifications.priceLessThanOrEqualTo(maxPrice));
    }
    
    // spec now contains all applicable conditions combined with AND
}
```

![Dynamic Specification Composition](assets/dynamic-specification-composition.png)

## Executing Specification-Based Queries

- **Repository method**: Call findAll() method with composed specification
- **Automatic SQL generation**: Spring Data JPA generates optimized SQL from specification
- **Result processing**: Handle results same as other repository query methods
- **Type safety**: Return type matches repository generic type

```java
public void fetchProductsBySpecifications(
    String name, BigDecimal minPrice, BigDecimal maxPrice) {
    
    // ... specification building code above ...
    
    // Execute query with composed specification
    List<Product> products = productRepository.findAll(spec);
    
    // Process results
    products.forEach(System.out::println);
}
```

![Executing Specification Queries](assets/executing-specification-queries.png)

## Testing Composable Query Behavior

- **Parameter variations**: Test different parameter combinations to verify dynamic behavior
- **SQL generation**: Observe generated SQL to confirm correct query construction
- **Null parameter handling**: Verify that null parameters are properly excluded
- **Composition verification**: Confirm that multiple conditions are combined with AND operator

```java
// Test different parameter combinations

// Example 1: Name filter only
fetchProductsBySpecifications("prod", null, null);
// Generates: WHERE name LIKE '%prod%'

// Example 2: Name and minimum price
fetchProductsBySpecifications("prod", BigDecimal.valueOf(1), null);
// Generates: WHERE name LIKE '%prod%' AND price >= 1

// Example 3: All filters
fetchProductsBySpecifications("prod", BigDecimal.valueOf(1), BigDecimal.valueOf(10));
// Generates: WHERE name LIKE '%prod%' AND price >= 1 AND price <= 10
```

![Testing Specification Behavior](assets/testing-specification-behavior.png)

![Generated Specification SQL](assets/generated-specification-sql.png)

## Key Points

- **Main takeaway**: Specifications API provides a cleaner, more maintainable approach to dynamic queries by building reusable, composable query components on top of the Criteria API
- **Repository extension**: Extend repository with JpaSpecificationExecutor to gain access to specification-based query methods
- **Utility classes**: Create static utility classes with methods that return Specification objects for common filtering operations
- **Functional interface**: Specification is a functional interface that can be implemented using lambda expressions with familiar Criteria API parameters
- **Composition flexibility**: Use Specification.where(null) as starting point and chain with and(), or(), not() methods for dynamic query building
- **Reusable components**: Individual specifications can be reused across different queries and combined in various ways
- **Type safety**: Generic types and compile-time checking prevent many query construction errors
- **Dynamic execution**: Same service method produces different SQL queries based on parameter values and null checking
- **Reduced verbosity**: Significantly less boilerplate code compared to raw Criteria API implementation
- **Better maintainability**: Modular approach makes queries easier to understand, test, and modify - ideal for complex search functionality and conditional business logic

## Links/References

- Video: 4.10.3-Composable-Queries-Using-Specifications-API.mp4 (07:20)
- Previous: [Dynamic Queries Using Criteria API](4.10.2-Dynamic-Queries-Using-Criteria-API.md)
- Next: Pagination and Sorting with Dynamic Queries
- Reference: [Spring Data JPA Specifications](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#specifications)
- Reference: [JpaSpecificationExecutor Documentation](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaSpecificationExecutor.html)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

# Configuring Beans Using Code

<!-- omit from toc -->
## Table of Contents

- [Code-Based vs Annotation-Based Configuration](#code-based-vs-annotation-based-configuration)
- [When to Use Code-Based Configuration](#when-to-use-code-based-configuration)
  - [Scenarios Requiring Code-Based Approach](#scenarios-requiring-code-based-approach)
- [Removing Annotation-Based Configuration](#removing-annotation-based-configuration)
  - [PayPal Payment Service](#paypal-payment-service)
  - [Stripe Payment Service](#stripe-payment-service)
  - [Order Service](#order-service)
- [Creating Configuration Class](#creating-configuration-class)
  - [AppConfig Class Setup](#appconfig-class-setup)
  - [Bean Producer Methods](#bean-producer-methods)
  - [Dependency Injection in Code](#dependency-injection-in-code)
- [Testing Code-Based Configuration](#testing-code-based-configuration)
- [Exercise: Dynamic Payment Gateway Selection](#exercise-dynamic-payment-gateway-selection)
  - [Exercise Requirements](#exercise-requirements)
  - [Solution Implementation](#solution-implementation)
    - [Adding PayPal Bean Method](#adding-paypal-bean-method)
    - [Simplifying OrderService](#simplifying-orderservice)
  - [Configuration Property](#configuration-property)
  - [Reading Configuration in AppConfig](#reading-configuration-in-appconfig)
  - [Conditional Bean Creation](#conditional-bean-creation)
  - [Testing Dynamic Configuration](#testing-dynamic-configuration)
- [Benefits of Code-Based Configuration](#benefits-of-code-based-configuration)
  - [Advantages Over Annotations](#advantages-over-annotations)
  - [Trade-offs](#trade-offs)
  - [Better Design Pattern](#better-design-pattern)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Code-Based vs Annotation-Based Configuration

- **Annotation-based**: Simple and easy using @Service, @Component annotations
- **Code-based**: More control over bean creation using Java configuration classes
- **Use case**: When you need complex logic during bean creation
- **Flexibility**: Code-based allows conditional bean creation and custom initialization

![Code vs Annotation Configuration Comparison](assets/code-vs-annotation-configuration-comparison.png)

## When to Use Code-Based Configuration

### Scenarios Requiring Code-Based Approach

- **Complex bean creation**: When additional logic is needed during bean instantiation
- **Third-party libraries**: Cannot add annotations to classes you don't control
- **Conditional creation**: Create different beans based on runtime conditions
- **Custom initialization**: Need to perform specific setup during bean creation

![When to Use Code Configuration](assets/when-to-use-code-configuration.png)

## Removing Annotation-Based Configuration

### PayPal Payment Service
```java
// @Service("payPal")  // Remove annotation
public class PayPalPaymentService implements PaymentService {
    
    @Override
    public void processPayment(double amount) {
        System.out.println("PayPal");
        System.out.println(amount);
    }
}
```

![Removing PayPal Service Annotation](assets/removing-paypal-service-annotation.png)

### Stripe Payment Service
```java
// @Service("stripe")  // Remove annotation
// @Primary           // Remove annotation
public class StripePaymentService implements PaymentService {
    
    @Override
    public void processPayment(double amount) {
        System.out.println("Stripe");
        System.out.println(amount);
    }
}
```

![Removing Stripe Service Annotations](assets/removing-stripe-service-annotations.png)

### Order Service
```java
// @Service  // Remove annotation
public class OrderService {
    private PaymentService paymentService;
    
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public void placeOrder() {
        paymentService.processPayment(10.0);
    }
}
```

![Removing Order Service Annotation](assets/removing-order-service-annotation.png)

## Creating Configuration Class

### AppConfig Class Setup

```java
@Configuration  // NOT @Configurable - common mistake!
public class AppConfig {
    // Bean configuration methods go here
}
```

![AppConfig Class Creation](assets/appconfig-class-creation.png)

**Important note:**
- **@Configuration**: Tells Spring this class contains bean definitions
- **Common mistake**: Using @Configurable instead of @Configuration
- **Naming convention**: AppConfig is commonly used but name doesn't matter

![Configuration vs Configurable Warning](assets/configuration-vs-configurable-warning.png)

### Bean Producer Methods

```java
@Configuration
public class AppConfig {
    
    @Bean
    public PaymentService stripe() {  // Method name becomes bean name
        return new StripePaymentService();
    }
}
```

![Bean Producer Method Example](assets/bean-producer-method-example.png)

**Method naming:**
- **Bean name**: Method name becomes the bean identifier
- **Noun not verb**: Use "stripe" not "getStripePaymentService"
- **@Bean annotation**: Marks method as bean producer

### Dependency Injection in Code

```java
@Configuration
public class AppConfig {
    
    @Bean
    public PaymentService stripe() {
        return new StripePaymentService();
    }
    
    @Bean
    public OrderService orderService() {
        // Full control over dependency injection
        return new OrderService(stripe());
    }
}
```

![Dependency Injection in Configuration](assets/dependency-injection-configuration.png)

**Benefits of code-based approach:**
- **Full control**: Can add conditional logic for bean creation
- **Custom logic**: if/else statements to determine which beans to create
- **Method calls**: Directly call other bean producer methods for dependencies

## Testing Code-Based Configuration

**Expected behavior**: Application should work exactly as before

**Test run output:**
```
Stripe
10.0
```

![Code Configuration Test Output](assets/code-configuration-test-output.png)

**Verification**: All beans created successfully via configuration class

## Exercise: Dynamic Payment Gateway Selection

### Exercise Requirements

- **Configuration property**: Add payment gateway setting to application.yaml
- **Possible values**: "stripe" or "paypal"
- **Dynamic selection**: Order service uses different payment services based on configuration
- **@Value injection**: Read configuration into AppConfig class
- **Conditional logic**: Use if/else to wire correct payment service

![Exercise Requirements Overview](assets/exercise-requirements-overview.png)

### Solution Implementation

#### Adding PayPal Bean Method

```java
@Configuration
public class AppConfig {
    
    @Bean
    public PaymentService stripe() {
        return new StripePaymentService();
    }
    
    @Bean
    public PaymentService payPal() {
        return new PayPalPaymentService();
    }
    
    @Bean
    public OrderService orderService() {
        return new OrderService(stripe()); // Currently hardcoded
    }
}
```

![Adding PayPal Bean Method](assets/adding-paypal-bean-method.png)

#### Simplifying OrderService

```java
public class OrderService {
    private PaymentService paymentService;
    
    // Remove @Qualifier annotation - no longer needed
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public void placeOrder() {
        paymentService.processPayment(10.0);
    }
}
```

![Simplified OrderService Class](assets/simplified-orderservice-class.png)

**Cleanup**: Remove @Qualifier responsibility from OrderService to AppConfig

### Configuration Property

```yaml
# application.yaml
spring:
  application:
    name: store

payment-gateway: stripe  # Can be "stripe" or "paypal"
```

![Payment Gateway Configuration Property](assets/payment-gateway-configuration-property.png)

### Reading Configuration in AppConfig

```java
@Configuration
public class AppConfig {
    
    @Value("${payment-gateway:stripe}")  // Default to stripe if not configured
    private String paymentGateway;
    
    @Bean
    public PaymentService stripe() {
        return new StripePaymentService();
    }
    
    @Bean
    public PaymentService payPal() {
        return new PayPalPaymentService();
    }
    
    @Bean
    public OrderService orderService() {
        // Will be updated with conditional logic
        return new OrderService(stripe());
    }
}
```

![Reading Configuration in AppConfig](assets/reading-configuration-appconfig.png)

### Conditional Bean Creation

```java
@Configuration
public class AppConfig {
    
    @Value("${payment-gateway:stripe}")
    private String paymentGateway;
    
    @Bean
    public PaymentService stripe() {
        return new StripePaymentService();
    }
    
    @Bean
    public PaymentService payPal() {
        return new PayPalPaymentService();
    }
    
    @Bean
    public OrderService orderService() {
        if (paymentGateway.equals("stripe")) {
            return new OrderService(stripe());
        } else {
            return new OrderService(payPal());
        }
    }
}
```

![Conditional Bean Creation Logic](assets/conditional-bean-creation-logic.png)

### Testing Dynamic Configuration

**Test 1: Using Stripe (default)**
```yaml
payment-gateway: stripe
```

**Expected output:**
```
Stripe
10.0
```

![Testing Stripe Configuration](assets/testing-stripe-configuration.png)

**Test 2: Using PayPal**
```yaml
payment-gateway: paypal
```

**Expected output:**
```
PayPal
10.0
```

![Testing PayPal Configuration](assets/testing-paypal-configuration.png)

**Dynamic behavior**: Application behavior changes based on configuration without code changes

## Benefits of Code-Based Configuration

### Advantages Over Annotations

- **More control**: Full programmatic control over bean creation
- **Conditional logic**: Create different beans based on runtime conditions
- **Third-party support**: Configure beans for libraries you don't control
- **Complex initialization**: Perform custom setup during bean creation

### Trade-offs

- **More verbose**: Requires more code than simple annotations
- **Complexity**: Can become complex for simple scenarios
- **Recommendation**: Use annotations for simple cases, code for complex scenarios

![Code Configuration Benefits and Trade-offs](assets/code-configuration-benefits-tradeoffs.png)

### Better Design Pattern

**Previous approach**: Hard-coded payment service selection in OrderService
**New approach**: Externalized configuration drives bean selection
**Benefits**: 
- Configuration-driven behavior
- No code changes needed to switch payment providers
- Separation of concerns

![Better Design Pattern Comparison](assets/better-design-pattern-comparison.png)

## Key Points

- **Main takeaway**: Code-based configuration provides more control over bean creation than annotations
- **When to use**: For complex bean creation logic, third-party libraries, or conditional bean creation
- **@Configuration class**: Contains @Bean methods that produce Spring-managed objects
- **Trade-off**: More verbose than annotations but offers greater flexibility
- **Dynamic configuration**: Can create different beans based on external configuration properties
- **Best practice**: Use annotations for simple scenarios, code configuration for complex ones
- **Design improvement**: Externalize bean selection logic from business classes to configuration classes
- **Common mistake**: Using @Configurable instead of @Configuration
- **Method naming**: Bean method names become bean identifiers in Spring container

## Links/References

- Video: 3.10-Configuring-Beans-Using-Code.mp4 (6m 31s)
- Previous: [Externalizing Configuration](3.9-Externalizing-Configuration.md)
- Next: Component Scanning and Profiles

---

**Created**: July 30, 2025  
**Last Modified**: July 30, 2025

# Designing the Application Model

<!-- omit from toc -->

## Table of Contents

- [Application Model Overview](#application-model-overview)
- [Core Entities and Relationships](#core-entities-and-relationships)
  - [Category and Product Relationship](#category-and-product-relationship)
  - [User and Product Wishlist](#user-and-product-wishlist)
  - [User and Tag Association](#user-and-tag-association)
  - [User and Profile Connection](#user-and-profile-connection)
  - [User and Address Relationship](#user-and-address-relationship)
- [Entity Details](#entity-details)
  - [Category Entity](#category-entity)
  - [Product Entity](#product-entity)
  - [User Entity](#user-entity)
  - [Profile Entity](#profile-entity)
  - [Tag Entity](#tag-entity)
  - [Address Entity](#address-entity)
- [Implementation Approaches](#implementation-approaches)
  - [Database First Approach](#database-first-approach)
  - [Model First Approach](#model-first-approach)
  - [Approach Selection](#approach-selection)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Application Model Overview

- **E-commerce focus**: Model designed for typical e-commerce application requirements
- **Core entities**: Category, Product, Profile, User, Tag, and Address
- **Relationship-driven**: Entity relationships define application data flow
- **Business requirements**: Model should always reflect specific business needs

![E-commerce Application Model Overview](assets/ecommerce-application-model-overview.png)

**Model characteristics:**
- Six primary entities with defined relationships
- Mix of one-to-many, many-to-many, and one-to-one associations
- Flexible design allowing for business requirement variations
- Foundation for both database schema and Java domain classes

## Core Entities and Relationships

### Category and Product Relationship

- **Relationship type**: One-to-Many (Category → Product)
- **Business rule**: One category can contain many products
- **Product constraint**: Each product belongs to only one category
- **Application-specific**: This relationship may vary in different applications

![Category Product One-to-Many Relationship](assets/category-product-one-to-many-relationship.png)

**Relationship details:**
- **One side**: Category entity (parent)
- **Many side**: Product entity (child)
- **Asterisk notation**: Indicates "many" in relationship diagrams
- **Business flexibility**: Some applications may require many-to-many for products in multiple categories

### User and Product Wishlist

- **Relationship type**: Many-to-Many (User ↔ Product)
- **Business functionality**: Users can have multiple products in wishlist
- **Product perspective**: Products can appear in multiple user wishlists
- **Common e-commerce feature**: Standard wishlist functionality

![User Product Wishlist Many-to-Many](assets/user-product-wishlist-many-to-many.png)

**Wishlist characteristics:**
- **User side**: Can have many favorite products
- **Product side**: Can be favorited by many users
- **Join table**: Requires intermediate table for many-to-many relationship
- **Practical application**: Essential for e-commerce user experience

### User and Tag Association

- **Relationship type**: Many-to-Many (User ↔ Tag)
- **Demonstration purpose**: Included for educational examples
- **Business logic note**: Tags typically apply to products, not users
- **Educational design**: Deliberately added for demo and exercise structure

![User Tag Many-to-Many Association](assets/user-tag-many-to-many-association.png)

**Association details:**
- **User side**: Can have multiple tags applied
- **Tag side**: Can be applied to multiple users
- **Educational note**: Real applications would likely tag products instead
- **Demo structure**: Designed for specific course exercises

### User and Profile Connection

- **Relationship type**: One-to-One (User ↔ Profile)
- **Data separation**: Account info vs. optional personal info
- **User entity**: Core account data (username, email, password, last sign-in)
- **Profile entity**: Optional data (bio, avatar, phone, date of birth, loyalty points)

![User Profile One-to-One Relationship](assets/user-profile-one-to-one-relationship.png)

**Data organization:**
- **User table**: Essential account information
- **Profile table**: Extended personal information
- **Optional nature**: Profile data may not exist for all users
- **Performance benefit**: Separates frequently accessed from optional data

### User and Address Relationship

- **Relationship type**: One-to-Many (User → Address)
- **Multiple addresses**: Users can have multiple shipping/billing addresses
- **Address ownership**: Each address belongs to exactly one user
- **E-commerce necessity**: Essential for order fulfillment

![User Address One-to-Many Relationship](assets/user-address-one-to-many-relationship.png)

**Address management:**
- **User side**: Can have multiple addresses (home, work, billing, shipping)
- **Address side**: Belongs to single user only
- **Business utility**: Supports multiple delivery options
- **Data integrity**: Clear ownership prevents address confusion

## Entity Details

### Category Entity

- **Purpose**: Organize products into logical groupings
- **Typical fields**: ID, name, description, created date
- **Relationship**: Parent to multiple products
- **Business value**: Product organization and navigation

![Category Entity Structure](assets/category-entity-structure.png)

### Product Entity

- **Purpose**: Core merchandise information
- **Typical fields**: ID, name, description, price, inventory, category reference
- **Relationships**: Belongs to category, appears in wishlists
- **Business value**: Central to e-commerce functionality

![Product Entity Structure](assets/product-entity-structure.png)

### User Entity

- **Purpose**: Account and authentication information
- **Core fields**: ID, username, email, password, last sign-in timestamp
- **Security focus**: Essential login and security data
- **Relationships**: Connected to profile, addresses, wishlists, tags

![User Entity Structure](assets/user-entity-structure.png)

### Profile Entity

- **Purpose**: Extended user information beyond account essentials
- **Optional fields**: Bio, avatar URL, phone number, date of birth, loyalty points
- **Enhancement data**: Improves user experience but not required for basic functionality
- **Relationship**: One-to-one with user entity

![Profile Entity Structure](assets/profile-entity-structure.png)

### Tag Entity

- **Purpose**: Labeling and categorization system
- **Typical fields**: ID, name, description, color
- **Flexibility**: Can be applied to various entities
- **Demonstration**: Used for educational purposes in user relationships

![Tag Entity Structure](assets/tag-entity-structure.png)

### Address Entity

- **Purpose**: Physical location information for users
- **Typical fields**: ID, street, city, state, postal code, country, address type
- **Relationship**: Belongs to specific user
- **Business necessity**: Required for shipping and billing

![Address Entity Structure](assets/address-entity-structure.png)

## Implementation Approaches

### Database First Approach

- **Process**: Create database schema first, then generate domain classes
- **Common usage**: Popular in larger organizations with dedicated database teams
- **Workflow**: Database design → Table creation → Domain class generation
- **Advantages**: Database-centric design, established schema before coding

![Database First Approach Workflow](assets/database-first-approach-workflow.png)

**Database-first characteristics:**
- Start with database table design
- Generate Java classes from existing schema
- Database structure drives application design
- Common in enterprise environments

### Model First Approach

- **Process**: Create Java domain classes first, then generate database schema
- **Workflow**: Domain class design → Annotation configuration → Schema generation
- **Advantages**: Object-oriented design first, code-centric approach
- **Flexibility**: Easier to modify during development

![Model First Approach Workflow](assets/model-first-approach-workflow.png)

**Model-first characteristics:**
- Start with Java class design
- Use JPA annotations to define relationships
- Generate database schema from classes
- More flexible during development phase

### Approach Selection

- **No right or wrong**: Both approaches have valid use cases
- **Personal preference**: Developers often prefer one approach over another
- **Course focus**: Primary emphasis on database-first approach
- **Comprehensive coverage**: Both approaches demonstrated for comparison

![Implementation Approach Comparison](assets/implementation-approach-comparison.png)

**Selection factors:**
- **Team structure**: Database specialists may favor database-first
- **Project phase**: New projects may benefit from model-first flexibility
- **Organizational standards**: Company policies may dictate approach
- **Developer experience**: Familiarity with approach influences choice

## Key Points

- **Main takeaway**: E-commerce application model consists of six core entities with well-defined relationships that support typical business requirements
- **Relationship variety**: Model demonstrates one-to-many, many-to-many, and one-to-one relationships essential for complex applications
- **Business alignment**: Application model must always reflect specific business requirements rather than generic patterns
- **Data separation**: User and Profile entities demonstrate effective separation of essential vs. optional data
- **Educational design**: Some relationships (like User-Tag) included specifically for demonstration purposes rather than business logic
- **Implementation flexibility**: Both database-first and model-first approaches are valid with different advantages
- **Enterprise preference**: Database-first approach commonly used in larger organizations with dedicated database teams
- **Course coverage**: Comprehensive exploration of both approaches enables informed decision-making
- **Schema foundation**: Proper model design creates solid foundation for both database schema and Java domain classes
- **Business requirements first**: Model design should always start with understanding specific business needs and constraints

## Links/References

- Video: 4.5-Designing-the-Application-Model.mp4 (02:49)
- Previous: [Setting Up Spring Data JPA](4.4-Setting-Up-Spring-Data-JPA.md)
- Next: Creating Database Schema

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

# Sorting and Pagination

<!-- omit from toc -->

## Table of Contents

- [Sorting and Pagination Overview](#sorting-and-pagination-overview)
- [Repository Interface Requirements](#repository-interface-requirements)
- [Understanding PagingAndSortingRepository](#understanding-pagingandsortingrepository)
- [Creating Sort Objects](#creating-sort-objects)
- [Single Column Sorting](#single-column-sorting)
- [Multi-Column Sorting with Different Directions](#multi-column-sorting-with-different-directions)
- [Executing Sorted Queries](#executing-sorted-queries)
- [Creating Pageable Objects](#creating-pageable-objects)
- [Understanding PageRequest and Pageable](#understanding-pagerequest-and-pageable)
- [Executing Paginated Queries](#executing-paginated-queries)
- [Working with Page Results](#working-with-page-results)
- [Extracting Pagination Metadata](#extracting-pagination-metadata)
- [Database-Specific SQL Generation](#database-specific-sql-generation)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Sorting and Pagination Overview

- **Large dataset handling**: Avoid loading entire datasets at once for better performance
- **Chunked data retrieval**: Fetch data in smaller, manageable chunks
- **Ordered results**: Retrieve data in specific order using multiple sort criteria
- **Spring Data JPA support**: Built-in sorting and pagination without complex custom queries

![Sorting and Pagination Overview](assets/sorting-pagination-overview.png)

**Benefits of sorting and pagination:**
- **Performance optimization**: Reduce memory usage and network overhead
- **User experience**: Enable incremental data loading for large lists
- **Database efficiency**: Leverage database-level sorting and limiting capabilities
- **Scalability**: Handle datasets that grow over time without performance degradation

## Repository Interface Requirements

- **JpaRepository requirement**: Must extend JpaRepository (not CrudRepository) for sorting and pagination
- **Interface hierarchy**: JpaRepository extends PagingAndSortingRepository which provides sorting/pagination methods
- **Method availability**: findAll() overloads that accept Sort and Pageable parameters
- **Existing functionality**: All CRUD operations still available plus sorting/pagination capabilities

```java
// Correct repository for sorting and pagination
public interface ProductRepository extends JpaRepository<Product, Long> {
    // Inherits sorting and pagination methods:
    // List<T> findAll(Sort sort)
    // Page<T> findAll(Pageable pageable)
    // Page<T> findAll(Specification<T> spec, Pageable pageable)
}

// CrudRepository does NOT provide sorting/pagination
// public interface ProductRepository extends CrudRepository<Product, Long> {
//     // No sorting/pagination methods available
// }
```

![Repository Interface Requirements](assets/repository-interface-requirements.png)

## Understanding PagingAndSortingRepository

- **Interface hierarchy**: JpaRepository extends PagingAndSortingRepository extends CrudRepository
- **Additional methods**: Provides findAll() overloads for Sort and Pageable parameters
- **Inheritance chain**: All basic CRUD methods plus sorting and pagination capabilities
- **Type safety**: Generic interface ensures compile-time type checking

![PagingAndSortingRepository Hierarchy](assets/pagingandsortingrepository-hierarchy.png)

**Interface method overview:**
- **Iterable<T> findAll(Sort sort)**: Find all entities with sorting
- **Page<T> findAll(Pageable pageable)**: Find all entities with pagination
- **Inherited methods**: All CrudRepository methods (save, findById, delete, etc.)

## Creating Sort Objects

- **Sort class**: Import from org.springframework.data.domain.Sort
- **Factory method**: Use Sort.by() to create sort objects with field names
- **Default direction**: Ascending order by default
- **Multiple properties**: Can sort by multiple fields in single Sort.by() call

```java
@Service
public class UserService {
    
    public void fetchSortedProducts() {
        // Import Sort from org.springframework.data.domain.Sort
        
        // Single field sorting (ascending by default)
        Sort sort = Sort.by("name");
        
        // Multiple fields sorting (all ascending)
        Sort multiSort = Sort.by("name", "price");
        
        // Explicit direction specification
        Sort descendingSort = Sort.by("name").descending();
    }
}
```

![Creating Sort Objects](assets/creating-sort-objects.png)

## Single Column Sorting

- **Simple sorting**: Sort by single field using Sort.by()
- **Direction control**: Use ascending() or descending() methods to specify sort direction
- **Default behavior**: Ascending order when no direction specified
- **Field names**: Use exact entity property names as strings

```java
public void fetchSortedProducts() {
    // Sort by name in ascending order (default)
    Sort sort = Sort.by("name");
    
    // Sort by price in descending order
    Sort priceSort = Sort.by("price").descending();
    
    // Execute query with sort
    List<Product> products = productRepository.findAll(sort);
    products.forEach(System.out::println);
}
```

![Single Column Sorting](assets/single-column-sorting.png)

## Multi-Column Sorting with Different Directions

- **Complex sorting**: Combine multiple sort criteria with different directions
- **Sort composition**: Use and() method to chain sort objects together
- **Direction independence**: Each field can have its own sort direction
- **Order precedence**: First sort takes precedence, subsequent sorts used for ties

```java
public void fetchSortedProducts() {
    // Sort by name ascending, then by price descending
    Sort sort = Sort.by("name")                    // First: name ascending
                   .and(Sort.by("price").descending()); // Then: price descending
    
    // Alternative syntax for multiple criteria
    Sort multiSort = Sort.by(
        Sort.Order.asc("name"),        // Ascending name
        Sort.Order.desc("price")       // Descending price
    );
    
    List<Product> products = productRepository.findAll(sort);
    products.forEach(System.out::println);
}
```

![Multi-Column Sorting](assets/multi-column-sorting.png)

## Executing Sorted Queries

- **Repository method**: Use findAll(Sort sort) overload for sorted queries
- **SQL generation**: Spring Data JPA generates ORDER BY clauses automatically
- **Database optimization**: Leverages database indexing for efficient sorting
- **Result processing**: Returns sorted List<Entity> for iteration

```java
public void fetchSortedProducts() {
    // Create sort object
    Sort sort = Sort.by("name")
                   .and(Sort.by("price").descending());
    
    // Execute sorted query
    List<Product> products = productRepository.findAll(sort);
    
    // Process sorted results
    products.forEach(System.out::println);
}
```

![Executing Sorted Queries](assets/executing-sorted-queries.png)

![Generated Sort SQL](assets/generated-sort-sql.png)

## Creating Pageable Objects

- **PageRequest class**: Import from org.springframework.data.domain.PageRequest
- **Factory method**: Use PageRequest.of() to create pageable objects
- **Zero-based indexing**: Page numbers start from 0 (0 = first page)
- **Page size**: Specify number of records per page

```java
public void fetchPaginatedProducts(int pageNumber, int size) {
    // Import PageRequest from org.springframework.data.domain.PageRequest
    
    // Create pageable object (page numbers start from 0)
    Pageable pageable = PageRequest.of(pageNumber, size);
    
    // pageNumber: 0 = first page, 1 = second page, etc.
    // size: number of records per page
}
```

![Creating Pageable Objects](assets/creating-pageable-objects.png)

## Understanding PageRequest and Pageable

- **Class hierarchy**: PageRequest extends AbstractPageRequest implements Pageable
- **Interface requirement**: Repository methods expect Pageable interface
- **Implementation details**: PageRequest is concrete implementation of Pageable
- **Polymorphism**: Can pass PageRequest wherever Pageable is expected

```java
// PageRequest class hierarchy:
// PageRequest extends AbstractPageRequest implements Pageable

public void fetchPaginatedProducts(int pageNumber, int size) {
    // PageRequest implements Pageable interface
    Pageable pageable = PageRequest.of(pageNumber, size);
    
    // Repository method expects Pageable interface
    Page<Product> page = productRepository.findAll(pageable);
}
```

![PageRequest and Pageable](assets/pagerequest-pageable.png)

## Executing Paginated Queries

- **Repository method**: Use findAll(Pageable pageable) overload for paginated queries
- **Return type**: Returns Page<Entity> instead of List<Entity>
- **Page object**: Contains both data and pagination metadata
- **SQL generation**: Generates LIMIT/OFFSET clauses for database pagination

```java
public void fetchPaginatedProducts(int pageNumber, int size) {
    // Create pageable object
    Pageable pageable = PageRequest.of(pageNumber, size);
    
    // Execute paginated query - returns Page<Product>
    Page<Product> page = productRepository.findAll(pageable);
    
    // Page contains both data and metadata
    // Use page.getContent() to get actual products
}
```

![Executing Paginated Queries](assets/executing-paginated-queries.png)

## Working with Page Results

- **Page interface**: Import from org.springframework.data.domain.Page
- **Content extraction**: Use getContent() method to get List<Entity> from Page
- **Data access**: Page wraps the actual data with additional pagination information
- **Type safety**: Page<Entity> provides compile-time type checking

```java
public void fetchPaginatedProducts(int pageNumber, int size) {
    Pageable pageable = PageRequest.of(pageNumber, size);
    
    // Get page results
    Page<Product> page = productRepository.findAll(pageable);
    
    // Extract actual products from page
    List<Product> products = page.getContent();
    
    // Process products
    products.forEach(System.out::println);
}
```

![Working with Page Results](assets/working-with-page-results.png)

## Extracting Pagination Metadata

- **Metadata methods**: Page object provides methods for pagination information
- **Total pages**: getTotalPages() returns total number of pages available
- **Total elements**: getTotalElements() returns total number of records in database
- **Current page info**: Additional methods for current page number, size, etc.

```java
public void fetchPaginatedProducts(int pageNumber, int size) {
    Pageable pageable = PageRequest.of(pageNumber, size);
    Page<Product> page = productRepository.findAll(pageable);
    
    // Extract products
    List<Product> products = page.getContent();
    products.forEach(System.out::println);
    
    // Extract pagination metadata
    long totalPages = page.getTotalPages();
    long totalElements = page.getTotalElements();
    
    // Print pagination info
    System.out.println("Total pages: " + totalPages);
    System.out.println("Total products: " + totalElements);
    System.out.println("Current page: " + page.getNumber());
    System.out.println("Page size: " + page.getSize());
}
```

![Pagination Metadata](assets/pagination-metadata.png)

## Database-Specific SQL Generation

- **LIMIT clause**: MySQL uses LIMIT for pagination (other databases may differ)
- **Database abstraction**: Spring Data JPA generates appropriate SQL for target database
- **Engine dependency**: SQL syntax varies between MySQL, PostgreSQL, Oracle, SQL Server
- **Automatic translation**: Hibernate handles database-specific query generation

```java
// Example call
fetchPaginatedProducts(0, 10);  // First page, 10 records

// Generated SQL (MySQL):
// SELECT * FROM products LIMIT 10 OFFSET 0

// Generated SQL (PostgreSQL):
// SELECT * FROM products LIMIT 10 OFFSET 0

// Generated SQL (SQL Server):
// SELECT * FROM products ORDER BY id OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY
```

![Database-Specific SQL](assets/database-specific-sql.png)

![Generated Pagination SQL](assets/generated-pagination-sql.png)

## Key Points

- **Main takeaway**: Spring Data JPA provides built-in sorting and pagination capabilities through JpaRepository interface, eliminating the need for complex custom queries
- **Repository requirement**: Must extend JpaRepository (not CrudRepository) to access PagingAndSortingRepository methods for sorting and pagination
- **Sort objects**: Use Sort.by() with field names to create sort criteria, chain with and() for multi-column sorting with different directions
- **Pageable objects**: Use PageRequest.of() with zero-based page numbers and page size to create pagination parameters
- **Return types**: Sorted queries return List<Entity>, paginated queries return Page<Entity> with both data and metadata
- **Page interface**: Extract actual data with getContent(), access pagination metadata with getTotalPages() and getTotalElements()
- **SQL generation**: Spring Data JPA automatically generates appropriate ORDER BY and LIMIT/OFFSET clauses for target database
- **Performance benefits**: Database-level sorting and pagination provide better performance than application-level processing
- **Metadata access**: Page objects provide comprehensive pagination information including total pages, total elements, current page, and page size
- **Database portability**: Hibernate generates database-specific SQL syntax automatically, ensuring compatibility across different database engines

## Links/References

- Video: 4.10.4-Sorting-and-Pagination.mp4 (06:18)
- Previous: [Composable Queries Using Specifications API](4.10.3-Composable-Queries-Using-Specifications-API.md)
- Next: Combining Specifications with Sorting and Pagination
- Reference: [Spring Data JPA Pagination and Sorting](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.special-parameters)
- Reference: [Pageable and Sort Documentation](https://docs.spring.io/spring-data/commons/docs/current/api/)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

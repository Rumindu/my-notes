# Fetching Partial Data with Projections

<!-- omit from toc -->

## Table of Contents

- [Projections Overview](#projections-overview)
- [Performance Problem with Full Entity Fetching](#performance-problem-with-full-entity-fetching)
- [Creating a Basic Query Method](#creating-a-basic-query-method)
- [Testing Full Entity Retrieval](#testing-full-entity-retrieval)
- [Analyzing Generated SQL Queries](#analyzing-generated-sql-queries)
- [Creating Interface-Based Projections](#creating-interface-based-projections)
- [Defining Projection Interface Methods](#defining-projection-interface-methods)
- [Implementing Interface Projections](#implementing-interface-projections)
- [Understanding Proxy Objects](#understanding-proxy-objects)
- [Creating Class-Based Projections](#creating-class-based-projections)
- [Implementing Class Projections](#implementing-class-projections)
- [Projections with Custom @Query Methods](#projections-with-custom-query-methods)
- [Field Selection in JPQL Queries](#field-selection-in-jpql-queries)
- [Constructor Expressions in JPQL](#constructor-expressions-in-jpql)
- [Interface vs Class Projections Comparison](#interface-vs-class-projections-comparison)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Projections Overview

- **Selective data fetching**: Retrieve only specific columns instead of entire entities
- **Performance optimization**: Reduce memory usage and network traffic
- **Resource efficiency**: Avoid fetching unnecessary data from database
- **Query optimization**: Generate more targeted SQL statements

![Projections Overview](assets/projections-overview.png)

**Use cases for projections:**
- **Large entities**: Tables with many columns where only few are needed
- **API responses**: Return minimal data for client consumption
- **Performance-critical queries**: Optimize database and network resources
- **Reporting**: Extract specific fields for analysis or display

## Performance Problem with Full Entity Fetching

- **All columns selected**: Default repository methods fetch complete entities
- **Resource waste**: Unnecessary data transfer and memory consumption
- **Performance impact**: Slower queries and increased bandwidth usage
- **Scalability concerns**: Problems magnified with large datasets

![Performance Problem Full Entity](assets/performance-problem-full-entity.png)

**Example scenario:**
- **Large product table**: 20+ columns including large text fields
- **Simple query need**: Only product ID and name required
- **Current behavior**: All columns fetched unnecessarily
- **Performance cost**: Wasted database I/O and memory allocation

## Creating a Basic Query Method

- **Standard repository method**: Create derived query method for category filtering
- **Full entity return**: Method returns complete Product entities
- **Category parameter**: Filter products by category relationship
- **Method naming convention**: Follow standard Spring Data patterns

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Standard derived query method - returns full entities
    List<Product> findByCategory(Category category);
}
```

![Basic Query Method Creation](assets/basic-query-method-creation.png)

## Testing Full Entity Retrieval

- **Service method creation**: Add method to test entity retrieval
- **Category object construction**: Create category with ID constructor
- **Product iteration**: Print each product to observe behavior
- **Performance observation**: Monitor generated SQL queries

```java
@Service
public class UserService {
    
    public void fetchProducts() {
        // Create category object with ID
        var category = new Category((byte) 1);
        
        // Fetch products by category
        var products = productRepository.findByCategory(category);
        
        // Print each product
        products.forEach(System.out::println);
    }
}

// Category constructor addition
public class Category {
    public Category(Byte id) {
        this.id = id;
    }
}
```

![Testing Full Entity Retrieval](assets/testing-full-entity-retrieval.png)

## Analyzing Generated SQL Queries

- **Multiple queries generated**: Product query plus eager loading queries
- **All columns selected**: ID, category_id, description, name, price all fetched
- **Eager loading impact**: Additional queries for related entities
- **Performance overhead**: More data transfer than necessary

![Generated SQL Analysis](assets/generated-sql-analysis.png)

**SQL output example:**
```sql
-- Main product query - all columns selected
SELECT p.id, p.category_id, p.description, p.name, p.price 
FROM products p WHERE p.category_id = ?

-- Additional eager loading query
SELECT c.id, c.name FROM categories c WHERE c.id = ?
```

![SQL Query Output Example](assets/sql-query-output-example.png)

## Creating Interface-Based Projections

- **DTO package creation**: Organize projection classes in dedicated package
- **Interface approach**: Simpler syntax for basic projections
- **Naming convention**: Use descriptive names like ProductSummary
- **Method declaration**: Define getter methods for required fields

```java
// Create dtos package for data transfer objects
package com.codewithmosh.store.dtos;

// Interface-based projection
public interface ProductSummary {
    Long getId();
    String getName();
}
```

![Interface Based Projections](assets/interface-based-projections.png)

## Defining Projection Interface Methods

- **Getter method pattern**: Match entity getter method names exactly
- **Property mapping**: Spring maps interface methods to entity properties
- **Type matching**: Return types must match entity field types
- **Naming convention**: Follow standard JavaBean getter patterns

![Projection Interface Methods](assets/projection-interface-methods.png)

**Method mapping rules:**
- **getId()**: Maps to entity's getId() method
- **getName()**: Maps to entity's getName() method
- **Exact matching**: Method names must match entity getters precisely
- **Return types**: Must be compatible with entity property types

## Implementing Interface Projections

- **Repository modification**: Change return type to projection interface
- **Automatic mapping**: Spring Data JPA handles projection mapping
- **SQL optimization**: Only required columns selected in generated SQL
- **Eager loading elimination**: Related entity loading avoided when not needed

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Change return type to projection interface
    List<ProductSummary> findByCategory(Category category);
}
```

![Interface Projections Implementation](assets/interface-projections-implementation.png)

**Generated SQL with projection:**
```sql
-- Only required columns selected
SELECT p.id, p.name FROM products p WHERE p.category_id = ?
-- No additional eager loading queries
```

![Optimized SQL With Projection](assets/optimized-sql-projection.png)

## Understanding Proxy Objects

- **Runtime proxy generation**: Spring creates dynamic proxy implementations
- **Interface implementation**: Proxy objects implement projection interface
- **Default toString()**: Proxy objects have generic toString() output
- **Functional access**: Getter methods work normally despite proxy nature

![Proxy Objects Understanding](assets/proxy-objects-understanding.png)

**Proxy characteristics:**
- **Dynamic creation**: Generated at runtime by Spring framework
- **Interface compliance**: Implements all projection interface methods
- **Memory efficiency**: Only contains projected data fields
- **Type information**: Shows as proxy class in toString() output

## Creating Class-Based Projections

- **Class alternative**: Use classes instead of interfaces for projections
- **Additional benefits**: Can encapsulate business logic and methods
- **Field declaration**: Define private fields for projected data
- **Constructor requirement**: Need all-args constructor for field initialization

```java
package com.codewithmosh.store.dtos;

@Getter
@AllArgsConstructor
public class ProductSummaryDetail {
    private Long id;
    private String name;
    
    // Can add additional methods and logic here
    public String getDisplayName() {
        return "Product: " + name;
    }
}
```

![Class Based Projections](assets/class-based-projections.png)

## Implementing Class Projections

- **Repository update**: Change return type to projection class
- **Automatic instantiation**: Spring creates class instances with projected data
- **Constructor injection**: Data injected via all-args constructor
- **Enhanced toString()**: Class-based projections have better string representation

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Use class-based projection
    List<ProductSummaryDetail> findByCategory(Category category);
}
```

![Class Projections Implementation](assets/class-projections-implementation.png)

## Projections with Custom @Query Methods

- **Custom query compatibility**: Projections work with @Query annotation
- **JPQL extraction**: Convert derived methods to custom queries
- **Initial behavior**: Custom queries fetch full entities by default
- **Explicit selection**: Must specify fields to project in JPQL

```java
@Query("SELECT p FROM Product p WHERE p.category.id = :categoryId")
List<ProductSummary> findByCategory(@Param("categoryId") Byte categoryId);
```

![Projections Custom Query Methods](assets/projections-custom-query-methods.png)

**Initial custom query problem:**
- **Full entity selection**: `SELECT p FROM Product p` fetches all columns
- **Eager loading persists**: Related entities still loaded eagerly
- **No optimization**: Projection return type doesn't affect SQL generation

## Field Selection in JPQL Queries

- **Explicit field selection**: Specify individual fields in SELECT clause
- **Property references**: Use entity property names with dot notation
- **Optimization achieved**: Only selected fields fetched from database
- **Eager loading avoided**: Related entities not loaded automatically

```java
@Query("SELECT p.id, p.name FROM Product p WHERE p.category.id = :categoryId")
List<ProductSummary> findByCategory(@Param("categoryId") Byte categoryId);
```

![Field Selection JPQL](assets/field-selection-jpql.png)

**Optimized JPQL benefits:**
- **Selective fetching**: Only id and name columns selected
- **No eager loading**: Category entities not automatically fetched
- **Better performance**: Reduced data transfer and memory usage
- **Interface compatibility**: Works seamlessly with projection interfaces

## Constructor Expressions in JPQL

- **Class projection requirement**: Classes need constructor expressions in JPQL
- **NEW keyword**: Required for instantiating projection classes
- **Fully qualified names**: Must use complete package path for class
- **Constructor parameters**: Pass selected fields as constructor arguments

```java
@Query("SELECT NEW com.codewithmosh.store.dtos.ProductSummaryDetail(p.id, p.name) " +
       "FROM Product p WHERE p.category.id = :categoryId")
List<ProductSummaryDetail> findByCategory(@Param("categoryId") Byte categoryId);
```

![Constructor Expressions JPQL](assets/constructor-expressions-jpql.png)

**Constructor expression syntax:**
- **NEW keyword**: Required prefix for class instantiation
- **Full package path**: Complete class name including package
- **Parameter matching**: Constructor arguments must match class constructor
- **Type compatibility**: Parameter types must match constructor parameter types

## Interface vs Class Projections Comparison

- **Interface advantages**: Simpler syntax, automatic proxy generation, less verbose
- **Class advantages**: Can encapsulate logic, better toString(), explicit constructors
- **JPQL complexity**: Classes require constructor expressions, interfaces work directly
- **Use case guidance**: Use interfaces for simple projections, classes for logic encapsulation

![Interface vs Class Comparison](assets/interface-vs-class-comparison.png)

**Comparison summary:**

| Aspect          | Interface Projections   | Class Projections               |
| --------------- | ----------------------- | ------------------------------- |
| **Syntax**      | Simple getter methods   | Fields + constructor            |
| **JPQL**        | Direct field selection  | Constructor expressions         |
| **Logic**       | Cannot add methods      | Can encapsulate business logic  |
| **Performance** | Slightly faster (proxy) | Slightly slower (instantiation) |
| **Maintenance** | Easier to maintain      | More verbose but explicit       |

## Key Points

- **Main takeaway**: Projections allow fetching only specific fields instead of complete entities, significantly improving performance and reducing resource usage
- **Interface projections**: Simpler syntax with getter methods that map to entity properties, automatically handled by Spring with proxy objects
- **Class projections**: Enable encapsulation of business logic but require explicit constructors and more verbose JPQL syntax
- **SQL optimization**: Projections generate targeted SELECT statements with only required columns, eliminating unnecessary data transfer
- **Eager loading elimination**: Projections prevent automatic loading of related entities, reducing query complexity
- **Custom query compatibility**: Works with both derived query methods and @Query annotations, but custom queries need explicit field selection
- **JPQL considerations**: Interface projections work with simple field selection, while class projections require NEW constructor expressions
- **Performance benefits**: Particularly valuable for large entities or high-volume queries where bandwidth and memory matter
- **Package organization**: Use dedicated DTO packages to organize projection interfaces and classes
- **Best practice**: Use interface projections for simple data transfer, class projections when additional logic is needed

## Links/References

- Video: 4.9.3-Fetching-Partial-Data-with-Projections.mp4 (08:08)
- Previous: [Writing Custom Queries Using @Query](4.9.2-Writing-Custom-Queries-Using-_Query.md)
- Next: Dynamic Queries with Specifications
- Reference: [Spring Data JPA Projections](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#projections)
- Reference: [JPQL Constructor Expressions](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage005.htm)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

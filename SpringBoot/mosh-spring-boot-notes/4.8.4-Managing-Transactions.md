# Managing Transactions

<!-- omit from toc -->

## Table of Contents

- [Table of Contents](#table-of-contents)
- [What is a Transaction](#what-is-a-transaction)
- [Transaction Use Cases](#transaction-use-cases)
- [Repository Method Transactions](#repository-method-transactions)
- [Transaction Boundaries](#transaction-boundaries)
- [Creating Service Layer](#creating-service-layer)
- [Entity Manager Introduction](#entity-manager-introduction)
- [Testing Entity States](#testing-entity-states)
- [Bean Configuration Issues](#bean-configuration-issues)
- [Understanding Transaction Scope](#understanding-transaction-scope)
- [Changing Transaction Boundaries](#changing-transaction-boundaries)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## What is a Transaction

- **Definition**: Group of operations that either all succeed together or all fail together
- **Consistency purpose**: Keep system in consistent state during operations
- **Atomic nature**: Operations are indivisible - cannot split like atoms
- **Persistence context connection**: Transaction lifetime determines persistence context lifetime

![Transaction Concept Diagram](assets/transaction-concept-diagram.png)

**Transaction characteristics:**
- **All or nothing**: Complete success or complete failure
- **Data consistency**: Prevents partial updates that leave system in invalid state
- **Isolation**: Operations within transaction isolated from other concurrent operations
- **Durability**: Committed changes persist even after system failures

## Transaction Use Cases

- **E-commerce example**: Order placement requires multiple coordinated operations
- **Order creation**: Insert new order record in orders table
- **Stock update**: Reduce inventory quantity for purchased items
- **Business requirement**: Both operations must succeed or both must fail
- **Real-world scenario**: Cannot have order without stock reduction or vice versa

```java
// Example: Order placement transaction
// Both operations must succeed together
public void placeOrder(Order order, Product product) {
    orderRepository.save(order);        // Operation 1
    productRepository.updateStock(product.getId(), -1);  // Operation 2
    // If either fails, both should be rolled back
}
```

![E-commerce Transaction Example](assets/ecommerce-transaction-example.png)

**Critical operations requiring transactions:**
- **Financial transfers**: Debit from one account, credit to another
- **Order processing**: Create order, update inventory, charge payment
- **User registration**: Create user, send email, create profile
- **Data migrations**: Multiple table updates that must remain consistent

## Repository Method Transactions

- **Built-in transactions**: Repository methods (find, save, delete) are automatically transactional
- **Individual transactions**: Each repository method call creates separate transaction
- **Persistence context scope**: Each transaction has its own persistence context
- **Method boundary**: Transaction starts when method called, ends when method completes

![Repository Method Transactions](assets/repository-method-transactions.png)

**Example of separate transactions:**
```java
var user = repository.findById(1L);  // Transaction 1 with Persistence Context 1
repository.delete(user);             // Transaction 2 with Persistence Context 2
```

![Separate Transaction Example](assets/separate-transaction-example.png)

**Implications of separate transactions:**
- **Multiple persistence contexts**: Each method gets separate context
- **Entity state changes**: Entities become detached between method calls
- **Performance impact**: Multiple database connections and commits
- **Consistency challenges**: Intermediate states visible to other transactions

## Transaction Boundaries

- **Default boundaries**: Each repository method has its own transaction boundary
- **Boundary modification**: Can change boundaries using @Transactional annotation
- **Method-level control**: Apply @Transactional to encompass multiple operations
- **Service layer usage**: Typically applied at service method level for business operations

![Transaction Boundary Modification](assets/transaction-boundary-modification.png)

**@Transactional annotation benefits:**
- **Single transaction**: Multiple operations within one transaction
- **Extended persistence context**: Entities remain managed longer
- **Better performance**: Fewer database commits and connections
- **Stronger consistency**: All operations succeed or fail together

## Creating Service Layer

- **Package organization**: Create dedicated services package for business logic
- **Service class**: UserService class to demonstrate transaction management
- **Demonstration purpose**: Not covering full service layer concepts yet
- **Static method limitation**: Cannot apply @Transactional to static methods like main()

```java
// Create services package and UserService class
package com.store.services;

@Service  // Bean annotation required
public class UserService {
    
    public void showEntityStates() {
        // Method to demonstrate entity state transitions
    }
}
```

![Service Class Creation](assets/service-class-creation.png)

**Service layer structure:**
- **Business logic**: Contains application business rules
- **Transaction management**: Manages transaction boundaries
- **Repository coordination**: Orchestrates multiple repository operations
- **Bean management**: Requires proper Spring annotations

## Entity Manager Introduction

- **JPA interface**: EntityManager is core JPA interface for entity management
- **Jakarta persistence**: Part of Jakarta Persistence (formerly JPA) specification
- **Hibernate implementation**: Hibernate provides EntityManager implementation
- **Persistence context access**: Provides direct access to persistence context operations

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final EntityManager entityManager;  // JPA EntityManager
    
    // Constructor injection for dependencies
    public UserService(UserRepository userRepository, EntityManager entityManager) {
        this.userRepository = userRepository;
        this.entityManager = entityManager;
    }
}
```

![Entity Manager Integration](assets/entity-manager-integration.png)

**EntityManager capabilities:**
- **Entity containment**: Check if entity exists in persistence context
- **Direct persistence**: Persist, merge, remove entities directly
- **Query execution**: Execute JPQL and native SQL queries
- **Transaction management**: Access to underlying transaction operations

## Testing Entity States

- **Entity creation**: Create user object using builder pattern
- **State checking**: Use EntityManager.contains() to check persistence context
- **Before save**: Entity should be in transient state (not in context)
- **After save**: Entity state depends on transaction boundary

```java
public void showEntityStates() {
    var user = User.builder()
        .name("John")
        .email("john@example.com")
        .password("password123")
        .build();
    
    // Check entity state before save
    if (entityManager.contains(user)) {
        System.out.println("Persistent");
    } else {
        System.out.println("Transient or Detached");
    }
    
    userRepository.save(user);
    
    // Check entity state after save
    if (entityManager.contains(user)) {
        System.out.println("Persistent");
    } else {
        System.out.println("Transient or Detached");
    }
}
```

![Entity State Testing Code](assets/entity-state-testing-code.png)

## Bean Configuration Issues

- **Bean definition error**: "No such bean definition" exception occurs
- **Missing annotation**: Service class needs @Service or @Component annotation
- **Spring context**: Spring cannot create bean without proper annotation
- **Bean discovery**: Spring scans for annotated classes during startup

![Bean Configuration Error](assets/bean-configuration-error.png)

**Solution - Add service annotation:**
```java
@Service  // Required for Spring bean creation
public class UserService {
    // Class implementation
}
```

![Service Annotation Fix](assets/service-annotation-fix.png)

**Spring stereotype annotations:**
- **@Service**: Business service components
- **@Repository**: Data access components
- **@Controller**: Web controller components
- **@Component**: General purpose components

## Understanding Transaction Scope

- **Repository method scope**: Transaction active only during repository method execution
- **Context cleanup**: Persistence context cleared when transaction ends
- **Entity detachment**: Entities become detached after transaction completion
- **Timing impact**: Understanding timing crucial for entity state management

![Transaction Scope Timeline](assets/transaction-scope-timeline.png)

**Without @Transactional output:**
```
Transient or Detached  // Before save
Transient or Detached  // After save (entity detached after transaction)
```

![Entity State Output Without Transactional](assets/entity-state-output-without-transactional.png)

**Why entity remains detached:**
1. **Initial state**: Entity created in transient state
2. **Save operation**: Repository.save() creates temporary transaction
3. **Transaction completion**: Transaction ends, persistence context cleared
4. **Entity detachment**: Entity becomes detached after context cleanup

## Changing Transaction Boundaries

- **@Transactional annotation**: Applied to method to extend transaction boundary
- **Jakarta persistence**: Import from Jakarta persistence package
- **Method-level transaction**: Entire method execution within single transaction
- **Extended persistence context**: Context remains active throughout method execution

```java
import jakarta.transaction.Transactional;

@Service
public class UserService {
    
    @Transactional  // Extends transaction to entire method
    public void showEntityStates() {
        // All operations within single transaction
        var user = User.builder()
            .name("John")
            .email("john@example.com")
            .password("password123")
            .build();
        
        // Entity state checking...
        userRepository.save(user);
        // Entity remains persistent until method completes
    }
}
```

![Transactional Annotation Implementation](assets/transactional-annotation-implementation.png)

**With @Transactional output:**
```
Transient or Detached  // Before save
Persistent             // After save (entity remains in context)
```

![Entity State Output With Transactional](assets/entity-state-output-with-transactional.png)

**Transaction boundary benefits:**
- **Single transaction**: All operations within one database transaction
- **Extended context**: Persistence context active throughout method
- **Entity management**: Entities remain managed and tracked
- **Performance improvement**: Fewer database connections and commits

## Key Points

- **Main takeaway**: Transactions group operations for atomic execution, ensuring all succeed or fail together to maintain system consistency
- **Transaction scope**: Repository methods are individually transactional by default, creating separate persistence contexts for each operation
- **@Transactional annotation**: Extends transaction boundaries to encompass entire methods, keeping persistence context active longer
- **Entity state management**: Transaction boundaries directly affect entity states - entities become detached when transactions end
- **Service layer necessity**: Business logic requiring multiple repository operations should use service layer with proper transaction management
- **EntityManager usage**: Provides direct access to persistence context for checking entity containment and state
- **Bean configuration**: Service classes require Spring annotations (@Service, @Component) for proper bean creation and dependency injection
- **Jakarta persistence**: @Transactional annotation comes from Jakarta persistence package, not Spring
- **Real-world applications**: E-commerce scenarios like order placement demonstrate critical need for transaction management
- **Performance considerations**: Proper transaction boundaries improve performance by reducing database connections and ensuring data consistency

## Links/References

- Video: 4.8.4-Managing-Transactions.mp4 (07:03)
- Previous: [Understanding Entity States](4.8.3-Understanding-Entity-States.md)
- Next: Advanced Transaction Management
- Reference: [Spring Transaction Management](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction)
- Reference: [Jakarta Persistence Transactions](https://jakarta.ee/specifications/persistence/3.0/apidocs/jakarta.persistence/jakarta/persistence/package-summary.html)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

# Exercise: Creating the Profiles and Tags Tables

<!-- omit from toc -->

## Table of Contents

- [Exercise Overview](#exercise-overview)
- [Database Extension Requirements](#database-extension-requirements)
- [Profiles Table Design](#profiles-table-design)
  - [Table Structure Requirements](#table-structure-requirements)
  - [One-to-One Relationship](#one-to-one-relationship)
  - [Column Specifications](#column-specifications)
- [Tags Table Design](#tags-table-design)
  - [Tags Table Structure](#tags-table-structure)
  - [Many-to-Many Relationship](#many-to-many-relationship)
  - [Join Table Implementation](#join-table-implementation)
- [Exercise Instructions](#exercise-instructions)
- [Solution Implementation](#solution-implementation)
  - [Migration V4: Profiles Table](#migration-v4-profiles-table)
  - [Migration V5: Tags and User Tags Tables](#migration-v5-tags-and-user-tags-tables)
- [Running the Migrations](#running-the-migrations)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Exercise Overview

- **Database extension**: Add more tables to existing database schema
- **Current state**: Only users and addresses tables implemented
- **New requirements**: Add profiles and tags functionality
- **Migration approach**: Create separate migrations for each table group

![Database Extension Overview](assets/database-extension-overview.png)

**Exercise objectives:**
- Practice creating database migrations
- Implement one-to-one relationships
- Create many-to-many relationships with join tables
- Apply relational database design concepts

## Database Extension Requirements

- **Starting point**: Users table already exists
- **Two new migrations**: Separate migration files for profiles and tags
- **Relationship implementation**: One-to-one and many-to-many relationships
- **Time allocation**: Approximately 20 minutes for completion

![Current Database Schema](assets/current-database-schema.png)

**Extension scope:**
- Profiles table with user relationship
- Tags table with many-to-many user association
- Proper foreign key constraints
- Default values and data type considerations

## Profiles Table Design

### Table Structure Requirements

- **Table name**: `profiles`
- **Relationship**: One-to-one with users table
- **Primary key**: Uses same ID value as corresponding user
- **Optional data**: All columns except ID are nullable

![Profiles Table Design Diagram](assets/profiles-table-design-diagram.png)

**Column requirements:**
- ID (primary key, foreign key to users)
- Bio (text field)
- Phone number (varchar)
- Date of birth (date type)
- Loyalty points (unsigned integer with default)

### One-to-One Relationship

- **Relationship type**: Each user has exactly one profile
- **Profile ownership**: Each profile belongs to exactly one user
- **ID sharing**: Profile ID matches corresponding user ID
- **Population process**: Create user first, then create profile with same ID

![One-to-One Relationship Diagram](assets/one-to-one-relationship-diagram.png)

**Implementation approach:**
1. Create user record (auto-increment generates ID)
2. Use generated user ID for profile record
3. Foreign key constraint ensures referential integrity

### Column Specifications

- **ID column**: `BIGINT` to match users table, primary key and foreign key
- **Bio column**: `TEXT` for longer biographical information
- **Phone number**: `VARCHAR(15)` - shorter length for practical phone numbers
- **Date of birth**: `DATE` type (no time component needed)
- **Loyalty points**: `INT UNSIGNED` with default value of 0

![Profiles Table Column Specifications](assets/profiles-table-column-specifications.png)

**Design considerations:**
- All columns nullable except ID
- Consistent data types with related tables
- Practical field lengths for phone numbers
- Appropriate data types for each field's purpose

## Tags Table Design

### Tags Table Structure

- **Table name**: `tags`
- **Columns**: ID (primary key) and name
- **ID type**: `INT AUTO_INCREMENT` for tag identification
- **Name field**: `VARCHAR(255)` for tag names

![Tags Table Structure](assets/tags-table-structure.png)

### Many-to-Many Relationship

- **Relationship type**: Users can have multiple tags, tags can apply to multiple users
- **Join table required**: Many-to-many relationships need intermediate table
- **Business logic**: Flexible tagging system for user categorization

![Many-to-Many Relationship Diagram](assets/many-to-many-relationship-diagram.png)

### Join Table Implementation

- **Table name**: `user_tags`
- **Composite primary key**: Both user_id and tag_id columns
- **Foreign keys**: References to both users and tags tables
- **Cascade delete**: Remove user_tags records when parent records deleted

![Join Table Implementation](assets/join-table-implementation.png)

**Join table features:**
- Composite primary key prevents duplicate associations
- Foreign key constraints ensure data integrity
- ON DELETE CASCADE for automatic cleanup

## Exercise Instructions

- **Migration 1**: Create profiles table with one-to-one relationship
- **Migration 2**: Create tags table and user_tags join table
- **Implementation freedom**: Use visual tools, ChatGPT, or hand-coding
- **Time limit**: 20 minutes for both migrations
- **Prerequisites**: Basic relational database knowledge required

![Exercise Instructions Overview](assets/exercise-instructions-overview.png)

**Recommended approach:**
1. Design profiles table structure
2. Create first migration file
3. Design tags and join table structure
4. Create second migration file
5. Test migrations

## Solution Implementation

### Migration V4: Profiles Table

```sql
-- V4__create_profiles_table.sql
CREATE TABLE profiles (
    id BIGINT NOT NULL,
    bio TEXT,
    phone_number VARCHAR(15),
    date_of_birth DATE,
    loyalty_points INT UNSIGNED DEFAULT 0,
    PRIMARY KEY (id),
    CONSTRAINT fk_profiles_user_id FOREIGN KEY (id) REFERENCES users (id)
);
```

![Profiles Table Migration SQL](assets/profiles-table-migration-sql.png)

**Implementation details:**
- **ID column**: `BIGINT` matching users table, no AUTO_INCREMENT
- **Bio**: `TEXT` type for longer content
- **Phone number**: `VARCHAR(15)` for practical phone number length
- **Date of birth**: `DATE` type without time component
- **Loyalty points**: `INT UNSIGNED DEFAULT 0` ensures positive values
- **Foreign key**: References users table ID column

### Migration V5: Tags and User Tags Tables

```sql
-- V5__create_tags_and_user_tags_tables.sql

-- Create tags table
CREATE TABLE tags (
    id INT AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    PRIMARY KEY (id)
);

-- Create join table for many-to-many relationship
CREATE TABLE user_tags (
    user_id BIGINT NOT NULL,
    tag_id INT NOT NULL,
    PRIMARY KEY (user_id, tag_id),
    CONSTRAINT fk_user_tags_user_id FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
    CONSTRAINT fk_user_tags_tag_id FOREIGN KEY (tag_id) REFERENCES tags (id) ON DELETE CASCADE
);
```

![Tags Migration SQL Implementation](assets/tags-migration-sql-implementation.png)

**Implementation features:**
- **Tags table**: Simple structure with auto-increment ID
- **Composite primary key**: Prevents duplicate user-tag associations
- **Foreign key constraints**: Ensure referential integrity
- **CASCADE delete**: Automatic cleanup when parent records deleted

![User Tags Join Table Structure](assets/user-tags-join-table-structure.png)

## Running the Migrations

- **Maven execution**: Use Maven tool window to run migrate command
- **Migration application**: Flyway applies both new migrations sequentially
- **Database verification**: Check database to confirm new tables created

![Migration Execution Process](assets/migration-execution-process.png)

**Execution steps:**
1. Open Maven tool window
2. Navigate to flyway plugin
3. Double-click migrate command
4. Verify successful execution

![Database After Migration](assets/database-after-migration.png)

**Expected results:**
- Total of 6 tables in database
- Profiles table with foreign key to users
- Tags table with basic structure
- User_tags join table with composite key
- All foreign key constraints properly configured

## Key Points

- **Main takeaway**: Database schema extension requires careful planning of relationships and proper migration file organization for maintainable database evolution
- **One-to-one implementation**: Profiles table uses shared primary key approach where profile ID matches user ID for direct relationship
- **Many-to-many complexity**: Tags implementation requires join table with composite primary key and dual foreign key constraints
- **Migration separation**: Using separate migration files for different table groups provides better organization and easier maintenance
- **Data type consistency**: Matching data types between related tables (BIGINT for IDs) ensures proper foreign key relationships
- **Nullable design**: Optional profile fields allow flexible user data without forcing complete information entry
- **Cascade deletion**: ON DELETE CASCADE in join table ensures automatic cleanup when parent records are removed
- **Implementation flexibility**: Solution can be created using visual tools, AI assistance, or manual SQL coding based on developer preference
- **Prerequisites importance**: Solid understanding of relational database concepts essential for Spring Boot database integration
- **Testing verification**: Running migrations and verifying table structure confirms proper implementation before proceeding

## Links/References

- Video: 4.6.5-Exercise-Creating-the-Profiles_-and-Tags-Tables.mp4 (04:55)
- Prerequisite: MySQL Course (for relational database concepts)
- Previous: [Running Migrations Using Maven](4.6.4-Running-Migrations-Using-Maven.md)
- Next: Domain Model Creation

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

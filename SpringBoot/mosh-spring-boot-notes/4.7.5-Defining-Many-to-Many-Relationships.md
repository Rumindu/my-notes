# Defining Many-to-Many Relationships

<!-- omit from toc -->

## Table of Contents

- [Many-to-Many Relationship Overview](#many-to-many-relationship-overview)
- [Implementing the User Side](#implementing-the-user-side)
- [Implementing the Tag Side](#implementing-the-tag-side)
- [Understanding Join Tables](#understanding-join-tables)
- [Configuring the Owning Side](#configuring-the-owning-side)
- [Configuring the Non-Owning Side](#configuring-the-non-owning-side)
- [Creating Tag Objects](#creating-tag-objects)
- [Testing the Relationship](#testing-the-relationship)
- [Creating Helper Methods](#creating-helper-methods)
- [Builder Pattern Issues](#builder-pattern-issues)
- [ToString Implementation](#tostring-implementation)
- [Avoiding Circular References](#avoiding-circular-references)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Many-to-Many Relationship Overview

- **Relationship type**: Many-to-Many between User and Tag entities
- **Business rule**: A user can have many tags, and a tag can belong to many users
- **Collection choice**: Use Set instead of List to prevent duplicate tags
- **Join table**: Requires intermediate table to store relationships

![Many-to-Many Relationship Diagram](assets/many-to-many-relationship-diagram.png)

**Set vs List comparison:**
- **Set interface**: Prevents duplicate objects (no duplicate tags per user)
- **List interface**: Allows duplicates (used for one-to-many relationships)
- **HashSet implementation**: Efficient duplicate prevention
- **Business logic**: Users shouldn't have duplicate tags

## Implementing the User Side

- **Collection field**: Add Set<Tag> field to User entity
- **Set initialization**: Initialize with new HashSet() for immediate use
- **Import requirement**: Import Set from java.util package
- **Annotation**: Use @ManyToMany with @JoinTable for relationship mapping

```java
@Entity
@Table(name = "users")
public class User {
    // Other fields...
    
    @ManyToMany
    @JoinTable(
        name = "user_tags",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "tag_id")
    )
    private Set<Tag> tags = new HashSet<>();
    
    // Other methods...
}
```

![User Entity Many-to-Many Implementation](assets/user-entity-many-to-many-implementation.png)

**Implementation steps:**
1. Add private Set<Tag> tags field
2. Initialize with new HashSet()
3. Import Tag entity from entities package
4. Apply @ManyToMany annotation
5. Configure @JoinTable with join columns

## Implementing the Tag Side

- **Reference field**: Add Set<User> field to Tag entity
- **Set initialization**: Initialize with new HashSet() for consistency
- **Annotation**: Use @ManyToMany with mappedBy attribute
- **Non-owning side**: References the owning field name

```java
@Entity
@Table(name = "tags")
public class Tag {
    // Other fields...
    
    @ManyToMany(mappedBy = "tags")
    private Set<User> users = new HashSet<>();
    
    // Other methods...
}
```

![Tag Entity Many-to-Many Implementation](assets/tag-entity-many-to-many-implementation.png)

**Implementation details:**
- **@ManyToMany**: Defines many tags to many users relationship
- **mappedBy**: References "tags" field in User entity
- **Set<User>**: Collection of users associated with this tag
- **Bidirectional**: Allows navigation in both directions

## Understanding Join Tables

- **Join table purpose**: Stores many-to-many relationships between entities
- **Table structure**: Contains foreign keys from both related tables
- **Flexibility**: Either entity can be designated as relationship owner
- **Database design**: user_tags table with user_id and tag_id columns

![Join Table Structure Diagram](assets/join-table-structure-diagram.png)

**Join table characteristics:**
- **Table name**: user_tags (conventional naming)
- **Foreign keys**: user_id references users.id, tag_id references tags.id
- **No additional columns**: Pure relationship storage
- **Ownership choice**: Either User or Tag can own the relationship

## Configuring the Owning Side

- **Owner selection**: User entity chosen as relationship owner
- **@JoinTable annotation**: Replaces @JoinColumn for many-to-many relationships
- **Join columns**: Specify foreign key columns in join table
- **Inverse join columns**: Specify foreign keys for the other entity

```java
@ManyToMany
@JoinTable(
    name = "user_tags",                           // Join table name
    joinColumns = @JoinColumn(name = "user_id"),  // FK to users table
    inverseJoinColumns = @JoinColumn(name = "tag_id") // FK to tags table
)
private Set<Tag> tags = new HashSet<>();
```

![JoinTable Annotation Configuration](assets/join-table-annotation-configuration.png)

**@JoinTable attributes:**
- **name**: Name of the join table ("user_tags")
- **joinColumns**: Foreign key referencing owner entity (user_id)
- **inverseJoinColumns**: Foreign key referencing other entity (tag_id)
- **Column naming**: Follow underscore convention for foreign keys

## Configuring the Non-Owning Side

- **MappedBy attribute**: References the owning field name from User entity
- **Field reference**: "tags" is the field name in User entity
- **No join table**: Non-owning side doesn't specify join table details
- **Relationship navigation**: Allows bidirectional access

```java
@ManyToMany(mappedBy = "tags")  // "tags" is field name in User entity
private Set<User> users = new HashSet<>();
```

![MappedBy Configuration Many-to-Many](assets/mappedby-configuration-many-to-many.png)

**Non-owning side characteristics:**
- **Simpler annotation**: Only @ManyToMany with mappedBy
- **Field name reference**: Must match exact field name in owning entity
- **No table configuration**: Join table defined on owning side only
- **Bidirectional access**: Enables Tag â†’ Users navigation

## Creating Tag Objects

- **Simple constructor**: Tag objects need only name parameter
- **Constructor generation**: Use IDE to generate constructor for name field
- **JPA requirement**: Add @NoArgsConstructor for JPA compliance
- **Minimal entity**: Tag has simple structure with ID and name

```java
@Entity
@Table(name = "tags")
@NoArgsConstructor  // Required for JPA
public class Tag {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    // Constructor for name
    public Tag(String name) {
        this.name = name;
    }
    
    // Other methods...
}
```

![Tag Constructor Implementation](assets/tag-constructor-implementation.png)

**Constructor requirements:**
- **Name parameter**: Primary constructor takes String name
- **No-args constructor**: @NoArgsConstructor for JPA compatibility
- **IDE generation**: Use "Generate Constructor" for name field
- **Error resolution**: Fixes "should have no-arg constructor" warning

## Testing the Relationship

- **Object creation**: Create User and Tag objects to test relationship
- **Manual wiring**: Connect objects using collection operations
- **Two-step process**: Add tag to user's collection, add user to tag's collection
- **Relationship integrity**: Both sides must be updated manually

```java
@SpringBootApplication
public class StoreApplication {
    public static void main(String[] args) {
        var user = User.builder()
            .name("John")
            .email("john@example.com")
            .password("password123")
            .build();
            
        var tag = new Tag("tag1");
        
        // Manual wiring (before helper methods)
        user.getTags().add(tag);
        tag.getUsers().add(user);
        
        System.out.println(user);
        
        SpringApplication.run(StoreApplication.class, args);
    }
}
```

![Many-to-Many Testing Code](assets/many-to-many-testing-code.png)

## Creating Helper Methods

- **Encapsulation**: Group related operations in helper methods
- **API design choice**: Pass String parameter and create Tag internally
- **Relationship integrity**: Ensure both sides are updated simultaneously
- **Code simplification**: Single method call replaces multiple operations

```java
@Entity
@Table(name = "users")
public class User {
    // Fields...
    
    public void addTag(String tagName) {
        var tag = new Tag(tagName);
        tags.add(tag);
        tag.getUsers().add(this);
    }
    
    // removeTag method left as exercise
    public void removeTag(Tag tag) {
        tags.remove(tag);
        tag.getUsers().remove(this);
    }
}
```

![Helper Method Implementation Many-to-Many](assets/helper-method-implementation-many-to-many.png)

**Helper method benefits:**
- **Parameter choice**: String parameter for tag name simplicity
- **Object creation**: Method handles Tag object creation internally
- **Relationship maintenance**: Both collections updated automatically
- **API consistency**: Follows same pattern as address helper methods

**Usage simplification:**
```java
// Before helper method
user.getTags().add(tag);
tag.getUsers().add(user);

// After helper method
user.addTag("tag1");
```

![Helper Method Usage Comparison](assets/helper-method-usage-comparison.png)

## Builder Pattern Issues

- **Initialization problem**: Builder pattern skips field initializations again
- **Null pointer exception**: Occurs when accessing uninitialized Set collections
- **Same solution**: Use @Builder.Default annotation for Set fields
- **Consistency**: Same issue as with List collections in one-to-many

```java
@Entity
@Table(name = "users")
public class User {
    @ManyToMany
    @JoinTable(
        name = "user_tags",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "tag_id")
    )
    @Builder.Default  // Ensures Set initialization with builder pattern
    private Set<Tag> tags = new HashSet<>();
}
```

![Builder Default Set Collection](assets/builder-default-set-collection.png)

**Builder pattern solutions:**
- **@Builder.Default**: Include field initialization in builder
- **Remove builder**: Alternative solution for critical initializations
- **Consistent pattern**: Same fix needed for all collection fields

## ToString Implementation

- **Debugging aid**: Apply @ToString to Tag entity for better output
- **Object inspection**: See tag details in console output
- **Development tool**: Helps understand object relationships during testing
- **Lombok generation**: Automatically includes all fields in string representation

```java
@ToString
@Entity
@Table(name = "tags")
public class Tag {
    // Fields and methods...
}
```

![ToString Tag Implementation](assets/tostring-tag-implementation.png)

**ToString output improvement:**
```
// Before @ToString on Tag
User(tags=[com.example.entities.Tag@4a6c5bbc])

// After @ToString on Tag
User(tags=[Tag(id=null, name=tag1, users=[...])])
```

![ToString Output Improvement](assets/tostring-output-improvement.png)

## Avoiding Circular References

- **Circular reference problem**: Same issue as one-to-many relationships
- **Stack overflow**: Bidirectional relationships create infinite loops
- **Solution**: Exclude back-reference field from toString
- **Strategic exclusion**: Remove users field from Tag's toString

```java
@ToString
@Entity
@Table(name = "tags")
public class Tag {
    // Other fields included in toString...
    
    @ToString.Exclude  // Prevent circular reference
    @ManyToMany(mappedBy = "tags")
    private Set<User> users = new HashSet<>();
}
```

![ToString Exclude Many-to-Many](assets/tostring-exclude-many-to-many.png)

**Circular reference prevention:**
- **@ToString.Exclude**: Excludes users field from string representation
- **Loop breaking**: Prevents User â†’ Tag â†’ User â†’ Tag infinite loop
- **Clean output**: Maintains readable debugging information
- **Consistent pattern**: Same solution as one-to-many relationships

## Key Points

- **Main takeaway**: Many-to-many relationships require join tables and can be owned by either entity, with Set collections preventing duplicate associations
- **Collection choice**: Use Set instead of List to prevent duplicate relationships and ensure business rule compliance
- **Join table configuration**: @JoinTable annotation on owning side specifies join table name and foreign key columns for both entities
- **Ownership flexibility**: Either entity can own many-to-many relationships since join table contains foreign keys for both entities
- **Helper methods**: Encapsulate relationship management in methods like addTag() to ensure both sides of bidirectional relationship are updated
- **Parameter design**: Helper methods can accept simple parameters (String) and handle object creation internally for cleaner APIs
- **Builder pattern consistency**: Same @Builder.Default solution needed for Set collections as with List collections in one-to-many relationships
- **Circular references**: Bidirectional many-to-many relationships create same toString() circular reference issues as one-to-many relationships
- **Constructor requirements**: Entity classes need both parameterized constructors for business logic and no-arg constructors for JPA compliance
- **Relationship integrity**: Always update both sides of bidirectional relationships to maintain data consistency and proper object state

## Links/References

- Video: 4.7.5-Defining-Many-to-Many-Relationships.mp4 (07:36)
- Previous: [Defining One-To-Many Relationships](4.7.4-Defining-One-To-Many-Relationships.md)
- Next: One-To-One Relationships
- Reference: [JPA ManyToMany Annotation](https://docs.oracle.com/javaee/7/api/javax/persistence/ManyToMany.html)
- Reference: [JPA JoinTable Annotation](https://docs.oracle.com/javaee/7/api/javax/persistence/JoinTable.html)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

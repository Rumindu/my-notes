# Efficiently Loading Entities with @EntityGraph

<!-- omit from toc -->

## Table of Contents

- [Entity Loading Strategies Overview](#entity-loading-strategies-overview)
- [Lazy Loading Default Behavior](#lazy-loading-default-behavior)
- [Global vs Query-Specific Loading](#global-vs-query-specific-loading)
- [Introducing @EntityGraph Annotation](#introducing-entitygraph-annotation)
- [Creating Query with Entity Graph](#creating-query-with-entity-graph)
- [Testing Entity Graph Loading](#testing-entity-graph-loading)
- [Database Constraint Issues](#database-constraint-issues)
- [Analyzing Generated SQL Queries](#analyzing-generated-sql-queries)
- [LazyInitializationException Problem](#lazyinitializationexception-problem)
- [Transaction Context Solution](#transaction-context-solution)
- [ToString Annotation Issues](#tostring-annotation-issues)
- [Custom ToString Implementation](#custom-tostring-implementation)
- [Loading Multiple Relationships](#loading-multiple-relationships)
- [Nested Relationship Loading](#nested-relationship-loading)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Entity Loading Strategies Overview

- **Lazy loading default**: Many-to-many and one-to-many relationships use lazy loading by default
- **Performance consideration**: Avoid loading unnecessary data until actually needed
- **Query-specific control**: Load related entities only when required for specific operations
- **@EntityGraph solution**: Override lazy loading for individual queries without changing global settings

![Entity Loading Strategies Overview](assets/entity-loading-strategies-overview.png)

**Loading strategy types:**
- **Eager loading**: Load related entities immediately with parent entity
- **Lazy loading**: Load related entities only when first accessed
- **Query-specific**: Use @EntityGraph to selectively load relationships
- **Performance impact**: Choose strategy based on use case requirements

## Lazy Loading Default Behavior

- **Many-to-many relationships**: User-Tag relationship uses lazy loading by default
- **One-to-many relationships**: User-Address relationship also lazy by default
- **Deferred loading**: Related entities fetched only when accessed
- **Separate queries**: Additional SQL queries generated when relationships accessed

```java
@Entity
public class User {
    
    @ManyToMany
    @JoinTable(
        name = "user_tags",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "tag_id")
    )
    private Set<Tag> tags = new HashSet<>();  // Lazy by default
    
    @OneToMany(mappedBy = "user")
    private List<Address> addresses = new ArrayList<>();  // Lazy by default
}
```

![Lazy Loading Default Behavior](assets/lazy-loading-default-behavior.png)

## Global vs Query-Specific Loading

- **Global eager loading**: Set fetch = FetchType.EAGER affects all queries
- **Performance penalty**: Every user query loads tags unnecessarily
- **Query-specific need**: Only some queries require tag information
- **Better approach**: Use @EntityGraph for selective loading

```java
// Global approach - affects ALL queries (not recommended)
@ManyToMany(fetch = FetchType.EAGER)
private Set<Tag> tags = new HashSet<>();

// Better approach - keep default lazy loading
@ManyToMany  // Lazy by default
private Set<Tag> tags = new HashSet<>();
```

![Global vs Query Specific Loading](assets/global-vs-query-specific-loading.png)

## Introducing @EntityGraph Annotation

- **Import location**: `org.springframework.data.jpa.repository.EntityGraph`
- **Selective loading**: Override lazy loading for specific repository methods
- **Attribute paths**: Specify which relationships to eagerly load
- **Query-level control**: Apply to individual repository methods

```java
import org.springframework.data.jpa.repository.EntityGraph;

public interface UserRepository extends CrudRepository<User, Long> {
    
    @EntityGraph(attributePaths = {"tags"})
    Optional<User> findByEmail(String email);
}
```

![EntityGraph Annotation Introduction](assets/entitygraph-annotation-introduction.png)

## Creating Query with Entity Graph

- **Method signature**: Define repository method with appropriate return type
- **Optional return**: Use Optional<User> for methods that may not find entity
- **Email lookup**: Common pattern for user authentication and retrieval
- **Annotation application**: Apply @EntityGraph with relationship names

```java
public interface UserRepository extends CrudRepository<User, Long> {
    
    @EntityGraph(attributePaths = {"tags"})
    Optional<User> findByEmail(String email);
    
    // Without @EntityGraph - uses lazy loading
    Optional<User> findByName(String name);
}
```

![Query with Entity Graph Creation](assets/query-entity-graph-creation.png)

## Testing Entity Graph Loading

- **Service method**: Create method to test entity graph functionality
- **User retrieval**: Find user by email with tags loaded
- **Exception handling**: Use orElseThrow() for missing user scenarios
- **Output testing**: Print user ID to verify loading without triggering lazy loading

```java
@Service
public class UserService {
    
    public void fetchUser() {
        var user = userRepository.findByEmail("mosh@codewithmosh.com")
                                .orElseThrow();
        
        // Print only ID to avoid lazy loading issues
        System.out.println(user.getId());
    }
}
```

![Testing Entity Graph Loading](assets/testing-entity-graph-loading.png)

## Database Constraint Issues

- **Duplicate email problem**: Multiple users with same email address
- **Missing unique constraint**: Email column should have unique constraint
- **Migration needed**: Add unique constraint to prevent duplicate emails
- **Data cleanup required**: Remove duplicate data before applying constraint

![Database Constraint Issues](assets/database-constraint-issues.png)

**Resolution steps:**
1. **Identify duplicates**: Find records with duplicate email addresses
2. **Clean data**: Remove or update duplicate records
3. **Create migration**: Add unique constraint on email column
4. **Update test data**: Use unique email addresses for testing

```sql
-- Migration to add unique constraint
ALTER TABLE users ADD CONSTRAINT uk_user_email UNIQUE (email);
```

![Unique Constraint Migration](assets/unique-constraint-migration.png)

## Analyzing Generated SQL Queries

- **Single optimized query**: @EntityGraph generates one query with JOINs
- **LEFT JOIN operations**: Includes user_tags junction table and tags table
- **All columns selected**: Fetches data from users, user_tags, and tags tables
- **Profile loading**: Additional query for one-to-one profile relationship

![Generated SQL Analysis](assets/generated-sql-analysis.png)

**SQL query structure:**
```sql
-- Main query with entity graph
SELECT u.*, t.* 
FROM users u 
LEFT JOIN user_tags ut ON u.id = ut.user_id 
LEFT JOIN tags t ON ut.tag_id = t.id 
WHERE u.email = ?;

-- Additional profile query (one-to-one relationship)
SELECT p.* FROM profiles p WHERE p.user_id = ?;
```

![SQL Query Structure](assets/sql-query-structure.png)

## LazyInitializationException Problem

- **Exception occurrence**: Printing entire user object triggers lazy loading
- **Hibernate session**: No active session when accessing lazy relationships
- **Common scenario**: Accessing lazy relationships outside transaction context
- **Error message**: "LazyInitializationException: could not initialize proxy"

```java
public void fetchUser() {
    var user = userRepository.findByEmail("mosh@codewithmosh.com")
                            .orElseThrow();
    
    // This will throw LazyInitializationException
    System.out.println(user);  // toString() accesses lazy relationships
}
```

![LazyInitializationException Problem](assets/lazy-initialization-exception.png)

## Transaction Context Solution

- **@Transactional annotation**: Maintain Hibernate session during method execution
- **Session lifecycle**: Keep session open for lazy loading access
- **Import location**: `org.springframework.transaction.annotation.Transactional`
- **Method-level application**: Apply to service methods accessing lazy relationships

```java
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
    
    @Transactional  // Keeps Hibernate session open
    public void fetchUser() {
        var user = userRepository.findByEmail("mosh@codewithmosh.com")
                                .orElseThrow();
        
        System.out.println(user);  // Now works with @Transactional
    }
}
```

![Transaction Context Solution](assets/transaction-context-solution.png)

## ToString Annotation Issues

- **Lombok @ToString**: Automatically includes all fields in toString() method
- **Lazy loading trigger**: ToString accesses lazy relationships causing additional queries
- **Performance impact**: Unexpected database queries when printing objects
- **IDE warning**: "ToString includes lazy loaded fields and associations"

![ToString Annotation Issues](assets/tostring-annotation-issues.png)

**Problems caused:**
- **Additional queries**: toString() triggers loading of addresses and wishlist
- **Performance degradation**: Unexpected database hits
- **Lazy loading cascade**: Each relationship access may trigger more queries
- **Debug difficulties**: Hard to track when lazy loading occurs

## Custom ToString Implementation

- **Replace Lombok annotation**: Remove @ToString and implement custom method
- **Selective field inclusion**: Choose specific fields for string representation
- **Avoid lazy relationships**: Include only eagerly loaded or simple fields
- **IDE assistance**: Use IDE generation for custom toString() method

```java
@Entity
@Getter
@Setter
// Remove @ToString to avoid lazy loading issues
public class User {
    private Long id;
    private String name;
    private String email;
    
    // Custom toString implementation
    @Override
    public String toString() {
        return "User{" +
               "id=" + id +
               ", name='" + name + '\'' +
               ", email='" + email + '\'' +
               '}';
    }
}
```

![Custom ToString Implementation](assets/custom-tostring-implementation.png)

## Loading Multiple Relationships

- **Array of attribute paths**: Load multiple relationships in single query
- **Syntax**: Use array notation with curly braces
- **Performance benefit**: Single query instead of multiple separate queries
- **Relationship selection**: Choose relationships based on query needs

```java
public interface UserRepository extends CrudRepository<User, Long> {
    
    // Load multiple relationships
    @EntityGraph(attributePaths = {"tags", "addresses"})
    Optional<User> findByEmail(String email);
    
    // Load only tags
    @EntityGraph(attributePaths = {"tags"})
    List<User> findByNameContaining(String name);
}
```

![Multiple Relationships Loading](assets/multiple-relationships-loading.png)

**Generated SQL with multiple relationships:**
```sql
SELECT u.*, t.*, a.* 
FROM users u 
LEFT JOIN user_tags ut ON u.id = ut.user_id 
LEFT JOIN tags t ON ut.tag_id = t.id 
LEFT JOIN addresses a ON u.id = a.user_id 
WHERE u.email = ?;
```

![Multiple Relationships SQL](assets/multiple-relationships-sql.png)

## Nested Relationship Loading

- **Dot notation**: Access nested relationships using dot syntax
- **Deep loading**: Load relationships of related entities
- **Complex queries**: Handle multi-level entity relationships
- **Performance consideration**: Balance loading depth with query performance

```java
public interface UserRepository extends CrudRepository<User, Long> {
    
    // Nested relationship loading
    @EntityGraph(attributePaths = {"addresses", "addresses.country"})
    Optional<User> findByEmail(String email);
    
    // Multiple levels
    @EntityGraph(attributePaths = {
        "tags", 
        "addresses", 
        "addresses.country",
        "profile"
    })
    Optional<User> findByEmailWithFullDetails(String email);
}
```

![Nested Relationship Loading](assets/nested-relationship-loading.png)

## Key Points

- **Main takeaway**: @EntityGraph allows selective eager loading of lazy relationships for specific queries without changing global fetch strategies
- **Performance optimization**: Generates single optimized SQL query with JOINs instead of multiple separate queries (N+1 problem prevention)
- **Query-specific control**: Override default lazy loading behavior only for methods that need related data, keeping other queries efficient
- **Transaction context**: Use @Transactional when accessing lazy relationships outside of @EntityGraph methods to prevent LazyInitializationException
- **ToString considerations**: Avoid Lombok @ToString with lazy relationships; implement custom toString() including only necessary fields
- **Multiple relationships**: Load multiple related entities using array syntax: `attributePaths = {"tags", "addresses"}`
- **Nested loading**: Access deep relationships using dot notation: `"addresses.country"` for loading relationships of related entities
- **Database constraints**: Ensure proper unique constraints on lookup fields like email to prevent data integrity issues
- **SQL analysis**: @EntityGraph generates LEFT JOIN queries that fetch all required data in single database round trip
- **Best practice**: Use @EntityGraph strategically for queries that definitely need related data, keep default lazy loading for general queries

## Links/References

- Video: 4.9.4-Efficiently-Loading-Entities-with-_EntityGraph.mp4 (06:38)
- Previous: [Fetching Partial Data with Projections](4.9.3-Fetching-Partial-Data-with-Projections.md)
- Next: Dynamic Queries with Specifications
- Reference: [Spring Data JPA EntityGraph](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.entity-graph)
- Reference: [JPA Entity Graph](https://www.baeldung.com/jpa-entity-graph)
- Reference: [Hibernate Lazy Loading](https://docs.jboss.org/hibernate/orm/5.6/userguide/html_single/Hibernate_User_Guide.html#fetching)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

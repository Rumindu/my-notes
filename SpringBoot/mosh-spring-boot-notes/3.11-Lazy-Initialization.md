# Lazy Initialization

<!-- omit from toc -->
## Table of Contents

- [Default Bean Initialization Behavior](#default-bean-initialization-behavior)
  - [Adding Constructor Logging](#adding-constructor-logging)
- [Understanding Eager Initialization](#understanding-eager-initialization)
  - [Testing with Bean Usage](#testing-with-bean-usage)
  - [Testing without Bean Usage](#testing-without-bean-usage)
- [Lazy Initialization Concept](#lazy-initialization-concept)
- [Creating a Heavy Resource Example](#creating-a-heavy-resource-example)
  - [Heavy Resource Class](#heavy-resource-class)
  - [Testing Eager Behavior](#testing-eager-behavior)
- [Implementing Lazy Initialization](#implementing-lazy-initialization)
  - [Using @Lazy Annotation](#using-lazy-annotation)
  - [Lazy with Code-Based Configuration](#lazy-with-code-based-configuration)
- [Testing Lazy Initialization](#testing-lazy-initialization)
  - [Application without HeavyResource Usage](#application-without-heavyresource-usage)
  - [Application with HeavyResource Usage](#application-with-heavyresource-usage)
- [Performance Considerations](#performance-considerations)
  - [Benefits of Lazy Initialization](#benefits-of-lazy-initialization)
  - [Important Guidelines](#important-guidelines)
  - [When to Use Lazy Initialization](#when-to-use-lazy-initialization)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Default Bean Initialization Behavior

- **Default behavior**: Spring creates and initializes all beans when application starts
- **Eager initialization**: All beans are created upfront, regardless of whether they're used
- **Demonstration**: Adding constructor logging to see bean creation timing

### Adding Constructor Logging

```java
public class OrderService {
    private PaymentService paymentService;
    
    public OrderService(PaymentService paymentService) {
        System.out.println("OrderService created");  // sout + Tab shortcut
        this.paymentService = paymentService;
    }
    
    public void placeOrder() {
        paymentService.processPayment(10.0);
    }
}
```

![Adding Constructor Logging](assets/adding-constructor-logging-orderservice.png)

**IntelliJ shortcut**: `sout` + Tab = `System.out.println()`

## Understanding Eager Initialization

### Testing with Bean Usage

**Application using OrderService:**
```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(StoreApplication.class, args);
        
        OrderService orderService = context.getBean(OrderService.class);
        orderService.placeOrder();
    }
}
```

**Output:**
```
OrderService created
```

![Eager Initialization with Usage](assets/eager-initialization-with-usage.png)

### Testing without Bean Usage

**Application NOT using OrderService:**
```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(StoreApplication.class, args);
        
        // OrderService orderService = context.getBean(OrderService.class);  // Commented out
        // orderService.placeOrder();                                        // Commented out
    }
}
```

**Output:**
```
OrderService created  // Still created even though not used!
```

![Eager Initialization without Usage](assets/eager-initialization-without-usage.png)

**Key observation**: OrderService is still created even when not explicitly used

## Lazy Initialization Concept

- **Alternative approach**: Create objects only when they are actually needed
- **Optimization technique**: Useful for costly-to-create objects
- **Use cases**: Objects that use significant memory or require expensive setup
- **Performance benefit**: Improves application startup time and memory usage

![Lazy Initialization Concept](assets/lazy-initialization-concept.png)

## Creating a Heavy Resource Example

### Heavy Resource Class

```java
@Component
public class HeavyResource {
    
    public HeavyResource() {
        System.out.println("HeavyResource created");  // sout + Tab
    }
}
```

![Creating Heavy Resource Class](assets/creating-heavy-resource-class.png)

**IntelliJ constructor generation:**
1. **Generate menu**: `Cmd+N` (Mac) or `Ctrl+N` (Windows)
2. **Select**: Constructor
3. **Add logging**: `sout` + Tab for System.out.println()

### Testing Eager Behavior

**Running application with HeavyResource:**

**Output:**
```
OrderService created
HeavyResource created
```

![Heavy Resource Eager Creation](assets/heavy-resource-eager-creation.png)

**Result**: HeavyResource is created immediately during application startup

## Implementing Lazy Initialization

### Using @Lazy Annotation

```java
@Component
@Lazy  // Delays creation until first use
public class HeavyResource {
    
    public HeavyResource() {
        System.out.println("HeavyResource created");
    }
}
```

![Lazy Annotation Implementation](assets/lazy-annotation-implementation.png)

### Lazy with Code-Based Configuration

**If using AppConfig for bean creation:**
```java
@Configuration
public class AppConfig {
    
    @Bean
    @Lazy  // Apply to bean producer method
    public HeavyResource heavyResource() {
        return new HeavyResource();
    }
}
```

![Lazy Annotation in AppConfig](assets/lazy-annotation-appconfig.png)

**Note**: Apply @Lazy to the @Bean method in configuration classes

## Testing Lazy Initialization

### Application without HeavyResource Usage

**Running application without accessing HeavyResource:**

**Output:**
```
OrderService created
// HeavyResource NOT created
```

![Lazy Initialization No Creation](assets/lazy-initialization-no-creation.png)

**Result**: HeavyResource is no longer created during startup

### Application with HeavyResource Usage

```java
@SpringBootApplication
public class StoreApplication {
    
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(StoreApplication.class, args);
        
        // Explicitly request HeavyResource
        HeavyResource resource = context.getBean(HeavyResource.class);
    }
}
```

![Accessing Heavy Resource Bean](assets/accessing-heavy-resource-bean.png)

**Output:**
```
OrderService created
HeavyResource created  // Created only when requested
```

![Lazy Initialization On Demand](assets/lazy-initialization-on-demand.png)

**Demonstration**: HeavyResource is created only when explicitly requested

## Performance Considerations

### Benefits of Lazy Initialization

- **Faster startup**: Application starts quicker by avoiding expensive object creation
- **Memory efficiency**: Reduces memory usage for unused objects
- **Resource optimization**: Delays expensive operations until necessary
- **Selective loading**: Create only what's needed for current application flow

### Important Guidelines

- **Don't use blindly**: Apply only when there's a clear benefit
- **Premature optimization**: "Premature optimization is the root of all evil"
- **Selective application**: Use for genuinely expensive objects (large memory usage, slow initialization)
- **Measure impact**: Profile application to verify performance improvements

![Performance Considerations Guidelines](assets/performance-considerations-guidelines.png)

### When to Use Lazy Initialization

**Good candidates:**
- Database connection pools
- Large in-memory caches
- Heavy computational objects
- Third-party service clients
- Objects with expensive initialization

**Poor candidates:**
- Simple POJOs
- Configuration objects
- Frequently used services
- Critical application components

![When to Use Lazy Initialization](assets/when-to-use-lazy-initialization.png)

## Key Points

- **Main takeaway**: Lazy initialization delays bean creation until first use, improving startup time and memory usage
- **Default behavior**: Spring creates all beans eagerly during application startup
- **@Lazy annotation**: Apply to classes or @Bean methods to enable lazy initialization
- **Performance optimization**: Useful for expensive-to-create objects or objects that may not be used
- **Testing approach**: Add constructor logging to observe bean creation timing
- **Configuration flexibility**: Works with both annotation-based and code-based bean configuration
- **Best practice**: Use selectively for genuinely expensive objects, not as a blanket optimization
- **Quote to remember**: "Premature optimization is the root of all evil" - apply judiciously
- **Measurement importance**: Profile application to verify that lazy initialization provides actual benefits

## Links/References

- Video: 3.11-Lazy-Initialization.mp4 (3m 12s)
- Previous: [Configuring Beans Using Code](3.10-Configuring-Beans-Using-Code.md)
- Next: Bean Scopes

---

**Created**: July 30, 2025  
**Last Modified**: July 30, 2025

# Defining One-to-One Relationships

<!-- omit from toc -->

## Table of Contents

- [One-to-One Relationship Overview](#one-to-one-relationship-overview)
- [Implementing the User Side](#implementing-the-user-side)
- [Implementing the Profile Side](#implementing-the-profile-side)
- [Understanding One-to-One Ownership](#understanding-one-to-one-ownership)
- [Primary Key as Foreign Key](#primary-key-as-foreign-key)
- [Creating Profile Objects](#creating-profile-objects)
- [Testing the Relationship](#testing-the-relationship)
- [Bidirectional Relationship Issues](#bidirectional-relationship-issues)
- [Fixing Circular References](#fixing-circular-references)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## One-to-One Relationship Overview

- **Relationship type**: One-to-One between User and Profile entities
- **Business rule**: One user has exactly one profile, one profile belongs to exactly one user
- **Cardinality**: 1:1 relationship with mutual exclusivity
- **Use case**: Extended user information stored in separate table

![One-to-One Relationship Diagram](assets/one-to-one-relationship-diagram.png)

**One-to-one characteristics:**
- **Mutual exclusivity**: Each user has exactly one profile
- **Bidirectional**: Can navigate in both directions
- **Separate tables**: User and Profile data in different tables
- **Shared primary key**: Profile uses user ID as both primary and foreign key

## Implementing the User Side

- **Reference field**: Add Profile field to User entity
- **Simple annotation**: Use @OneToOne with mappedBy attribute
- **Import requirement**: Import Profile from entities package
- **Non-owning side**: User entity doesn't own the relationship

```java
@Entity
@Table(name = "users")
public class User {
    // Other fields...
    
    @OneToOne(mappedBy = "user")
    private Profile profile;
    
    // Other methods...
}
```

![User Entity One-to-One Implementation](assets/user-entity-one-to-one-implementation.png)

**Implementation steps:**
1. Add private Profile profile field
2. Import Profile entity from entities package
3. Apply @OneToOne annotation with mappedBy attribute
4. Reference owning field name from Profile entity

## Implementing the Profile Side

- **Reference field**: Add User field to Profile entity
- **Owning annotation**: Use @OneToOne with @JoinColumn
- **Column specification**: Join column maps to primary key
- **Owner side**: Profile entity owns the relationship

```java
@Entity
@Table(name = "profiles")
public class Profile {
    // Other fields...
    
    @OneToOne
    @JoinColumn(name = "id")
    @MapsId
    private User user;
    
    // Other methods...
}
```

![Profile Entity One-to-One Implementation](assets/profile-entity-one-to-one-implementation.png)

**Implementation details:**
- **@OneToOne**: Defines one profile to one user relationship
- **@JoinColumn**: Specifies foreign key column (id)
- **@MapsId**: Uses same column as primary and foreign key
- **Owner designation**: Profile owns the relationship

## Understanding One-to-One Ownership

- **Ownership principle**: Entity with foreign key owns the relationship
- **Database perspective**: Profile table contains foreign key to users
- **Primary key sharing**: Profile uses user ID as its primary key
- **Relationship owner**: Profile entity owns the one-to-one relationship

![One-to-One Ownership Concept](assets/one-to-one-ownership-concept.png)

**Ownership determination:**
- **Owner entity**: Profile (contains foreign key)
- **Non-owner entity**: User (uses mappedBy)
- **Foreign key location**: profiles.id references users.id
- **MappedBy value**: "user" (field name in Profile entity)

## Primary Key as Foreign Key

- **@MapsId annotation**: Tells Hibernate to use same column for primary and foreign key
- **Column sharing**: ID column serves dual purpose in profiles table
- **Database efficiency**: Eliminates need for separate foreign key column
- **Unique constraint**: Ensures one-to-one relationship integrity

![MapsId Annotation Usage](assets/mapsid-annotation-usage.png)

**@MapsId benefits:**
- **Space efficiency**: Single column serves two purposes
- **Referential integrity**: Automatic foreign key constraint
- **Unique relationship**: Prevents multiple profiles per user
- **Database normalization**: Optimal table structure

**Database schema:**
```sql
-- Users table
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255),
    email VARCHAR(255),
    password VARCHAR(255)
);

-- Profiles table (id is both PK and FK)
CREATE TABLE profiles (
    id BIGINT PRIMARY KEY,  -- Same as user.id
    bio TEXT,
    phone_number VARCHAR(255),
    date_of_birth DATE,
    loyalty_points INTEGER,
    FOREIGN KEY (id) REFERENCES users(id)
);
```

![One-to-One Database Schema](assets/one-to-one-database-schema.png)

## Creating Profile Objects

- **Builder pattern**: Good candidate due to multiple optional attributes
- **Lombok annotations**: Add @Builder, @AllArgsConstructor, @NoArgsConstructor
- **Optional fields**: Profile has many fields that may not be set initially
- **Flexible creation**: Builder allows setting only needed fields

```java
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "profiles")
public class Profile {
    @Id
    private Long id;
    
    @Column(name = "bio")
    private String bio;
    
    @Column(name = "phone_number")
    private String phoneNumber;
    
    @Column(name = "date_of_birth")
    private LocalDate dateOfBirth;
    
    @Column(name = "loyalty_points")
    private Integer loyaltyPoints;
    
    @OneToOne
    @JoinColumn(name = "id")
    @MapsId
    private User user;
}
```

![Profile Builder Implementation](assets/profile-builder-implementation.png)

## Testing the Relationship

- **Object creation**: Create User and Profile objects
- **Simple assignment**: Use setter to establish relationship
- **Unidirectional test**: Initially test only User → Profile direction
- **Console output**: Print objects to verify relationship

```java
@SpringBootApplication
public class StoreApplication {
    public static void main(String[] args) {
        var user = User.builder()
            .name("John")
            .email("john@example.com")
            .password("password123")
            .build();
            
        var profile = Profile.builder()
            .bio("Hello guys")
            .build();
            
        user.setProfile(profile);
        System.out.println(user);
        
        SpringApplication.run(StoreApplication.class, args);
    }
}
```

![One-to-One Testing Code](assets/one-to-one-testing-code.png)

## Bidirectional Relationship Issues

- **Missing back-reference**: Profile doesn't know about User initially
- **Incomplete relationship**: Only one side is set
- **Data integrity**: Both sides need to be updated for proper bidirectional relationship
- **Manual synchronization**: Must update both entities

![Incomplete Bidirectional Relationship](assets/incomplete-bidirectional-relationship.png)

**Problem identification:**
```java
// Only one side set
user.setProfile(profile);
// profile.getUser() returns null - missing back-reference

// Solution: update both sides
user.setProfile(profile);
profile.setUser(user);  // Set back-reference
```

**Fixed relationship code:**
```java
var user = User.builder()
    .name("John")
    .email("john@example.com")
    .password("password123")
    .build();
    
var profile = Profile.builder()
    .bio("Hello guys")
    .build();
    
// Update both sides of relationship
user.setProfile(profile);
profile.setUser(user);

System.out.println(user);
```

![Bidirectional Relationship Fix](assets/bidirectional-relationship-fix.png)

## Fixing Circular References

- **Stack overflow exception**: Occurs with bidirectional toString() calls
- **Circular reference**: User.toString() → Profile.toString() → User.toString()
- **Solution**: Exclude back-reference from toString generation
- **@ToString.Exclude**: Applied to User field in Profile entity

```java
@ToString
@Entity
@Table(name = "profiles")
public class Profile {
    // Other fields included in toString...
    
    @ToString.Exclude  // Prevent circular reference
    @OneToOne
    @JoinColumn(name = "id")
    @MapsId
    private User user;
}
```

![ToString Exclude One-to-One](assets/tostring-exclude-one-to-one.png)

**Circular reference prevention:**
- **@ToString annotation**: Add to Profile entity for debugging
- **@ToString.Exclude**: Exclude user field to break circular loop
- **Clean output**: Maintains readable object representation
- **Stack overflow fix**: Eliminates infinite recursion

**Final working output:**
```
User(id=null, name=John, email=john@example.com, password=password123, 
profile=Profile(id=null, bio=Hello guys, phoneNumber=null, dateOfBirth=null, loyaltyPoints=null))
```

![Final One-to-One Output](assets/final-one-to-one-output.png)

## Key Points

- **Main takeaway**: One-to-one relationships use shared primary keys with @MapsId annotation, where the dependent entity's primary key also serves as the foreign key
- **Ownership designation**: Profile entity owns the relationship since it contains the foreign key reference to User
- **@MapsId significance**: Critical annotation that tells Hibernate to use the same column (id) as both primary key and foreign key in the owning entity
- **Bidirectional integrity**: Both sides of one-to-one relationships must be updated manually to maintain proper object state and referential integrity
- **Builder pattern suitability**: Profile entity is ideal for builder pattern due to multiple optional attributes like bio, phone, date of birth, and loyalty points
- **Circular reference consistency**: Same @ToString.Exclude solution needed for one-to-one relationships as with one-to-many and many-to-many relationships
- **Database efficiency**: Shared primary key approach eliminates need for separate foreign key column, optimizing storage and maintaining uniqueness constraint
- **Cascade considerations**: IntelliJ suggests cascade attributes for one-to-one relationships, but cascading behavior should be configured based on business requirements
- **Relationship synchronization**: Unlike collection-based relationships, one-to-one requires simple setter calls on both entities to establish bidirectional links
- **Primary key strategy**: One-to-one relationships often use shared primary key strategy where dependent entity inherits primary key value from parent entity

## Links/References

- Video: 4.7.6-Defining-One-to-One-Relationships.mp4 (04:48)
- Previous: [Defining Many-to-Many Relationships](4.7.5-Defining-Many-to-Many-Relationships.md)
- Next: Relationship Cascading and Fetch Types
- Reference: [JPA OneToOne Annotation](https://docs.oracle.com/javaee/7/api/javax/persistence/OneToOne.html)
- Reference: [JPA MapsId Annotation](https://docs.oracle.com/javaee/7/api/javax/persistence/MapsId.html)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

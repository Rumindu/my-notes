# Generating Database Tables with Hibernate

<!-- omit from toc -->

## Table of Contents

- [Hibernate DDL Auto Overview](#hibernate-ddl-auto-overview)
- [Configuring DDL Auto Properties](#configuring-ddl-auto-properties)
- [DDL Auto Options](#ddl-auto-options)
- [Setting Up Test Database](#setting-up-test-database)
- [Application Configuration](#application-configuration)
- [Running Hibernate Generation](#running-hibernate-generation)
- [Verifying Generated Tables](#verifying-generated-tables)
- [Problems with Hibernate Generation](#problems-with-hibernate-generation)
- [Database Schema Quality Issues](#database-schema-quality-issues)
- [Versioning and Team Collaboration Problems](#versioning-and-team-collaboration-problems)
- [Creating Initial Migration from Generated Schema](#creating-initial-migration-from-generated-schema)
- [Best Practices and Recommendations](#best-practices-and-recommendations)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Hibernate DDL Auto Overview

- **Alternative approach**: Let Hibernate automatically generate database tables at runtime
- **No migration scripts**: Database schema created without manual SQL scripts
- **Runtime generation**: Tables created when application starts
- **Development convenience**: Quick setup for prototyping and development

![Hibernate DDL Auto Concept](assets/hibernate-ddl-auto-concept.png)

**DDL Auto benefits:**
- **Rapid prototyping**: Quick database setup for development
- **No SQL knowledge**: Tables generated from entity definitions
- **Automatic updates**: Schema changes based on entity modifications
- **Development speed**: Faster initial setup compared to migrations

## Configuring DDL Auto Properties

- **Configuration file**: Add properties to application.yaml
- **Property cleanup**: Remove unused properties from previous lessons
- **JPA configuration**: Configure under spring.jpa.hibernate section
- **DDL auto setting**: Specify database generation behavior

```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: create
  datasource:
    url: jdbc:mysql://localhost:3306/store_temp
    username: root
    password: your_password
```

![Application YAML DDL Configuration](assets/application-yaml-ddl-configuration.png)

**Configuration steps:**
1. Open application.yaml file
2. Clean up unused properties
3. Add spring.jpa.hibernate.ddl-auto property
4. Set temporary database name for testing

## DDL Auto Options

- **create**: Recreates database every application startup
- **update**: Updates database schema if necessary
- **validate**: Validates schema without making changes
- **create-drop**: Creates on startup, drops on shutdown

![DDL Auto Options Explanation](assets/ddl-auto-options-explanation.png)

**Option descriptions:**
- **create**: 
  - Drops existing tables and recreates them
  - Useful for development with fresh data each startup
  - **Data loss**: All existing data is lost

- **update**: 
  - Modifies existing schema to match entities
  - Preserves existing data
  - **Caution**: May not handle all schema changes properly

- **validate**: 
  - Checks if schema matches entity definitions
  - No schema modifications
  - **Validation only**: Throws exception if mismatch found

- **create-drop**: 
  - Creates schema on startup, drops on shutdown
  - Useful for testing scenarios
  - **Temporary**: No persistent database

## Setting Up Test Database

- **Database name change**: Use temporary database name for testing
- **Isolation**: Avoid affecting existing development database
- **Testing approach**: Verify Hibernate generation in separate environment
- **Connection configuration**: Update datasource URL for test database

![Test Database Configuration](assets/test-database-configuration.png)

**Database setup:**
- **Original database**: store (preserved)
- **Test database**: store_temp (for Hibernate generation)
- **URL change**: jdbc:mysql://localhost:3306/store_temp
- **Isolation benefit**: Keep existing data safe during testing

## Application Configuration

- **Main method cleanup**: Remove test code for user/profile objects
- **Spring application**: Ensure SpringApplication.run() is active for Hibernate
- **Import cleanup**: Remove unused imports with Alt + Enter
- **Clean startup**: Application ready for Hibernate table generation

```java
@SpringBootApplication
public class StoreApplication {
    public static void main(String[] args) {
        // Clean main method - let Hibernate generate tables
        SpringApplication.run(StoreApplication.class, args);
    }
}
```

![Clean Application Main Method](assets/clean-application-main-method.png)

**Cleanup steps:**
1. Remove user/profile creation code
2. Ensure SpringApplication.run() is present
3. Remove unused imports
4. Clean startup for table generation

## Running Hibernate Generation

- **Application startup**: Start application to trigger table generation
- **Hibernate DDL**: Hibernate executes DDL statements during startup
- **Console output**: See table creation statements in application logs
- **Automatic process**: No manual intervention required

![Hibernate Table Generation Startup](assets/hibernate-table-generation-startup.png)

**Generation process:**
1. Application starts with ddl-auto: create
2. Hibernate analyzes entity classes
3. DDL statements generated and executed
4. Database tables created automatically
5. Application ready for use

## Verifying Generated Tables

- **Database window**: Add new data source for test database
- **Connection setup**: Configure connection to store_temp database
- **Table verification**: Confirm all entity tables were created
- **Schema inspection**: Review generated table structures

![Database Connection Setup](assets/database-connection-setup-temp.png)

**Verification steps:**
1. Add new MySQL data source
2. Set database to store_temp
3. Test connection
4. Explore generated tables
5. Verify table structures

![Generated Tables Overview](assets/generated-tables-overview.png)

**Generated tables confirmation:**
- **users table**: User entity mapped to table
- **addresses table**: Address entity with foreign keys
- **profiles table**: Profile entity with shared primary key
- **tags table**: Tag entity structure
- **wishlist table**: Many-to-many join table

## Problems with Hibernate Generation

- **Model-first issues**: Same problems as discussed in previous lesson
- **Database details required**: Entities must contain all database specifications
- **Schema quality**: Generated schema may not be optimal
- **Production unsuitability**: Not recommended for production environments

![Problems with Hibernate Generation](assets/problems-hibernate-generation.png)

**Primary issues:**
1. **Entity clutter**: Database details mixed with business logic
2. **Schema optimization**: May not generate optimal database structure
3. **Versioning loss**: No migration history for schema changes
4. **Team collaboration**: Difficult to synchronize schema across environments

## Database Schema Quality Issues

- **Default data types**: Hibernate uses default SQL types for Java types
- **varchar(255) default**: String fields default to varchar(255)
- **Suboptimal choices**: May not match business requirements
- **Manual specification required**: Need detailed annotations for proper schema

![Schema Quality Issues Example](assets/schema-quality-issues-example.png)

**Bio column example:**
- **Generated type**: varchar(255) for String bio field
- **Problem**: Limited length for biography content
- **Solution needed**: @Column(columnDefinition = "TEXT") in entity
- **Entity complexity**: Additional database details in business objects

```java
// Default Hibernate generation
private String bio; // Results in varchar(255)

// Required for proper schema
@Column(columnDefinition = "TEXT", nullable = false)
private String bio; // Results in TEXT NOT NULL
```

![Column Type Customization Need](assets/column-type-customization-need.png)

## Versioning and Team Collaboration Problems

- **No migration history**: Schema changes not tracked
- **Environment inconsistency**: Different schema states across environments
- **Team synchronization**: Difficult to share exact schema with team members
- **Production deployment**: Cannot recreate exact database structure

![Versioning Problems Diagram](assets/versioning-problems-diagram.png)

**Collaboration challenges:**
- **Developer machine**: Different schema state
- **Testing environment**: Cannot guarantee same schema
- **Production environment**: Unsafe to use ddl-auto
- **CI/CD pipeline**: No reliable schema versioning

## Creating Initial Migration from Generated Schema

- **JPA Buddy solution**: Generate initial migration from working schema
- **Migration creation**: Right-click migration folder â†’ "New Flyway init migration"
- **Source selection**: Choose domain model or database as source
- **V1 migration**: Create initial migration similar to manual approach

![Initial Migration Creation](assets/initial-migration-creation.png)

**Migration creation process:**
1. Right-click migration directory
2. Select "New Flyway init migration"
3. Choose source (model or database)
4. Generate V1 initial migration
5. Include in version control for team sharing

![Flyway Init Migration Dialog](assets/flyway-init-migration-dialog.png)

**Migration benefits:**
- **Version control**: Initial schema in migration format
- **Team sharing**: Everyone can recreate same database
- **Environment consistency**: Same schema across all environments
- **Production readiness**: Proper migration-based deployment

## Best Practices and Recommendations

- **Development only**: Use Hibernate generation only for development/prototyping
- **Migration transition**: Create initial migration from working prototype
- **Production approach**: Always use migration-based schema management
- **Configuration revert**: Remove ddl-auto properties after prototyping

![Best Practices Workflow](assets/best-practices-workflow.png)

**Recommended workflow:**
1. **Prototype phase**: Use ddl-auto for rapid development
2. **Schema finalization**: Include all necessary database details
3. **Migration creation**: Generate initial migration with JPA Buddy
4. **Production deployment**: Use Flyway migrations for all environments
5. **Future changes**: Use migration-first approach

**Configuration cleanup:**
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/store  # Back to original
    username: root
    password: your_password
  # Remove JPA DDL auto properties for production
```

![Configuration Cleanup](assets/configuration-cleanup.png)

## Key Points

- **Main takeaway**: Hibernate DDL auto provides convenient table generation for development but should never be used in production due to versioning and schema quality issues
- **Development convenience**: DDL auto enables rapid prototyping without writing SQL migration scripts, but entities must contain detailed database specifications
- **Schema quality concerns**: Hibernate generates default SQL types that may not match business requirements, requiring extensive entity annotations for proper schema
- **Versioning problems**: Automatic generation lacks migration history, making it impossible to recreate exact database states across different environments
- **Team collaboration issues**: No reliable way to synchronize schema changes across team members, testing, and production environments
- **Migration transition**: JPA Buddy can generate initial migrations from Hibernate-generated schemas, enabling transition to proper migration-based approach
- **DDL auto options**: create, update, validate, and create-drop serve different development scenarios but all have production limitations
- **Best practice workflow**: Use DDL auto for prototyping, then create proper migrations before production deployment
- **Production readiness**: Migration-based schema management essential for reliable deployments and environment consistency
- **Configuration management**: Remove DDL auto properties and revert to original database configuration after prototyping phase

## Links/References

- Video: 4.7.11-Generating-Database-Tables-with-Hibernate.mp4 (04:38)
- Previous: [Exercise - Creating the Wishlist Table](4.7.10-Exercise-Creating-the-Wishlist-Table.md)
- Next: Advanced JPA Configuration
- Reference: [Hibernate DDL Auto](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization.using-hibernate)
- Tool: [JPA Buddy Plugin](https://plugins.jetbrains.com/plugin/15075-jpa-buddy) (for initial migration generation)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025

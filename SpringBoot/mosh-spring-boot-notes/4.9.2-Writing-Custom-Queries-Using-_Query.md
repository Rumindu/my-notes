# Writing Custom Queries Using @Query

<!-- omit from toc -->

## Table of Contents

- [Custom Queries with @Query Overview](#custom-queries-with-query-overview)
- [Limitations of Derived Query Methods](#limitations-of-derived-query-methods)
- [Creating Complex Query with Derived Methods](#creating-complex-query-with-derived-methods)
- [Introducing @Query Annotation](#introducing-query-annotation)
- [SQL vs JPQL Overview](#sql-vs-jpql-overview)
- [Writing SQL Queries with @Query](#writing-sql-queries-with-query)
- [Parameter Binding with @Param](#parameter-binding-with-param)
- [Converting SQL to JPQL](#converting-sql-to-jpql)
- [JPQL Benefits and IntelliSense](#jpql-benefits-and-intellisense)
- [JPA Buddy Query Generation](#jpa-buddy-query-generation)
- [Advanced JPQL Features](#advanced-jpql-features)
- [Aggregate Functions in JPQL](#aggregate-functions-in-jpql)
- [Update Operations with @Query](#update-operations-with-query)
- [Testing Update Operations](#testing-update-operations)
- [Transaction Requirements](#transaction-requirements)
- [Key Points](#key-points)
- [Links/References](#linksreferences)

## Custom Queries with @Query Overview

- **Complex query needs**: Derived query methods break down for complex scenarios
- **Method name problems**: Long, unreadable method names with complex queries
- **@Query solution**: Write custom queries while keeping method names simple
- **Flexibility gained**: Handle scenarios where naming conventions don't exist

![Custom Queries with @Query Overview](assets/custom-queries-query-overview.png)

**When to use @Query:**
- **Complex business logic**: Multi-condition queries beyond simple conventions
- **Join operations**: Queries involving multiple tables/entities
- **Aggregate functions**: COUNT, SUM, MIN, MAX operations
- **Update/Delete operations**: Data modification queries
- **Performance optimization**: Hand-crafted queries for better performance

## Limitations of Derived Query Methods

- **Complex scenarios**: No naming conventions for certain query types
- **Long method names**: Become unreadable as complexity increases
- **Limited expressiveness**: Cannot handle advanced SQL features
- **Performance concerns**: Generated queries may not be optimal

![Derived Query Method Limitations](assets/derived-query-method-limitations.png)

**Example limitations:**
- **Multi-table joins**: Complex relationships difficult to express
- **Conditional logic**: Dynamic WHERE clauses not supported
- **Advanced SQL**: Window functions, CTEs, stored procedures
- **Database-specific features**: Vendor-specific SQL extensions

## Creating Complex Query with Derived Methods

- **Scenario**: Find products in price range, sorted by name
- **Method structure**: Combine multiple naming conventions
- **Result**: Long, unwieldy method names

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    // Complex derived query method - long method name
    List<Product> findByPriceBetweenOrderByName(BigDecimal min, BigDecimal max);
    
    // Method name becomes increasingly unreadable
    List<Product> findByPriceBetweenAndCategoryOrderByNameAsc(
        BigDecimal min, BigDecimal max, String category);
}
```

![Complex Derived Query Method](assets/complex-derived-query-method.png)

## Introducing @Query Annotation

- **Import location**: `org.springframework.data.jpa.repository.Query`
- **Method simplification**: Use descriptive method names instead of conventions
- **Query specification**: Provide SQL or JPQL query as annotation parameter
- **Parameter flexibility**: Support for named and positional parameters

```java
import org.springframework.data.jpa.repository.Query;

public interface ProductRepository extends CrudRepository<Product, Long> {
    
    @Query("...")  // SQL or JPQL query goes here
    List<Product> findProducts(BigDecimal min, BigDecimal max);
    
    // Short, descriptive method name vs long derived method name
}
```

![Query Annotation Introduction](assets/query-annotation-introduction.png)

## SQL vs JPQL Overview

- **JPQL (Java Persistence Query Language)**: Object-oriented query language
- **Database agnostic**: Portable across different database engines
- **Entity-based**: Works with Java entities instead of database tables
- **SQL**: Direct database queries with full SQL feature access
- **Trade-offs**: JPQL portability vs SQL advanced features

![SQL vs JPQL Comparison](assets/sql-vs-jpql-comparison.png)

**JPQL advantages:**
- **Database independence**: Switch databases without rewriting queries
- **Type safety**: Compile-time checking of entity references
- **IntelliSense support**: IDE autocompletion for entity properties
- **Simpler syntax**: Less verbose than equivalent SQL

**SQL advantages:**
- **Full feature access**: Database-specific functions and optimizations
- **Performance tuning**: Direct control over query execution
- **Advanced features**: Window functions, CTEs, stored procedures
- **Existing expertise**: Leverage SQL knowledge directly

## Writing SQL Queries with @Query

- **Native query flag**: Set `nativeQuery = true` for SQL queries
- **Table references**: Use actual database table names
- **Parameter syntax**: Prefix parameters with colon (`:parameter`)
- **Alias usage**: Optional table aliases for readability

```java
public interface ProductRepository extends CrudRepository<Product, Long> {
    
    @Query(value = "SELECT * FROM products p " +
           "WHERE p.price BETWEEN :min AND :max " +
           "ORDER BY p.name", 
           nativeQuery = true)
    List<Product> findProducts(@Param("min") BigDecimal min, 
                              @Param("max") BigDecimal max);
}
```

![SQL Query with Native Flag](assets/sql-query-native-flag.png)

## Parameter Binding with @Param

- **@Param annotation**: Links method parameters to query parameters
- **Import location**: `org.springframework.data.repository.query.Param`
- **Named parameters**: Use descriptive parameter names in queries
- **Parameter matching**: Annotation value must match query parameter name

```java
import org.springframework.data.repository.query.Param;

@Query(value = "SELECT * FROM products p " +
       "WHERE p.price BETWEEN :min AND :max " +
       "ORDER BY p.name", 
       nativeQuery = true)
List<Product> findProducts(@Param("min") BigDecimal min, 
                          @Param("max") BigDecimal max);
```

![Parameter Binding with @Param](assets/parameter-binding-param.png)

## Converting SQL to JPQL

- **Remove nativeQuery flag**: Default behavior expects JPQL
- **Entity references**: Use entity class names instead of table names
- **Property access**: Reference entity properties, not database columns
- **IntelliSense support**: IDE provides autocompletion for entity properties

```java
// SQL version (nativeQuery = true)
@Query(value = "SELECT * FROM products p " +
       "WHERE p.price BETWEEN :min AND :max " +
       "ORDER BY p.name", 
       nativeQuery = true)

// JPQL version (default)
@Query("SELECT p FROM Product p " +
       "WHERE p.price BETWEEN :min AND :max " +
       "ORDER BY p.name")
List<Product> findProducts(@Param("min") BigDecimal min, 
                          @Param("max") BigDecimal max);
```

![SQL to JPQL Conversion](assets/sql-to-jpql-conversion.png)

## JPQL Benefits and IntelliSense

- **Entity-based queries**: Work with Java objects instead of database tables
- **IDE support**: Autocompletion for entity properties and relationships
- **Type safety**: Compile-time validation of entity references
- **Refactoring support**: Automatic updates when entity properties change

![JPQL IntelliSense Support](assets/jpql-intellisense-support.png)

**IntelliSense features:**
- **Entity completion**: `Ctrl+Space` shows available entities
- **Property completion**: `p.` shows all entity properties
- **Relationship navigation**: Access related entity properties
- **Syntax validation**: Real-time error checking

## JPA Buddy Query Generation

- **Automatic conversion**: Transform derived query methods to @Query
- **Method shortcuts**: Alt+Enter on method name for options
- **Extract JPQL Query**: Convert existing derived methods
- **Configuration options**: Choose named vs indexed parameters

![JPA Buddy Query Generation](assets/jpa-buddy-query-generation.png)

**Generation steps:**
1. **Position cursor**: On derived query method name
2. **Trigger action**: Press Alt+Enter
3. **Select option**: "Extract JPQL query and configure"
4. **Configure**: Choose method name and parameter style
5. **Generate**: Automatic @Query annotation creation

## Advanced JPQL Features

- **Join operations**: Access related entities in queries
- **Left joins**: Include entities even when relationships are null
- **Entity relationships**: Navigate object graph in queries
- **Complex conditions**: Combine multiple entity criteria

```java
@Query("SELECT p FROM Product p " +
       "JOIN p.category c " +
       "WHERE p.price BETWEEN :min AND :max " +
       "ORDER BY p.name")
List<Product> findProductsWithCategory(@Param("min") BigDecimal min, 
                                      @Param("max") BigDecimal max);

@Query("SELECT p FROM Product p " +
       "LEFT JOIN p.category c " +
       "WHERE c.name = :categoryName")
List<Product> findProductsByCategory(@Param("categoryName") String categoryName);
```

![Advanced JPQL Features](assets/advanced-jpql-features.png)

## Aggregate Functions in JPQL

- **COUNT function**: Count records matching criteria
- **Other functions**: SUM, MIN, MAX, AVG available
- **Return types**: Use appropriate return types (Long, Integer, BigDecimal)
- **Grouping support**: GROUP BY and HAVING clauses supported

```java
@Query("SELECT COUNT(*) FROM Product p " +
       "WHERE p.price BETWEEN :min AND :max")
Long countProducts(@Param("min") BigDecimal min, 
                   @Param("max") BigDecimal max);

@Query("SELECT SUM(p.price) FROM Product p " +
       "WHERE p.category.id = :categoryId")
BigDecimal getTotalPriceByCategory(@Param("categoryId") Long categoryId);
```

![Aggregate Functions in JPQL](assets/aggregate-functions-jpql.png)

## Update Operations with @Query

- **UPDATE statement**: Modify existing records with JPQL
- **@Modifying annotation**: Required for update/delete operations
- **SET clause**: Specify fields to update with new values
- **WHERE clause**: Filter records to update

```java
import org.springframework.data.jpa.repository.Modifying;

@Modifying
@Query("UPDATE Product p SET p.price = :newPrice " +
       "WHERE p.category.id = :categoryId")
void updatePriceByCategory(@Param("newPrice") BigDecimal newPrice,
                          @Param("categoryId") Byte categoryId);
```

![Update Operations with Query](assets/update-operations-query.png)

**@Modifying requirements:**
- **Mandatory annotation**: Must be present for UPDATE/DELETE operations
- **Return type**: Usually void for update operations
- **Transaction context**: Must be executed within transaction
- **Cache implications**: May require clearing persistence context

## Testing Update Operations

- **Service method**: Wrap repository call in service layer
- **Parameter preparation**: Convert primitive types as needed
- **Method invocation**: Call update method from main application

```java
@Service
public class UserService {
    
    public void updateProductPrices() {
        productRepository.updatePriceByCategory(
            BigDecimal.valueOf(10),  // Convert to BigDecimal
            (byte) 1                 // Cast to byte
        );
    }
}

// In main method
public static void main(String[] args) {
    var context = SpringApplication.run(Application.class, args);
    var service = context.getBean(UserService.class);
    service.updateProductPrices();
}
```

![Testing Update Operations](assets/testing-update-operations.png)

## Transaction Requirements

- **Update operations**: Require transaction context for execution
- **@Transactional annotation**: Add to service method calling update
- **Exception handling**: TransactionRequiredException thrown without transaction
- **Generated SQL**: Proper UPDATE statements generated

```java
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
    
    @Transactional  // Required for update operations
    public void updateProductPrices() {
        productRepository.updatePriceByCategory(
            BigDecimal.valueOf(10),
            (byte) 1
        );
    }
}
```

![Transaction Requirements](assets/transaction-requirements.png)

**Generated SQL output:**
```sql
UPDATE products SET price = ? WHERE category_id = ?
```

![Update SQL Statement Output](assets/update-sql-statement-output.png)

## Key Points

- **Main takeaway**: @Query annotation allows writing complex custom queries while keeping method names simple and readable
- **SQL vs JPQL**: Choose SQL for advanced features and performance, JPQL for database portability and type safety
- **Parameter binding**: Use @Param annotation to link method parameters to query parameters by name
- **JPQL advantages**: Entity-based queries with IntelliSense support, compile-time validation, and database independence
- **Update operations**: Require @Modifying annotation and must be executed within @Transactional context
- **JPA Buddy integration**: Can automatically convert derived query methods to @Query annotations with configuration options
- **Advanced features**: Support for joins, aggregate functions, and complex WHERE conditions in JPQL
- **Performance consideration**: Hand-written queries can offer better performance than generated derived query methods
- **Query flexibility**: Handle scenarios impossible with derived query method naming conventions
- **Development productivity**: IntelliSense and refactoring support make JPQL queries maintainable and less error-prone

## Links/References

- Video: 4.9.2-Writing-Custom-Queries-Using-_Query.mp4 (08:53)
- Previous: [Derived Query Methods](4.9.1-Derived-Query-Methods.md)
- Next: Dynamic Queries with Criteria API
- Reference: [Spring Data JPA @Query](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query)
- Reference: [JPQL Language Reference](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm)
- Reference: [JPA Buddy Plugin](https://plugins.jetbrains.com/plugin/15075-jpa-buddy)

---

**Created**: July 31, 2025  
**Last Modified**: July 31, 2025
